<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/andersm%C3%B6rtberg/" title="Anders Mörtberg" uri="https://www.jonmsterling.com/andersmörtberg/" display-uri="andersmörtberg" type="local">Anders Mörtberg</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/maxzeuner/" title="Max Zeuner" uri="https://www.jonmsterling.com/maxzeuner/" display-uri="maxzeuner" type="local">Max Zeuner</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2021</fr:year>
      <fr:month>1</fr:month>
      <fr:day>4</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/acmz-2021/</fr:uri>
    <fr:display-uri>acmz-2021</fr:display-uri>
    <fr:route>/acmz-2021/</fr:route>
    <fr:title text="Internalizing representation independence with univalence">Internalizing representation independence with univalence</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="doi">10.1145/3434293</fr:meta>
    <fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 5, Issue POPL</fr:meta>
    <fr:meta name="bibtex"><![CDATA[@article{acmz-2021,
  author = {Angiuli, Carlo and Cavallo, Evan and M\"{o}rtberg, Anders and Zeuner, Max},
  address = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  year = {2021},
  month = jan,
  doi = {10.1145/3434293},
  journal = {Proceedings of the ACM on Programming Languages},
  keywords = {Proof Assistants,Higher Inductive Types,Cubical Type Theory,Univalence,Representation Independence},
  number = {POPL},
  pages = {1--30},
  title = {Internalizing Representation Independence with Univalence},
  volume = {5},
}]]></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>In their usual form, representation independence metatheorems provide an external guarantee that two implementations of an abstract interface are interchangeable when they are related by an operation-preserving correspondence. If our programming language is dependently-typed, however, we would like to appeal to such invariance results within the language itself, in order to obtain correctness theorems for complex implementations by transferring them from simpler, related implementations. Recent work in proof assistants has shown that Voevodsky’s univalence principle allows transferring theorems between isomorphic types, but many instances of representation independence in programming involve non-isomorphic representations.</html:p>
    <html:p>In this paper, we develop techniques for establishing internal relational representation independence results in dependent type theory, by using higher inductive types to simultaneously quotient two related implementation types by a heterogeneous correspondence between them. The correspondence becomes an isomorphism between the quotiented types, thereby allowing us to obtain an equality of implementations by univalence. We illustrate our techniques by considering applications to matrices, queues, and finite multisets. Our results are all formalized in Cubical Agda, a recent extension of Agda which supports univalence and higher inductive types in a computationally well-behaved way.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000R/</fr:uri>
            <fr:display-uri>jms-000R</fr:display-uri>
            <fr:route>/jms-000R/</fr:route>
            <fr:title text="Background on homotopy and cubical type theory">Background on homotopy and cubical type theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>For more than four decades, dependent type theory has been positioned as the “common language” that can finally <fr:link href="/martin-loef-1982/" title="Constructive mathematics and computer programming" uri="https://www.jonmsterling.com/martin-loef-1982/" display-uri="martin-loef-1982" type="local">unify mathematics and computer programming</fr:link>: while it has never been controversial that a computer program is a form of mathematical construction, the running hypothesis of the type theoretic community has been the converse to this claim, namely that mathematical constructions should be viewed as programs that can in principle be executed by a physical machine — roughly, <html:strong>sets</html:strong> = <html:strong>types</html:strong> and <html:strong>elements</html:strong> = <html:strong>programs</html:strong>. Thus the struggle to realize this type theoretic hypothesis has been a two-way process, punctuated by moments at which the mathematical meaning of a programming construct is elucidated, or at which the computational content of a mathematical construct is uncovered.</html:p>
            <html:p>In the current millennium, a new identification has been taking shape in which <html:strong>types</html:strong> = <html:strong><html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-groupoids</html:span></html:strong> (homotopy types), which are an infinite-dimensional generalization of sets; the origins of this new perspective on type theory lie with <fr:link href="/hofmann-streicher-1998/" title="The groupoid interpretation of type theory" uri="https://www.jonmsterling.com/hofmann-streicher-1998/" display-uri="hofmann-streicher-1998" type="local">Hofmann and Streicher’s 1998 groupoid interpretation of type theory</fr:link>, combined with the revolutionary contributions of <fr:link href="/voevodsky-2006/" title="A very short note on the homotopy λ-calculus" uri="https://www.jonmsterling.com/voevodsky-2006/" display-uri="voevodsky-2006" type="local">Voevodsky</fr:link> and <fr:link href="/awodey-warren-2009/" title="Homotopy theoretic models of identity types" uri="https://www.jonmsterling.com/awodey-warren-2009/" display-uri="awodey-warren-2009" type="local">Awodey and Warren</fr:link> respectively. The main feature of the new language, dubbed <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local"><html:strong>homotopy type theory</html:strong></fr:link> or <html:strong>HoTT</html:strong>, is that isomorphisms between types are equipped with a new induction rule called univalence stating that all type theoretic constructs respect isomorphisms: to a first approximation, if <fr:tex display="inline"><![CDATA[A \cong  B]]></fr:tex> then <fr:tex display="inline"><![CDATA[P(A) \cong  P(B)]]></fr:tex> for any <fr:tex display="inline"><![CDATA[P]]></fr:tex>. The univalence principle is motivated by the phenomenon of homotopy invariance that pervades the large-scale structure of modern-day mathematics, from algebraic topology to algebraic geometry to mathematical physics; as a programming construct, univalence suggests <fr:link href="/acmz-2021/" title="Internalizing representation independence with univalence" uri="https://www.jonmsterling.com/acmz-2021/" display-uri="acmz-2021" type="local">new approaches</fr:link> to both generic and modular programming.</html:p>
            <html:p>Thus one of the main projects for the first decade of homotopy type theory was to substantiate the relationship between HoTT and mathematics on the one hand, and between HoTT and computer programming on the other hand. The question of whether homotopy type theoretic language can be interpreted in sheaves on arbitrary infinite-dimensional spaces (<html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-topoi</html:span>) has finally been resolved satisfactorily by <fr:link href="/shulman-2019/" title="All (∞,1)-toposes have strict univalent universes" uri="https://www.jonmsterling.com/shulman-2019/" display-uri="shulman-2019" type="local">Shulman</fr:link> in 2019. On the other hand, the computational interpretation of homotopy type theory has involved a reformulation of HoTT called <html:strong><fr:link href="/abchfl-2021/" title="Syntax and models of Cartesian cubical type theory" uri="https://www.jonmsterling.com/abchfl-2021/" display-uri="abchfl-2021" type="local">cubical</fr:link> <fr:link href="/angiuli-favonia-harper-2018/" title="Cartesian cubical computational type theory: constructive reasoning with paths and equalities" uri="https://www.jonmsterling.com/angiuli-favonia-harper-2018/" display-uri="angiuli-favonia-harper-2018" type="local">type</fr:link> <fr:link href="/cchm-2017/" title="Cubical type theory: a constructive interpretation of the univalence axiom" uri="https://www.jonmsterling.com/cchm-2017/" display-uri="cchm-2017" type="local">theory</fr:link></html:strong> that reorganizes the higher-dimensional structure discussed by considering all the points, lines, squares, cubes, hypercubes, and so-on that one can draw in a given type. The computational interpretation of the new cubical type theory can be split into two different conjectures:</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000S/</fr:uri>
                <fr:display-uri>jms-000S</fr:display-uri>
                <fr:route>/jms-000S/</fr:route>
                <fr:title text="Cubical canonicity">Cubical canonicity</fr:title>
                <fr:taxon>Conjecture</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>For any closed term <fr:tex display="inline"><![CDATA[\cdot \vdash  N:\mathsf {nat}]]></fr:tex> of cubical type theory, there exists a unique natural number <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\cdot \vdash  N\equiv  \bar {n}:\mathsf {nat}]]></fr:tex> where <fr:tex display="inline"><![CDATA[\bar {n}]]></fr:tex> is the encoding of the number <fr:tex display="inline"><![CDATA[n]]></fr:tex> as a term in the type theory.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000T/</fr:uri>
                <fr:display-uri>jms-000T</fr:display-uri>
                <fr:route>/jms-000T/</fr:route>
                <fr:title text="Decidability of cubical type theory">Decidability of cubical type theory</fr:title>
                <fr:taxon>Conjecture</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The assertions <fr:tex display="inline"><![CDATA[\Gamma \vdash  {A}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash {A\equiv  B}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash  M:A]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\Gamma \vdash  M\equiv  N: A]]></fr:tex> are all decidable.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <html:p>The <fr:link href="/jms-000S/" title="Cubical canonicity" uri="https://www.jonmsterling.com/jms-000S/" display-uri="jms-000S" type="local">canonicity conjecture</fr:link> ensures that terms written in cubical type theory can be thought of as computer programs, and was verified independently by <fr:link href="/huber-2018/" title="Canonicity for cubical type theory" uri="https://www.jonmsterling.com/huber-2018/" display-uri="huber-2018" type="local">Huber</fr:link> and <fr:link href="/angiuli-2019/" title="Computational semantics of cartesian cubical type theory" uri="https://www.jonmsterling.com/angiuli-2019/" display-uri="angiuli-2019" type="local">Angiuli</fr:link> for different variants of cubical type theory. The <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability conjecture</fr:link> is no less important, as it is a necessary ingredient to implement a <html:em>typechecker</html:em> or a <html:em>compiler</html:em> for a programming language based on cubical type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/pacmpl/</fr:uri>
            <fr:display-uri>pacmpl</fr:display-uri>
            <fr:route>/pacmpl/</fr:route>
            <fr:title text="Proceedings of the ACM on Programming Languages">Proceedings of the ACM on Programming Languages</fr:title>
            <fr:taxon>Journal</fr:taxon>
            <fr:meta name="external">https://dl.acm.org/journal/pacmpl</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><html:em>Proceedings of the ACM on Programming Languages</html:em> (PACMPL) is a Gold Open Access journal publishing research on all aspects of programming languages, from design to implementation and from mathematical formalisms to empirical studies. Each issue of the journal is devoted to a particular subject area within programming languages and will be announced through publicized Calls for Papers. All accepted papers receive two rounds of reviewing and authors can expect initial decisions regarding submissions in under 3 months. The journal operates in close collaboration with the Special Interest Group on Programming Languages (SIGPLAN) and is committed to making high-quality peer-reviewed scientific research in programming languages free of restrictions on both access and use.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
