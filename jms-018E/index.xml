<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>2</fr:month>
      <fr:day>16</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-018E/</fr:uri>
    <fr:display-uri>jms-018E</fr:display-uri>
    <fr:route>/jms-018E/</fr:route>
    <fr:title text="Decidability of regular expression matching">Decidability of <fr:link href="/jms-017C/" title="Regular expression matching" uri="https://www.jonmsterling.com/jms-017C/" display-uri="jms-017C" type="local">regular expression matching</fr:link></fr:title>
    <fr:taxon>Corollary</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expression</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. Then there exists an algorithm to compute whether a given <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u\in \Sigma ^\star ]]></fr:tex> <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">matches</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>The idea of the proof is to find a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex>; so for this we need only <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> rather than the full <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>. Then our algorithm is to feed the given string <fr:tex display="inline"><![CDATA[u]]></fr:tex> through <fr:tex display="inline"><![CDATA[M]]></fr:tex> and check whether the final state is accepting or not.</html:p>
</fr:mainmatter></fr:tree>
 
<html:p>There is a subtlety in the argument above: we need the <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> to have computably decidable equality of states. The way to deal with this is that <fr:tex display="inline"><![CDATA[M]]></fr:tex> has a <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local"><html:em>finite</html:em></fr:link> set of states, and so <fr:link href="/jms-00L0/" title="Isomorphic sets" uri="https://www.jonmsterling.com/jms-00L0/" display-uri="jms-00L0" type="local">isomorphic</fr:link> to a standard finite set of the form <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>, which has computably decidable equality. A more important subtlety is that we need it to be computably decidable whether a given state is an accepting state, and we also need the transition function to be computable; any subset of a finite set is going to be decidable for roughly the same reason—ahead of time, we can enumerate it as a list of numbers in <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>.</html:p></fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-018D/</fr:uri>
            <fr:display-uri>jms-018D</fr:display-uri>
            <fr:route>/jms-018D/</fr:route>
            <fr:title text="Kleene’s theorem and its consequences">Kleene’s theorem and its consequences</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We now come to the main result of this lecture.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018B/</fr:uri>
                <fr:display-uri>jms-018B</fr:display-uri>
                <fr:route>/jms-018B/</fr:route>
                <fr:title text="Kleene’s theorem">Kleene’s theorem</fr:title>
                <fr:taxon>Theorem</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>A <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> if and only if it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>By <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> and <fr:link href="/jms-0183/" title="Decompilation of NFAs" uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" /></fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <html:p>In light of the above, we will from now on refer mainly to <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">regular languages</fr:link>, and leave behind the non-standard terminology of <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">“automatical languages”</fr:link>. Several questions that we left unanswered (see <fr:link href="/jms-017F/" title="Questions about regular expression matching" uri="https://www.jonmsterling.com/jms-017F/" display-uri="jms-017F" type="local">Discussion <fr:contextual-number uri="https://www.jonmsterling.com/jms-017F/" display-uri="jms-017F" /></fr:link>) can now be addressed in light of <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018E/</fr:uri>
                <fr:display-uri>jms-018E</fr:display-uri>
                <fr:route>/jms-018E/</fr:route>
                <fr:title text="Decidability of regular expression matching">Decidability of <fr:link href="/jms-017C/" title="Regular expression matching" uri="https://www.jonmsterling.com/jms-017C/" display-uri="jms-017C" type="local">regular expression matching</fr:link></fr:title>
                <fr:taxon>Corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expression</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. Then there exists an algorithm to compute whether a given <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u\in \Sigma ^\star ]]></fr:tex> <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">matches</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>The idea of the proof is to find a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex>; so for this we need only <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> rather than the full <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>. Then our algorithm is to feed the given string <fr:tex display="inline"><![CDATA[u]]></fr:tex> through <fr:tex display="inline"><![CDATA[M]]></fr:tex> and check whether the final state is accepting or not.</html:p>
</fr:mainmatter></fr:tree>
 
<html:p>There is a subtlety in the argument above: we need the <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> to have computably decidable equality of states. The way to deal with this is that <fr:tex display="inline"><![CDATA[M]]></fr:tex> has a <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local"><html:em>finite</html:em></fr:link> set of states, and so <fr:link href="/jms-00L0/" title="Isomorphic sets" uri="https://www.jonmsterling.com/jms-00L0/" display-uri="jms-00L0" type="local">isomorphic</fr:link> to a standard finite set of the form <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>, which has computably decidable equality. A more important subtlety is that we need it to be computably decidable whether a given state is an accepting state, and we also need the transition function to be computable; any subset of a finite set is going to be decidable for roughly the same reason—ahead of time, we can enumerate it as a list of numbers in <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>.</html:p></fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018F/</fr:uri>
                <fr:display-uri>jms-018F</fr:display-uri>
                <fr:route>/jms-018F/</fr:route>
                <fr:title text="Closure of regular languages under complementation">Closure of <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> under complementation</fr:title>
                <fr:taxon>Corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[L]]></fr:tex> is a <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, then so is its complement <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[L]]></fr:tex> be a <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link>, and so by <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link> we have some <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[L=\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>. We define a new <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (\lnot {M}\right )\mathclose {}} = \Sigma ^\star \setminus  L]]></fr:tex> by setting <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> to have the same states, transition function, and starting state as <fr:tex display="inline"><![CDATA[M]]></fr:tex> but with the opposite set of accepting states:</html:p>
 <fr:tex display="block"><![CDATA[
  F_{\lnot {M}} = Q_{M}\setminus F_{M}
 ]]></fr:tex>

 <html:p>The desired property of <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> is immediate.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018G/</fr:uri>
                <fr:display-uri>jms-018G</fr:display-uri>
                <fr:route>/jms-018G/</fr:route>
                <fr:title text="Closure of regular languages under intersection">Closure of <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> under intersection</fr:title>
                <fr:taxon>Corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>The intersection of two <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We fix <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> <fr:tex display="inline"><![CDATA[L_1,L_2\subseteq \Sigma ^\star ]]></fr:tex> and consider the intersection <fr:tex display="inline"><![CDATA[L_1\cap  L_2]]></fr:tex>. By De Morgan’s laws, we have:</html:p>

 <fr:tex display="block"><![CDATA[
  L_1\cap  L_2 =
  \Sigma ^\star \setminus {\mathopen {}\left (
   {\mathopen {}\left (
    \Sigma ^\star \setminus  L_1
   \right )\mathclose {}}\cup  {\mathopen {}\left (
    \Sigma ^\star \setminus  L_2
   \right )\mathclose {}}
  \right )\mathclose {}}
 ]]></fr:tex>

 <html:p>Because <fr:link href="/jms-018F/" title="Closure of regular languages under complementation" uri="https://www.jonmsterling.com/jms-018F/" display-uri="jms-018F" type="local"><fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are closed under complementation</fr:link>, it suffices to check that <fr:tex display="block"><![CDATA[
   {\mathopen {}\left (
    \Sigma ^\star \setminus  L_1
   \right )\mathclose {}}\cup  {\mathopen {}\left (
    \Sigma ^\star \setminus  L_2
   \right )\mathclose {}}
 ]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">Regular languages</fr:link> are, by definition, closed under finite unions, so it remains to check that the complements <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L_2]]></fr:tex> are <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. This follows from our assumption that <fr:tex display="inline"><![CDATA[L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[L_2]]></fr:tex> are <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> via <fr:link href="/jms-018F/" title="Closure of regular languages under complementation" uri="https://www.jonmsterling.com/jms-018F/" display-uri="jms-018F" type="local">closure under complements</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018H/</fr:uri>
                <fr:display-uri>jms-018H</fr:display-uri>
                <fr:route>/jms-018H/</fr:route>
                <fr:title text="Decidability of regular expression equivalence">Decidability of <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link> equivalence</fr:title>
                <fr:taxon>Corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>It is decidable whether two regular expressions <fr:tex display="inline"><![CDATA[R,S]]></fr:tex> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> are equivalent in the sense that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We note that two subsets are equal if and only if the intersection of one with the complement of the other is empty, and vice versa:</html:p>

 <fr:tex display="block"><![CDATA[
  \begin {aligned}
   & \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}
   \\
   &\quad \Leftrightarrow 
   \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\subseteq \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\land  \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\subseteq \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}
   \\
   &\quad \Leftrightarrow 
   {\mathopen {}\left ({\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}} =\varnothing  = {\mathopen {}\left ({\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}
  \end {aligned}
 ]]></fr:tex>

 <html:p>We therefore let <fr:tex display="inline"><![CDATA[M]]></fr:tex> and <fr:tex display="inline"><![CDATA[N]]></fr:tex> be two <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link> recognising the language <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> respectively. (These <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link> can be obtained computably using the compilation procedure by which we proved <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link>.) It follows then that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\varnothing =\mathcal {L}{\mathopen {}\left (N\right )\mathclose {}}]]></fr:tex>.</html:p>

 <html:p>So it now remains to check whether there exists <html:em>any</html:em> <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> at all that is accepted by <fr:tex display="inline"><![CDATA[M]]></fr:tex> and likewise for <fr:tex display="inline"><![CDATA[N]]></fr:tex>. We do not have to check <html:em>all</html:em> <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, which would be impossible: we observe that the number of states in <fr:tex display="inline"><![CDATA[M]]></fr:tex> bounds the number of transitions required to reach an accepting state, because any loops about a state <fr:tex display="inline"><![CDATA[q]]></fr:tex> can be excised from the path without changing the result. This is a special property of the <fr:link href="/jms-017J/" title="Kinds of finite automata" uri="https://www.jonmsterling.com/jms-017J/" display-uri="jms-017J" type="local">finite automata</fr:link> that we have studied so far, corresponding to the fact that they have no memory.</html:p>

</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-018B/</fr:uri>
            <fr:display-uri>jms-018B</fr:display-uri>
            <fr:route>/jms-018B/</fr:route>
            <fr:title text="Kleene’s theorem">Kleene’s theorem</fr:title>
            <fr:taxon>Theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>A <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> if and only if it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>By <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> and <fr:link href="/jms-0183/" title="Decompilation of NFAs" uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" /></fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-018A/</fr:uri>
            <fr:display-uri>jms-018A</fr:display-uri>
            <fr:route>/jms-018A/</fr:route>
            <fr:title text="All regular languages are automatical">All <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link></fr:title>
            <fr:taxon>Corollary</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>If a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> <fr:tex display="inline"><![CDATA[L]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>, then it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[U]]></fr:tex> be the set of all <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expressions</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>. We wish to show that the set of all <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expressions</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is contained in <fr:tex display="inline"><![CDATA[U]]></fr:tex>. By <fr:link href="/jms-0171/" title="Rule induction" uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" type="local">rule induction</fr:link> it suffices to check the following cases:</html:p>

 <html:ol><html:li>We need to know that <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a},\texttt {Null}, \texttt {Never} \in  U]]></fr:tex>, which is the same as to say that the languages <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a\right \}\mathclose {}}, {\mathopen {}\left \{\epsilon \right \}\mathclose {}}, \varnothing ]]></fr:tex> are all <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>. This is <fr:link href="/jms-0186/" title="automaticality of basic regular languages" uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R,S\in  U]]></fr:tex> then <fr:tex display="inline"><![CDATA[\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that the language <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\cup \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> assuming that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> are. This is <fr:link href="/jms-0187/" title="Closure of automaticality under union" uri="https://www.jonmsterling.com/jms-0187/" display-uri="jms-0187" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0187/" display-uri="jms-0187" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R,S\in  U]]></fr:tex> then <fr:tex display="inline"><![CDATA[\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that the language <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}} = {\mathopen {}\left \{uv\,\middle \vert \,u\in \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}},v\in \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right \}\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> assuming that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> are. This is <fr:link href="/jms-0188/" title="Closure of automaticality under concatenation" uri="https://www.jonmsterling.com/jms-0188/" display-uri="jms-0188" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0188/" display-uri="jms-0188" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R\in  U]]></fr:tex> then so is <fr:tex display="inline"><![CDATA[\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that if <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> then so is <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}^\star ]]></fr:tex>. This is <fr:link href="/jms-0189/" title="Closure of automaticality under repetition" uri="https://www.jonmsterling.com/jms-0189/" display-uri="jms-0189" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0189/" display-uri="jms-0189" /></fr:link>.</html:li></html:ol>

 <html:p>We are done.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-017L/</fr:uri>
            <fr:display-uri>jms-017L</fr:display-uri>
            <fr:route>/jms-017L/</fr:route>
            <fr:title text="Deterministic finite automaton">Deterministic finite automaton</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <html:em><html:strong>deterministic finite automaton</html:strong></html:em> or <html:em><html:strong>DFA</html:strong></html:em> for short is an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> for which the transition relation <fr:tex display="inline"><![CDATA[\Delta \colon  Q\times  \Sigma \mathbin {\nrightarrow } Q]]></fr:tex> is a <fr:link href="/jms-00KF/" title="Function" uri="https://www.jonmsterling.com/jms-00KF/" display-uri="jms-00KF" type="local">function</fr:link>, i.e. a <fr:link href="/jms-00KF/" title="Function" uri="https://www.jonmsterling.com/jms-00KF/" display-uri="jms-00KF" type="local">total</fr:link> and <fr:link href="/jms-00K7/" title="Partial function" uri="https://www.jonmsterling.com/jms-00K7/" display-uri="jms-00K7" type="local">functional</fr:link> relation. This states, in other words, that to each state each state <fr:tex display="inline"><![CDATA[q\in  Q]]></fr:tex> can transition along each symbol <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex> to one and only one state, which we conventionally write <fr:tex display="inline"><![CDATA[\delta {\mathopen {}\left (q,a\right )\mathclose {}}]]></fr:tex>. Indeed, we will often write <fr:tex display="inline"><![CDATA[M = (Q,\Sigma ,\delta ,s,F)]]></fr:tex> for a DFA. In this case, we have <fr:tex display="inline"><![CDATA[q \mathrel {\xrightarrow {a}}q']]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[\delta {\mathopen {}\left (q,a\right )\mathclose {}}=q']]></fr:tex>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017M/</fr:uri>
                <fr:display-uri>jms-017M</fr:display-uri>
                <fr:route>/jms-017M/</fr:route>
                <fr:title text="Non-exclusive privatives in mathematical English">Non-exclusive privatives in mathematical English</fr:title>
                <fr:taxon>Aside</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>As an aside, it might feel strange to speak of “deterministic non-deterministic finite automata”. This is OK but can take some getting used to: mathematicians have discovered over the past several centuries that it is better for negations in terminology to mean “not necessarily” rather than “definitely not”; this is similar to the way that mathematicians often say “greater than” to mean “greater than or equal to”, reserving “strictly greater than” for the notion that excludes equality.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-017D/</fr:uri>
            <fr:display-uri>jms-017D</fr:display-uri>
            <fr:route>/jms-017D/</fr:route>
            <fr:title text="The matching relation for regular expressions">The matching relation for regular expressions</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The matching relation <fr:tex display="inline"><![CDATA[u\mathrel {\textsf {matches}}R]]></fr:tex> is given by an <html:em>inductive</html:em> definition over <fr:tex display="inline"><![CDATA[\Sigma ^\star \times \mathsf {Regexp}_{\Sigma }]]></fr:tex>.</html:p>
            <fr:tex display="block"><![CDATA[
 \begin {gathered}
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({a},{\texttt {Sym}_{a}}\right )\mathclose {}}
  \quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Null}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({v},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({w},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({vw},{\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({v},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({uv},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


 \end {gathered}
]]></fr:tex>
            <html:p>We will write <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> for the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> matching or “recognised” by the regular expression <fr:tex display="inline"><![CDATA[R]]></fr:tex>:</html:p>
            <fr:tex display="block"><![CDATA[
 \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}} =
 {\mathopen {}\left \{
  u\in \Sigma ^\star 
  \mid 
  u\mathrel {\textsf {matches}}R
 \right \}\mathclose {}}
]]></fr:tex>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-017C/</fr:uri>
            <fr:display-uri>jms-017C</fr:display-uri>
            <fr:route>/jms-017C/</fr:route>
            <fr:title text="Regular expression matching">Regular expression matching</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We have seen the <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local"><html:em>syntax</html:em> of regular expressions</fr:link> in both concrete and abstract form. What about <html:em>semantics</html:em>, i.e. what do regular expressions actually do? The meaning of a given regular expression over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is a <html:em><html:strong>matching predicate</html:strong></html:em> on <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> that says when a given string is matched by the regular expression. In this course, we are particularly interested in the class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> that can be recognised by regular expressions, and later on we will develop tools that allow us to show that some <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> are too complex to be recognised by regular expressions. In the meanwhile, we will first explain how matching works.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017D/</fr:uri>
                <fr:display-uri>jms-017D</fr:display-uri>
                <fr:route>/jms-017D/</fr:route>
                <fr:title text="The matching relation for regular expressions">The matching relation for regular expressions</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The matching relation <fr:tex display="inline"><![CDATA[u\mathrel {\textsf {matches}}R]]></fr:tex> is given by an <html:em>inductive</html:em> definition over <fr:tex display="inline"><![CDATA[\Sigma ^\star \times \mathsf {Regexp}_{\Sigma }]]></fr:tex>.</html:p>
                <fr:tex display="block"><![CDATA[
 \begin {gathered}
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({a},{\texttt {Sym}_{a}}\right )\mathclose {}}
  \quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Null}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({v},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({w},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({vw},{\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({v},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({uv},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


 \end {gathered}
]]></fr:tex>
                <html:p>We will write <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> for the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> matching or “recognised” by the regular expression <fr:tex display="inline"><![CDATA[R]]></fr:tex>:</html:p>
                <fr:tex display="block"><![CDATA[
 \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}} =
 {\mathopen {}\left \{
  u\in \Sigma ^\star 
  \mid 
  u\mathrel {\textsf {matches}}R
 \right \}\mathclose {}}
]]></fr:tex>
              </fr:mainmatter>
            </fr:tree>
            <html:p>We can also obtain a version of the <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">matching relation</fr:link> between <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> and <fr:link href="/jms-0176/" title="Regular expressions (concrete syntax)" uri="https://www.jonmsterling.com/jms-0176/" display-uri="jms-0176" type="local"><html:em>concrete</html:em> regular expressions</fr:link> by <fr:link href="/jms-00IN/" title="Relational composite" uri="https://www.jonmsterling.com/jms-00IN/" display-uri="jms-00IN" type="local">relational composition</fr:link> with the (transpose of) the <fr:link href="/jms-017B/" title="Precedence parsing for regular expressions" uri="https://www.jonmsterling.com/jms-017B/" display-uri="jms-017B" type="local">parsing relation</fr:link>. Alternatively, we can simply <html:em>write</html:em> the concrete syntax as a mere notation (to be eliminated by the reader immediately) for the abstract syntax. In fact, that is what we will do in the future.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017E/</fr:uri>
                <fr:display-uri>jms-017E</fr:display-uri>
                <fr:route>/jms-017E/</fr:route>
                <fr:title text="Examples of regular expression matching">Examples of regular expression matching</fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Consider <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">regular expression matching</fr:link> over the alphabet <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex>.</html:p>
                <html:ol><html:li><fr:tex display="inline"><![CDATA[a\vert  b]]></fr:tex> is matched by each symbol in <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[(a\vert  b)*]]></fr:tex> is matched every <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[b(a\vert  b)*]]></fr:tex> is matched by any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> that starts with a <fr:tex display="inline"><![CDATA[b]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[((a\vert  b)(a\vert  b))*]]></fr:tex> is matched by any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> of even length over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[(\underline {\epsilon }\vert  a)(\underline {\epsilon }\vert  b)\vert  bb]]></fr:tex> is matched just by the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>, <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, <fr:tex display="inline"><![CDATA[ab]]></fr:tex>, and <fr:tex display="inline"><![CDATA[bb]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[\varnothing  b\vert  a]]></fr:tex> is matched only by the symbol <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017F/</fr:uri>
                <fr:display-uri>jms-017F</fr:display-uri>
                <fr:route>/jms-017F/</fr:route>
                <fr:title text="Questions about regular expression matching">Questions about regular expression matching</fr:title>
                <fr:taxon>Discussion</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Here are some questions for discussion.</html:p>
                <html:ol><html:li>Is there an algorithm which, given a string <fr:tex display="inline"><![CDATA[u]]></fr:tex> and a regular expression <fr:tex display="inline"><![CDATA[r]]></fr:tex>, computes whether or not <fr:tex display="inline"><![CDATA[u]]></fr:tex> matches <fr:tex display="inline"><![CDATA[r]]></fr:tex>?</html:li>
 <html:li>In formulating the definition of regular expressions, have we missed out on some practically useful notions of pattern?</html:li>
 <html:li>Is there an algorithm that will compute whether two regular expressions generate the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>?</html:li>
 <html:li>Is every <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> of generated by a regular expression?</html:li></html:ol>
                <html:p>We will come back to these questions in subsequent lectures. In the meantime, we can say:</html:p>
                <html:ol><html:li><html:em>Is there an algorithm which, given a string <fr:tex display="inline"><![CDATA[u]]></fr:tex> and a regular expression <fr:tex display="inline"><![CDATA[r]]></fr:tex>, computes whether or not <fr:tex display="inline"><![CDATA[u]]></fr:tex> matches <fr:tex display="inline"><![CDATA[r]]></fr:tex>?</html:em> Yes. One very simple way is to simply use the rules of <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" /></fr:link> as a search algorithm, but this is not very efficient; better ways to decide regular expression matching can be achieved using <html:em>finite automata</html:em>, which we will study in the next lecture.</html:li>
 <html:li><html:em>In formulating the definition of regular expressions, have we missed out on some practically useful notions of pattern?</html:em>
  Yes! For example, it can be useful to specify a <html:em>range</html:em> of symbols (including all symbols!) over an alphabet like most practical regular expression libraries allow. A more sophisticated example is complementation, where a <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> matches <fr:tex display="inline"><![CDATA[\mathord {\sim }(r)]]></fr:tex> if and only if it does <html:em>not</html:em> match <fr:tex display="inline"><![CDATA[r]]></fr:tex>. We will ultimately see that the complement of any regular expression already exists—but it can be useful to include it as a built-in feature.</html:li>
 <html:li><html:em>Is there an algorithm that will compute whether two regular expressions generate the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>?</html:em> Yes, but we will need the theory of finite automata to see that this is the case.</html:li>
 <html:li><html:em>Is every <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> of generated by a regular expression?</html:em> No: we will ultimately learn a technique, called the <html:em>pumping lemma</html:em> to find counter-examples.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0179/</fr:uri>
            <fr:display-uri>jms-0179</fr:display-uri>
            <fr:route>/jms-0179/</fr:route>
            <fr:title text="Regular expressions (abstract syntax)">Regular expressions (abstract syntax)</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The <html:em>abstract</html:em> syntax of regular expressions over an alphabet <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> will be represented by trees whose vertices are labelled by the symbols <fr:tex display="inline"><![CDATA[\texttt {Union}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Concat}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Star}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Null}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Never}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a}]]></fr:tex> for any <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex>. More specifically, each node of a tree will be of the following form:</html:p>
            <html:ol><html:li>A node labelled by either <fr:tex display="inline"><![CDATA[\texttt {Union}]]></fr:tex> or <fr:tex display="inline"><![CDATA[\texttt {Concat}]]></fr:tex> has exactly two children.</html:li>
 <html:li>A node labelled by <fr:tex display="inline"><![CDATA[\texttt {Star}]]></fr:tex> has exactly one child.</html:li>
 <html:li>A node labelled by <fr:tex display="inline"><![CDATA[\texttt {Null}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Never}]]></fr:tex>, or <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a}]]></fr:tex> has no children.</html:li></html:ol>
            <html:p>The plain English description above could be expressed as an <fr:link href="/jms-016N/" title="Inductive definitions" uri="https://www.jonmsterling.com/jms-016N/" display-uri="jms-016N" type="local">inductive definition</fr:link> of a subset of the set of all trees.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-016I/</fr:uri>
            <fr:display-uri>jms-016I</fr:display-uri>
            <fr:route>/jms-016I/</fr:route>
            <fr:title text="String over an alphabet">String over an alphabet</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> be an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link>. A <html:em><html:strong>string of length <fr:tex display="inline"><![CDATA[n]]></fr:tex></html:strong></html:em> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined to be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-tuple of elements of <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. We write these without any punctuation between them. For example, <fr:tex display="inline"><![CDATA[aaabc]]></fr:tex> is a string over the Latin alphabet; we will write <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> for the empty string. The set of all strings (of any length) over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is written <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex>; for a string <fr:tex display="inline"><![CDATA[u\in \Sigma ^\star ]]></fr:tex>, we will write <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u\right \rvert \mathclose {}}\in \mathbb {N}]]></fr:tex> for its length.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-016H/</fr:uri>
            <fr:display-uri>jms-016H</fr:display-uri>
            <fr:route>/jms-016H/</fr:route>
            <fr:title text="Alphabet">Alphabet</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>An <html:em><html:strong>alphabet</html:strong></html:em> is specified by giving a <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local">finite set</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> whose elements are called <html:em>symbols</html:em>. Any <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local">finite set</fr:link> can serve as an alphabet as far as we are concerned.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00LX/</fr:uri>
            <fr:display-uri>jms-00LX</fr:display-uri>
            <fr:route>/jms-00LX/</fr:route>
            <fr:title text="Finite set">Finite set</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A set <fr:tex display="inline"><![CDATA[A]]></fr:tex> is said to be <html:em><html:strong>finite</html:strong></html:em> or have <html:em><html:strong>finite cardinality</html:strong></html:em> when it is <fr:link href="/jms-00L0/" title="Isomorphic sets" uri="https://www.jonmsterling.com/jms-00L0/" display-uri="jms-00L0" type="local">isomorphic</fr:link> to a set of the form <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [n\right  ]\mathclose {}}]]></fr:tex> for some <fr:tex display="inline"><![CDATA[n\in  \mathbb {N}]]></fr:tex>; in this case, we therefore have <fr:tex display="inline"><![CDATA[\mathord {\#}{A}=n]]></fr:tex>. (Recall that <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [n\right  ]\mathclose {}}]]></fr:tex> is the standard <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[n]]></fr:tex>-element</html:span> set <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{i\in \mathbb {N}\,\middle \vert \,0\leq  i < n\right \}\mathclose {}}]]></fr:tex>.)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00L0/</fr:uri>
            <fr:display-uri>jms-00L0</fr:display-uri>
            <fr:route>/jms-00L0/</fr:route>
            <fr:title text="Isomorphic sets">Isomorphic sets</fr:title>
            <fr:taxon>Definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Two sets <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are said to be <html:em><html:strong>isomorphic</html:strong></html:em> (and have the <html:em><html:strong>same cardinality</html:strong></html:em>) whenever there is a <fr:link href="/jms-00KR/" title="Bijection" uri="https://www.jonmsterling.com/jms-00KR/" display-uri="jms-00KR" type="local">bijection</fr:link> between them. In this case, we write <fr:tex display="inline"><![CDATA[A\cong  B]]></fr:tex> or <fr:tex display="inline"><![CDATA[\mathord {\#}{A}=\mathord {\#}{B}]]></fr:tex></html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
