\title{2023-09-17}
\date{2023-09-17}

\author{jonmsterling}
\taxon{entry}
\import{base-macros}

\let\QTT{[QTT](atkey-2018)}
\let\STC{[STC](sterling-2021-thesis)}
\let\ECat{#{\mathscr{E}}}
\let\One{#{\mathbf{1}}}
\let\QCat{#{\mathscr{Q}}}
\let\FCat{#{\mathscr{F}}}

\p{I have been thinking again about the relationship between [quantitative type theory](atkey-2018) and [synthetic Tait computability](sterling-2021-thesis) and other approaches to type refinements. One of the defining characteristics of \QTT that I thought distinguished it from \STC was the treatment of types: in \QTT, types only depend on the “computational” / unrefined aspect of their context, whereas in \STC, types depend on everything. In the past, I believed that this was due to the \em{realizability interpretation} of \QTT, in contrast with \STC’s \em{gluing interpretation}. It is now clear to me that (1) \QTT is actually glued (in the sense of \em{q-realizability}, no pun intended), and (2) \mark{the nonstandard interpretation of types in \QTT corresponds to adding an \em{additional} axiom to STC, namely the tininess of the generic proposition.}}

\p{My thoughts on the precise relationship between the \QTT models and Artin gluing will be elucidated at a different time. Today, I will restrict myself to sketching an interpretation of a QTT-style language in STC assuming the generic proposition is internally tiny.}

\p{Let \QCat be an elementary topos equipped with a \em{internally tiny} subterminal object #{\P\hookrightarrow\One} inducing an open subtopos #{\ECat\simeq\Sl{\QCat}{\P}\hookrightarrow\QCat} and its complementary closed subtopos #{\FCat\hookrightarrow\QCat}. Because #{\P} is tiny, the monad #{\bigcirc \equiv j_*j^* : \QCat\to\QCat} corresponding to the open immersion #{j : \ECat\hookrightarrow\QCat} has a right adjoint #{\square : \QCat\to \QCat}.}

\proof{
  \p{As #{\bigcirc \equiv j_*j^*} is the exponential functor #{\prn{-}^\P}, its right adjoint #{\square} is therefore the “root functor” #{\prn{-}_\P} that exhibits #{\P} as an internally tiny object.}
}

\p{Although #{\square} lifts to each slice of \QCat, these liftings do not commute with base change; this will, however, not be an obstacle for us.}

\p{We now consider the interpretation of a language of (potentially quantitative) refinements in to \QCat. A context #{\Gamma} is interpreted by an object of #{\QCat}; a type #{\Gamma\vdash A} is interpreted by a family #{A\to \bigcirc{\Gamma}}; a term #{\Gamma\vdash a : A} is interpreted as a section of #{A\to\bigcirc{\Gamma}}.}

\let\VV{#{\mathcal{V}}}
\let\UU{#{\mathcal{U}}}

\p{So far we have not needed to use the amazing write adjoint #{\bigcirc\dashv\square}, which will come into play when we introduce a universe (either for the purpose of interpreting universes of refinement types, or for the purpose of strictifying the model that we have sketched). Let \VV be a (standard) universe in \QCat; we shall then interpret the corresponding universe of refinements as #{\UU:\equiv \square\VV}. To see that #{\UU} classifies #{\VV}-small families of refinements, we compute as follows:}

\ol{
  \li{An code #{\Gamma\vdash\hat{A} : \UU} is given by a section of the projection #{\Gamma\times\square{\VV}\to\Gamma}, which amounts to nothing more than a morphism #{\hat{A}:\Gamma\to\square{\VV}}.}
  \li{By adjoint transpose, this is the same as a morphism #{\hat{A}^\sharp : \bigcirc{\Gamma}\to\VV}.}
}

\p{Thus we see that if \VV is generic for #{\VV}-small families of (arbitrary) types in \QCat, then #{\UU \equiv \square\VV} is generic for #{\VV}-small families of type refinements, i.e. types whose context is #{\bigcirc}-modal.}
