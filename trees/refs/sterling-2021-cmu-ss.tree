\title{Abstraction, composition, and the phase distinction}
\date{2021-8-24}
\taxon{reference}

\author{jonmsterling}
\tag{seminar}
\tag{stc}


\meta{slides}{https://www.jonmsterling.com/slides/sterling-2021-cmu-ss.pdf}



\meta{venue}{CMU Speakers Club}
\p{Programmers use abstraction to hide representation details from ourselves: either to avoid mistakes (e.g. confusing a list index with a length) or to exploit representation invariants (e.g. two implementations of the QUEUE interface are indistinguishable). These abstraction boundaries can unfortunately impede the linking of smaller program units into efficient composite programs, because compilers must exploit representation details in order to produce efficient code.  Sometimes seen as the "waterloo of separate compilation", the need to break abstraction is answered by whole-program analysis techniques that break all abstractions (as in the MLton compiler for Standard ML). Separate compilation, however, has a number of advantages including speed, parallelization, and elegance.}\p{We present an alternative type theoretic account of abstraction-breaking during compilation based on the famous phase distinction of ML languages; rather than distinguishing between compiletime and runtime, we focus on separating "devtime" from compiletime. Our framework allows the programmer to selectively reveal representation details to the compiler without giving up the representation independence properties guaranteed by "devtime" type correctness.  We also describe an application to the problem of printf-debugging, which is ordinarily obstructed by abstraction.}