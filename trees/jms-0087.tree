\title{an XSLT 2.0 transformer to convert [Bike](jms-0085) outlines to HTML}
\author{jonmsterling}
\date{2023-08-29}
\taxon{listing}
\meta{external}{https://git.sr.ht/~jonsterling/bike-convertors/tree/main/item/bike-to-html.xsl}

\p{We can write convert [Bike](jms-0085) outlines to reasonable HTML using an XSLT 2.0 stylesheet, \code{bike-to-html.xsl} detailed below.}

\pre{\startverb%
<?xml version="1.0"?>

<xsl:stylesheet version="2.0"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xhtml="http://www.w3.org/1999/xhtml"
  exclude-result-prefixes="xhtml">

  <xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes" />
  <xsl:strip-space elements="*" />
\stopverb}

\p{We will allow several tags to be copied verbatim into the output, as [Bike](jms-0085) uses these in the same way that idiomatic HTML does.}

\pre{\startverb%
  <xsl:template match="xhtml:html | xhtml:body | xhtml:code | xhtml:strong | xhtml:em | xhtml:mark">
    <xsl:copy>
      <xsl:apply-templates select="node()|@*" />
    </xsl:copy>
  </xsl:template>
\stopverb}

\p{[Bike](jms-0085) leaves behind a lot of empty \code{span} elements; we drop these.}

\pre{\startverb%
  <xsl:template match="xhtml:span">
    <xsl:apply-templates />
  </xsl:template>
\stopverb}

\p{[Bike](jms-0085) uses \code{ul} for all lists; the list type is determined not at this level, but rather by each individual item’s \code{@data-type} attribute. To get this data into the HTML list model, we must group items that have the same \code{@data-type} and wrap them in an appropriate list-forming element.}

\p{To do this, we use XSLT 2.0’s \code{xsl:for-each-group} instruction to group adjacent \code{li} elements by their \code{@data-type} attribute.  (It is extremely difficult and error-prone to write equivalent code in the more widely available XSLT 1.0.) We must convert \code{@data-type} to a string: otherwise, the transformer will crash when it encounters an item without a \code{@data-type} attribute.}

\pre{\startverb%
  <xsl:template match="xhtml:ul">
    <xsl:for-each-group select="xhtml:li" group-adjacent="string(@data-type)">
      <xsl:choose>
        <xsl:when test="@data-type='ordered' or @data-type='task'">
          <ol>
            <xsl:apply-templates select="current-group()" />
          </ol>
        </xsl:when>
        <xsl:when test="@data-type='unordered'">
          <ul>
            <xsl:apply-templates select="current-group()" />
          </ul>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="current-group()" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:template>
\stopverb}

\p{Next, we match each individual \code{li} element; the content of a list item is stored in a \code{p} element directly under \code{li}, so we let the transformer fall thorugh the parent and then format the content underneath according to the \code{@data-type} of the item.}

\pre{\startverb%
  <xsl:template match="xhtml:li">
    <xsl:apply-templates />
  </xsl:template>

  <xsl:template
    match="xhtml:li[@data-type='ordered' or @data-type='unordered' or @data-type='task']/xhtml:p">
    <li>
      <xsl:apply-templates />
    </li>
  </xsl:template>
\stopverb}

\p{[Bike](jms-0085) has correctly adopted the optimal [explicit](tfmt-000D) and [relative](tfmt-000B) model of hierarchy, in contrast to HTML; this means that the depth of a heading is not reflected in the element that introduces it, but is instead inferred from its actual position in the outline hierarchy. To convert [Bike](jms-0085) outlines to idiomatic HTML, we must flatten the hierarchy and introduce explicit heading levels; luckily, this is easy to accomplish in XSLT by counting the ancestors of \code{heading} type.}

\pre{\startverb%
  <xsl:template match="xhtml:li[@data-type='heading']/xhtml:p">
    <xsl:element
      name="h{count(ancestor::xhtml:li[@data-type='heading'])}">
      <xsl:apply-templates />
    </xsl:element>
  </xsl:template>
\stopverb}

\p{The remainder of the row types are not difficult to render; you may prefer alternative formatting depending on your goals.}

\pre{\startverb%
  <xsl:template match="xhtml:li[@data-type='quote']/xhtml:p">
    <blockquote>
      <xsl:apply-templates />
    </blockquote>
  </xsl:template>

  <xsl:template match="xhtml:li[@data-type='note']/xhtml:p">
    <p>
      <em>
        <xsl:apply-templates />
      </em>
    </p>
  </xsl:template>

  <xsl:template match="xhtml:li[not(@data-type)]/xhtml:p">
    <p>
      <xsl:apply-templates />
    </p>
  </xsl:template>
</xsl:stylesheet>
\stopverb}

