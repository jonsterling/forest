<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://www.jonmsterling.com/alexandergrothendieck/</fr:uri>
    <fr:display-uri>alexandergrothendieck</fr:display-uri>
    <fr:route>/alexandergrothendieck/</fr:route>
    <fr:title text="Alexander Grothendieck">Alexander Grothendieck</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:meta name="institution">Université de Montpellier, Institut des hautes études
scientifiques</fr:meta>
    <fr:meta name="position">Professor (Deceased)</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>31</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0084/</fr:uri>
            <fr:display-uri>jms-0084</fr:display-uri>
            <fr:route>/jms-0084/</fr:route>
            <fr:title text="Scientific refereeing using Bike Outliner">Scientific refereeing using <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike Outliner</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>I have long been an enthusiast for <fr:link href="http://outliners.com/default.html" type="external">outliners</fr:link>, a genre of computer software that deserves more than almost any other to be called an <html:em>“elegant weapon for a more civilized age”</html:em>. Recently I have been enjoying experimenting with <fr:link href="/jessegrosjean/" title="Jesse Grosjean" uri="https://www.jonmsterling.com/jessegrosjean/" display-uri="jessegrosjean" type="local">Jesse Grosjean</fr:link>’s highly <fr:link href="/jms-008B/" title="Rich text editing in Bike" uri="https://www.jonmsterling.com/jms-008B/" display-uri="jms-008B" type="local">innovative</fr:link> outliner for macOS called <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>, which builds on a lot of his previous (highly impressive) work in the area with a level of fit and finish that is rare even in the world of macOS software. <html:strong><fr:link href="https://www.hogbaysoftware.com/bike/" type="external">Bike costs $29.99</fr:link> and is well-worth it; watch the <fr:link href="https://www.hogbaysoftware.com/bike/" type="external">introductory video</fr:link> or try the demo to see for yourself.</html:strong></html:p><html:p>The purpose of outliners is to provide room to actively think; <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Grothendieck</fr:link> is said to have been unable to think at all without a pen in his hand, and I think of outliners as one way to elevate the tactile aspect of active thinking using the unique capabilities of software. Tools for thinking must combat stress and mental weight, and the most immediate way that outliners achieve this is through the ability to <html:em>focus</html:em> on a subtree — narrowing into a portion of the hierarchy and treating it as if it were the entire document, putting its context aside. This feature, which some of my readers may recognize from Emacs <html:code>org-mode</html:code>, is well-represented in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> — without, of course, suffering the noticeable quirks that come from the Emacs environment, nor the <fr:link href="https://www.forester-notes.org/tfmt-000B/" title="Absolute vs. relative hierarchy in document markup languages" uri="https://www.forester-notes.org/tfmt-000B/" display-uri="https://www.forester-notes.org/tfmt-000B/" type="local">ill-advised <html:em>absolute/top-down</html:em> model of hierarchy</fr:link> sadly adopted by <html:code>org-mode</html:code>.</html:p><html:p>As a scientist in academia, one of the most frequent things I am doing when I am not writing my own papers or working with students is <html:strong>refereeing other scientists’ papers</html:strong>. For those who are unfamiliar, this means carefully studying a paper and then producing a detailed and well-structured report that includes a summary of the paper, my personal assessment of its scientific validity and value, and a long list of corrections, questions, comments, and suggestions. Referee reports of this kind are then used by journal editors and conference program committees to decide which papers deserve to be published.</html:p><html:p><html:mark>In this post, I will give an overview of my refereeing workflow with <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link></html:mark> and how I overcame the challenges transferring finished referee reports from <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> into the text-based formats used by conference refereeing platforms like <fr:link href="https://hotcrp.com/" type="external">HotCRP</fr:link> and <fr:link href="https://hotcrp.com/" type="external">EasyChair</fr:link> using a combination of XSLT 2.0 and <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link>. This tutorial applies to <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> 1.14; I hope the format will not change too much, but I cannot make promises about what I do not control.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-0089/</fr:uri><fr:display-uri>jms-0089</fr:display-uri><fr:route>/jms-0089/</fr:route><fr:title text="Refereeing in an outliner">Refereeing in an outliner</fr:title></fr:frontmatter><fr:mainmatter><html:p>Most scientific conferences solicit and organize reviews for papers using a web platform such as <fr:link href="https://hotcrp.com/" type="external">HotCRP</fr:link> and <fr:link href="https://hotcrp.com/" type="external">EasyChair</fr:link>; although these are not the same, the idea is similar. Once you have been assigned to referee a paper, you will receive a web form with several sections and large text areas in which to put the components of your review; not all conferences ask for the same components, but usually one is expected to include the following in addition to your (numerical) assessment of the paper’s merit and your expertise:</html:p><html:ol><html:li>A summmary of the paper</html:li>
  <html:li>Your assessment of the paper</html:li>
  <html:li>Detailed comments for the authors</html:li>
  <html:li>Questions to be addressed by author response</html:li>
  <html:li>Comments for the PC (program committee) and other reviewers</html:li></html:ol><html:p>Usually you will be asked to enter your comments under each section in a plain text format like Markdown. <html:strong>The first thing a new referee learns is not to type answers directly into the web interface</html:strong>, because this is an extremely reliable way to lose hours of your time when a browser or server glitch deletes all your work. Most of us instead write out our answers in a separate text editor, and paste them into the web interface when we are satisfied with them. In the past, I have done this with text files on my computer, but <html:mark>today I want to discuss how to draft referee reports as outlines in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link></html:mark>; then I will show you how to convert them to the correct plain text format that can be pasted into your conference’s preferred web-based refereeing platform.</html:p><html:p>To start off, have a look at the <fr:link href="/jms-0086/" title="A Bike outline for conference refereeing" uri="https://www.jonmsterling.com/jms-0086/" display-uri="jms-0086" type="local">figure</fr:link> below, which shows my refereeing template outline in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-0086/</fr:uri><fr:display-uri>jms-0086</fr:display-uri><fr:route>/jms-0086/</fr:route><fr:title text="A Bike outline for conference refereeing">A <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline for conference refereeing</fr:title><fr:taxon>Figure</fr:taxon><fr:meta name="external">https://git.sr.ht/~jonsterling/bike-convertors/tree/main/item/example.bike</fr:meta></fr:frontmatter><fr:mainmatter><html:figure><html:img src="/bafkrmigmquqcipfrbxjs6e66eywjrnkbo7mntai2iyhjbu67a3qo5i6fsy.png" />
  <html:figcaption>This <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline contains the skeleton of a referee report for a major computer science conference. <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>’s <html:em>row types</html:em> are used extensively: for example, sections are formatted as <html:em>heading</html:em>s, and prompts are formatted as <html:em>note</html:em>s</html:figcaption></html:figure></fr:mainmatter></fr:tree><html:p>As you can see, there is a healthy combination of hierarchy and formatting in a <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008B/</fr:uri><fr:display-uri>jms-008B</fr:display-uri><fr:route>/jms-008B/</fr:route><fr:title text="Rich text editing in Bike">Rich text editing in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link></fr:title></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> is a rich text editor, but one that (much like <fr:link href="/van-der-hoeven-2020/" title="The jolly writer: your guide to GNU TeXmacs" uri="https://www.jonmsterling.com/van-der-hoeven-2020/" display-uri="van-der-hoeven-2020" type="local">GNU TeXmacs</fr:link>) avoids the classic pitfalls of nearly all rich text editors, such as the ubiquitous and dreaded <html:em>“Is the space italic?!”</html:em> user-experience failure; I will not outline <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> <fr:link href="https://www.hogbaysoftware.com/posts/bike-rich-text/" type="external">innovative approach to rich text editing</fr:link> here, but I suggest you check it out for yourself.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008A/</fr:uri><fr:display-uri>jms-008A</fr:display-uri><fr:route>/jms-008A/</fr:route><fr:title text="Row types in Bike">Row types in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link></fr:title></fr:frontmatter><fr:mainmatter><html:p>One of the most useful features of <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>’s approach to formatting is the concept of a <html:strong>row type</html:strong>, which is a semantic property of a row that has consequences for its visual presentation. <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> currently supports the following row types:</html:p><html:ul><html:li><html:strong>Plain rows</html:strong></html:li>
  <html:li><html:strong>Heading rows</html:strong>, formatted in boldface</html:li>
  <html:li><html:strong>Note rows</html:strong>, formatted in gray italics</html:li>
  <html:li><html:strong>Quote rows</html:strong>, formatted with a vertical bar to their left</html:li>
  <html:li><html:strong>Ordered rows</html:strong>, formatted with an (automatically chosen) numeral to their left</html:li>
  <html:li><html:strong>Unordered rows</html:strong>, formatted with a bullet to their left</html:li>
  <html:li><html:strong>Task rows</html:strong>, formatted with a checkbox to their left</html:li></html:ul></fr:mainmatter></fr:tree><html:p>My <fr:link href="/jms-0086/" title="A Bike outline for conference refereeing" uri="https://www.jonmsterling.com/jms-0086/" display-uri="jms-0086" type="local">refereeing template</fr:link> uses several of these <fr:link href="/jms-008A/" title="Row types in Bike" uri="https://www.jonmsterling.com/jms-008A/" display-uri="jms-008A" type="local">row types</fr:link> (headings, notes, tasks) as well as some of the <fr:link href="/jms-008B/" title="Rich text editing in Bike" uri="https://www.jonmsterling.com/jms-008B/" display-uri="jms-008B" type="local">rich text formatting</fr:link> (highlighting). When I fill out the refereeing outline, I will use other <fr:link href="/jms-008A/" title="Row types in Bike" uri="https://www.jonmsterling.com/jms-008A/" display-uri="jms-008A" type="local">row types</fr:link> as well — including quotes, ordered, and unordered rows. I will create a subheading under <html:em>Detailed comments for the author</html:em> to contain my questions and comments, which I enter in as ordered rows; then I make a separate subheading at the same level for <html:em>Typographical errors</html:em>, which I populate with unordered rows. Unordered rows are best for typos, because they are always accompanied already by line numbers. If I need to quote an extended portion of the paper, I will use a <html:em>quote row</html:em>.</html:p><html:p>When working on the report outline, I will constantly be <html:em>focusing</html:em> on individual sections to avoid not only distractions but also the intense mental weight of unfinished sections. Focusing means that the entire outline is narrowed to a subtree that can be edited away from its context; this is achieved in <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> by pressing the gray south-easterly arrows to the right of each heading, as seen in <fr:link href="/jms-0086/" title="A Bike outline for conference refereeing" uri="https://www.jonmsterling.com/jms-0086/" display-uri="jms-0086" type="local">the figure</fr:link>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008C/</fr:uri><fr:display-uri>jms-008C</fr:display-uri><fr:route>/jms-008C/</fr:route><fr:title text="From an outline to a plain text referee report">From an outline to a plain text referee report</fr:title></fr:frontmatter><fr:mainmatter><html:p>Although we have seen how pleasant it is to use an outliner like <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> to draft a referee report, but we obviously cannot submit a <html:code>.bike</html:code> file to a conference reviewing website or a journal editor. Most conference reviewing systems accept plain text or Markdown responses, and so our goal will be to convert a <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline into reasonably formatted Markdown.</html:p><html:p>It happens that <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>’s underlying format is HTML, so one idea would be to use <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link> to process this HTML into Markdown. This would work, except that <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>’s model is sufficiently structured that it must make deeply idiosyncratic use of HTML tags, as can be seen from the <fr:link href="/jms-008G/" title="The source code to a typical Bike outline" uri="https://www.jonmsterling.com/jms-008G/" display-uri="jms-008G" type="local">listing</fr:link> below.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008G/</fr:uri><fr:display-uri>jms-008G</fr:display-uri><fr:route>/jms-008G/</fr:route><fr:title text="The source code to a typical Bike outline">The source code to a typical <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline</fr:title><fr:taxon>Listing</fr:taxon></fr:frontmatter><fr:mainmatter><html:pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8"/>
  </head>
  <body>
    <ul id="2sbcmmms">
      <li id="3C" data-type="heading">
        <p>Tasks</p>
        <ul>
          <li id="cs" data-type="task">
            <p>read through paper on iPad and highlight</p>
          </li>
        </ul>
      </li>
      <li id="XZ" data-type="heading">
        <p>Syntax and semantics of foo bar baz</p>
        <ul>
          <li id="Kp">
            <p><mark>Overall merit:</mark><span> </span></p>
          </li>
          <li id="d9">
            <p><mark>Reviewer Expertise:</mark></p>
          </li>
          <li id="uM" data-type="heading">
            <p>Summary of the paper</p>
            <ul>
              <li id="oB" data-type="note">
                <p>Please give a brief summary of the paper</p>
              </li>
              <li id="TWZ">
                <p>This paper describes the syntax and semantics of foo, bar, and baz.</p>
              </li>
            </ul>
          </li>
          <li id="V8" data-type="heading">
            <p>Assessment of the paper</p>
            <ul>
              <li id="vD" data-type="note">
                <p>Please give a balanced assessment of the paper's strengths and weaknesses and a clear justification for your review score.</p>
              </li>
            </ul>
          </li>
          <li id="zo" data-type="heading">
            <p>Detailed comments for authors</p>
            <ul>
              <li id="o0" data-type="note">
                <p>Please give here any additional detailed comments or questions that you would like the authors to address in revising the paper.</p>
              </li>
              <li id="bgy" data-type="heading">
                <p>Minor comments</p>
                <ul>
                  <li id="tMq" data-type="unordered">
                    <p>line 23: "teh" =&gt; "the"</p>
                  </li>
                  <li id="EmX" data-type="unordered">
                    <p>line 99: "fou" =&gt; "foo"</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li id="aN" data-type="heading">
            <p>Questions to be addressed by author response</p>
            <ul>
              <li id="7s" data-type="note">
                <p>Please list here any specific questions you would like the authors to address in their author response. Since authors have limited time in which to prepare their response, please only ask questions here that are likely to affect your accept/reject decision.</p>
              </li>
            </ul>
          </li>
          <li id="4S" data-type="heading">
            <p>Comments for PC and other reviewers</p>
            <ul>
              <li id="bN" data-type="note">
                <p>Please list here any additional comments you have which you want the PC and other reviewers to see, but not the authors.</p>
              </li>
              <li id="i2b">
                <p>In case any one is wondering, I am an expert in foo, but not in bar nor baz.</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </body>
</html>]]></html:pre></fr:mainmatter></fr:tree><html:p>The Markdown that would result from postprocessing a <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline directly with <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link> would be deeply unsuitable for submission. We will, however, use a version of this idea: first we will preprocess the <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> format into more conventional (unstructured) HTML using XSLT 2.0, and then we will use <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link> to convert this into Markdown.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008E/</fr:uri><fr:display-uri>jms-008E</fr:display-uri><fr:route>/jms-008E/</fr:route><fr:title text="System requirements to convert Bike outlines to Markdown">System requirements to convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outlines to Markdown</fr:title></fr:frontmatter><fr:mainmatter><html:p>XSLT 2.0 is unfortunately only implemented by proprietary tools like <fr:link href="https://saxonica.com/welcome/welcome.xml" type="external">Saxon</fr:link>, developed by Saxonica. Nonetheless, it is possible to freely install Saxon on macOS using Homebrew:</html:p><html:pre>brew install saxon</html:pre><html:p>You must also install <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link>, which is also conveniently available as a binary on Homebrew:</html:p><html:pre>brew install pandoc</html:pre></fr:mainmatter></fr:tree><html:p>With the <fr:link href="/jms-008E/" title="System requirements to convert Bike outlines to Markdown" uri="https://www.jonmsterling.com/jms-008E/" display-uri="jms-008E" type="local">system requirements</fr:link> out of the way, we can proceed to prepare an XSLT stylesheet that will convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>’s idiosyncratic use of HTML tags to more conventional HTML that can be processed into Markdown by <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link>. The stylesheet <html:code>bike-to-html.xsl</html:code> is described and explained in the <fr:link href="/jms-0087/" title="An XSLT 2.0 transformer to convert Bike outlines to HTML" uri="https://www.jonmsterling.com/jms-0087/" display-uri="jms-0087" type="local">listing</fr:link> below.</html:p>
  
  <fr:tree show-metadata="true"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-0087/</fr:uri><fr:display-uri>jms-0087</fr:display-uri><fr:route>/jms-0087/</fr:route><fr:title text="An XSLT 2.0 transformer to convert Bike outlines to HTML">An XSLT 2.0 transformer to convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outlines to HTML</fr:title><fr:taxon>Listing</fr:taxon><fr:meta name="external">https://git.sr.ht/~jonsterling/bike-convertors/tree/main/item/bike-to-html.xsl</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We can write convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outlines to reasonable HTML using an XSLT 2.0 stylesheet, <html:code>bike-to-html.xsl</html:code> detailed below.</html:p><html:pre><![CDATA[<?xml version="1.0"?>

<xsl:stylesheet version="2.0"
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:html="http://www.w3.org/1999/xhtml"
  exclude-result-prefixes="xhtml">

  <xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes" />
  <xsl:strip-space elements="*" />]]></html:pre><html:p>We will allow several tags to be copied verbatim into the output, as <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> uses these in the same way that idiomatic HTML does.</html:p><html:pre><![CDATA[  <xsl:template match="html:html | html:body | html:code | html:strong | html:em | html:mark">
    <xsl:copy>
      <xsl:apply-templates select="node()|@*" />
    </xsl:copy>
  </xsl:template>]]></html:pre><html:p><fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> leaves behind a lot of empty <html:code>span</html:code> elements; we drop these.</html:p><html:pre><![CDATA[  <xsl:template match="html:span">
    <xsl:apply-templates />
  </xsl:template>]]></html:pre><html:p><fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> uses <html:code>ul</html:code> for all lists; the list type is determined not at this level, but rather by each individual item’s <html:code>@data-type</html:code> attribute. To get this data into the HTML list model, we must group items that have the same <html:code>@data-type</html:code> and wrap them in an appropriate list-forming element.</html:p><html:p>To do this, we use XSLT 2.0’s <html:code>xsl:for-each-group</html:code> instruction to group adjacent <html:code>li</html:code> elements by their <html:code>@data-type</html:code> attribute.  (It is extremely difficult and error-prone to write equivalent code in the more widely available XSLT 1.0.) We must convert <html:code>@data-type</html:code> to a string: otherwise, the transformer will crash when it encounters an item without a <html:code>@data-type</html:code> attribute.</html:p><html:pre><![CDATA[  <xsl:template match="html:ul">
    <xsl:for-each-group select="html:li" group-adjacent="string(@data-type)">
      <xsl:choose>
        <xsl:when test="@data-type='ordered' or @data-type='task'">
          <ol>
            <xsl:apply-templates select="current-group()" />
          </ol>
        </xsl:when>
        <xsl:when test="@data-type='unordered'">
          <ul>
            <xsl:apply-templates select="current-group()" />
          </ul>
        </xsl:when>
        <xsl:otherwise>
          <xsl:apply-templates select="current-group()" />
        </xsl:otherwise>
      </xsl:choose>
    </xsl:for-each-group>
  </xsl:template>]]></html:pre><html:p>Next, we match each individual <html:code>li</html:code> element; the content of a list item is stored in a <html:code>p</html:code> element directly under <html:code>li</html:code>, so we let the transformer fall thorugh the parent and then format the content underneath according to the <html:code>@data-type</html:code> of the item.</html:p><html:pre><![CDATA[  <xsl:template match="html:li">
    <xsl:apply-templates />
  </xsl:template>

  <xsl:template
    match="html:li[@data-type='ordered' or @data-type='unordered' or @data-type='task']/html:p">
    <li>
      <xsl:apply-templates />
    </li>
  </xsl:template>]]></html:pre><html:p><fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> has correctly adopted the optimal <fr:link href="https://www.forester-notes.org/tfmt-000D/" title="Implicit vs. explicit hierarchy in document markup languages" uri="https://www.forester-notes.org/tfmt-000D/" display-uri="https://www.forester-notes.org/tfmt-000D/" type="local">explicit</fr:link> and <fr:link href="https://www.forester-notes.org/tfmt-000B/" title="Absolute vs. relative hierarchy in document markup languages" uri="https://www.forester-notes.org/tfmt-000B/" display-uri="https://www.forester-notes.org/tfmt-000B/" type="local">relative</fr:link> model of hierarchy, in contrast to HTML; this means that the depth of a heading is not reflected in the element that introduces it, but is instead inferred from its actual position in the outline hierarchy. To convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outlines to idiomatic HTML, we must flatten the hierarchy and introduce explicit heading levels; luckily, this is easy to accomplish in XSLT by counting the ancestors of <html:code>heading</html:code> type.</html:p><html:pre><![CDATA[  <xsl:template match="html:li[@data-type='heading']/html:p">
    <xsl:element
      name="h{count(ancestor::html:li[@data-type='heading'])}">
      <xsl:apply-templates />
    </xsl:element>
  </xsl:template>]]></html:pre><html:p>The remainder of the row types are not difficult to render; you may prefer alternative formatting depending on your goals.</html:p><html:pre><![CDATA[  <xsl:template match="html:li[@data-type='quote']/html:p">
    <blockquote>
      <xsl:apply-templates />
    </blockquote>
  </xsl:template>

  <xsl:template match="html:li[@data-type='note']/html:p">
    <p>
      <em>
        <xsl:apply-templates />
      </em>
    </p>
  </xsl:template>

  <xsl:template match="html:li[not(@data-type)]/html:p">
    <p>
      <xsl:apply-templates />
    </p>
  </xsl:template>
</xsl:stylesheet>]]></html:pre></fr:mainmatter></fr:tree>
<html:p>Next, we can use Saxon to convert a <fr:link href="/jms-0087/" title="An XSLT 2.0 transformer to convert Bike outlines to HTML" uri="https://www.jonmsterling.com/jms-0087/" display-uri="jms-0087" type="local">Bike</fr:link> outline to idiomatic HTML using the <fr:link href="/jms-0087/" title="An XSLT 2.0 transformer to convert Bike outlines to HTML" uri="https://www.jonmsterling.com/jms-0087/" display-uri="jms-0087" type="local">stylesheet above</fr:link>.</html:p><html:pre>cat review.bike | saxon -xsl:bike-to-html.xsl - &gt; review.html</html:pre><html:p>Go ahead and open the resulting HTML file in a text editor and a browser to see the results.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008F/</fr:uri><fr:display-uri>jms-008F</fr:display-uri><fr:route>/jms-008F/</fr:route><fr:title text="A Bike outline transformed to idiomatic HTML">A <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> <fr:link href="/jms-008G/" title="The source code to a typical Bike outline" uri="https://www.jonmsterling.com/jms-008G/" display-uri="jms-008G" type="local">outline</fr:link> transformed to idiomatic HTML</fr:title><fr:taxon>Listing</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The following is the result of transforming an <fr:link href="/jms-008G/" title="The source code to a typical Bike outline" uri="https://www.jonmsterling.com/jms-008G/" display-uri="jms-008G" type="local">example <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outline</fr:link> to idiomatic HTML using an <fr:link href="/jms-0087/" title="An XSLT 2.0 transformer to convert Bike outlines to HTML" uri="https://www.jonmsterling.com/jms-0087/" display-uri="jms-0087" type="local">XSLT stylesheet</fr:link>.</html:p><html:pre><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
   <body>
      <h1>Tasks</h1>
      <ol>
         <li>read through paper on iPad and highlight</li>
      </ol>
      <h1>Syntax and semantics of foo bar baz</h1>
      <p>
         <mark>Overall merit:</mark>
      </p>
      <p>
         <mark>Reviewer Expertise:</mark>
      </p>
      <h2>Summary of the paper</h2>
      <p>
         <em>Please give a brief summary of the paper</em>
      </p>
      <p>This paper describes the syntax and semantics of foo, bar, and baz.</p>
      <h2>Assessment of the paper</h2>
      <p>
         <em>Please give a balanced assessment of the paper's strengths and weaknesses and a clear justification for your review score.</em>
      </p>
      <h2>Detailed comments for authors</h2>
      <p>
         <em>Please give here any additional detailed comments or questions that you would like the authors to address in revising the paper.</em>
      </p>
      <h3>Minor comments</h3>
      <ul>
         <li>line 23: "teh" =&gt; "the"</li>
         <li>line 99: "fou" =&gt; "foo"</li>
      </ul>
      <h2>Questions to be addressed by author response</h2>
      <p>
         <em>Please list here any specific questions you would like the authors to address in their author response. Since authors have limited time in which to prepare their response, please only ask questions here that are likely to affect your accept/reject decision.</em>
      </p>
      <h2>Comments for PC and other reviewers</h2>
      <p>
         <em>Please list here any additional comments you have which you want the PC and other reviewers to see, but not the authors.</em>
      </p>
      <p>In case any one is wondering, I am an expert in foo, but not in bar nor baz.</p>
   </body>
</html>]]></html:pre></fr:mainmatter></fr:tree><html:p>Next, we will process this HTML file using <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link>; unfortunately, <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link> leaves behind a lot of garbage character escapes that are <html:em>not</html:em> suitable for submission anywhere, so we must filter those out using <html:code>sed</html:code>.</html:p><html:pre><![CDATA[cat review.html | pandoc -f html -t markdown-raw_html-native_divs-native_spans-fenced_divs-bracketed_spans-smart | sed 's/\\//g']]></html:pre><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008H/</fr:uri><fr:display-uri>jms-008H</fr:display-uri><fr:route>/jms-008H/</fr:route><fr:title text="A Bike outline transformed to Markdown">A <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> <fr:link href="/jms-008G/" title="The source code to a typical Bike outline" uri="https://www.jonmsterling.com/jms-008G/" display-uri="jms-008G" type="local">outline</fr:link> transformed to Markdown</fr:title><fr:taxon>Listing</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The following is the result of converting the <fr:link href="/jms-008F/" title="A Bike outline transformed to idiomatic HTML" uri="https://www.jonmsterling.com/jms-008F/" display-uri="jms-008F" type="local">idiomatic HTML representation</fr:link> of a <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> <fr:link href="/jms-008G/" title="The source code to a typical Bike outline" uri="https://www.jonmsterling.com/jms-008G/" display-uri="jms-008G" type="local">outline</fr:link> to Markdown using <fr:link href="/jms-008D/" title="Pandoc: a universal document convertor" uri="https://www.jonmsterling.com/jms-008D/" display-uri="jms-008D" type="local">Pandoc</fr:link>, with some light postprocessing by <html:code>sed</html:code>.</html:p><html:pre><![CDATA[# Tasks

1.  read through paper on iPad and highlight

# Syntax and semantics of foo bar baz

Overall merit:

Reviewer Expertise:

## Summary of the paper

*Please give a brief summary of the paper*

This paper describes the syntax and semantics of foo, bar, and baz.

## Assessment of the paper

*Please give a balanced assessment of the paper's strengths and
weaknesses and a clear justification for your review score.*

## Detailed comments for authors

*Please give here any additional detailed comments or questions that you
would like the authors to address in revising the paper.*

### Minor comments

-   line 23: "teh" => "the"
-   line 99: "fou" => "foo"

## Questions to be addressed by author response

*Please list here any specific questions you would like the authors to
address in their author response. Since authors have limited time in
which to prepare their response, please only ask questions here that are
likely to affect your accept/reject decision.*

## Comments for PC and other reviewers

*Please list here any additional comments you have which you want the PC
and other reviewers to see, but not the authors.*

In case any one is wondering, I am an expert in foo, but not in bar nor
baz.]]></html:pre></fr:mainmatter></fr:tree><html:p>We can compose all these tasks into a one-liner as follows:</html:p><html:pre><![CDATA[cat review.bike | saxon -xsl:bike-to-html.xsl - | pandoc -f html -t markdown-raw_html-native_divs-native_spans-fenced_divs-bracketed_spans-smart | sed 's/\\//g']]></html:pre></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-008I/</fr:uri><fr:display-uri>jms-008I</fr:display-uri><fr:route>/jms-008I/</fr:route><fr:title text="A convenient Bike-to-Markdown script">A convenient <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link>-to-Markdown script</fr:title><fr:meta name="external">https://git.sr.ht/~jonsterling/bike-convertors</fr:meta></fr:frontmatter><fr:mainmatter><html:p>I have gathered the scripts to convert <fr:link href="/jms-0085/" title="Bike Outliner: Structured focused writing" uri="https://www.jonmsterling.com/jms-0085/" display-uri="jms-0085" type="local">Bike</fr:link> outlines into Markdown via idiomatic HTML in a <fr:link href="https://git.sr.ht/~jonsterling/bike-convertors" type="external">Git repository</fr:link> where they can be easily downloaded. If you have any improvements to these scripts, please <fr:link href="https://git-send-email.io/" type="external">submit them as a patch</fr:link> to my <fr:link href="https://lists.sr.ht/~jonsterling/public-inbox" type="external">public inbox</fr:link>! I am also interested in whether it is possible to write the <fr:link href="/jms-0087/" title="An XSLT 2.0 transformer to convert Bike outlines to HTML" uri="https://www.jonmsterling.com/jms-0087/" display-uri="jms-0087" type="local">XSLT 2.0 stylesheet</fr:link> as equivalent XSLT 1.0, to avoid <fr:link href="/jms-008E/" title="System requirements to convert Bike outlines to Markdown" uri="https://www.jonmsterling.com/jms-008E/" display-uri="jms-008E" type="local">requiring</fr:link> the proprietary <fr:link href="https://saxonica.com/welcome/welcome.xml" type="external">Saxon</fr:link> tool. Feel free also to send comments on this post to my public inbox, or discuss with me on <fr:link href="https://mathstodon.xyz/@jonmsterling" type="external">Mastodon</fr:link>.</html:p></fr:mainmatter></fr:tree>
  
  <html:hr />

  
  
    
    <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:uri>https://www.jonmsterling.com/jms-0088/</fr:uri><fr:display-uri>jms-0088</fr:display-uri><fr:route>/jms-0088/</fr:route><fr:title text="Crowdfunding and sponsorship">Crowdfunding and sponsorship</fr:title><fr:taxon>☕</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Apart from my day-job at the <fr:link href="/ucam/" title="University of Cambridge" uri="https://www.jonmsterling.com/ucam/" display-uri="ucam" type="local">University of Cambridge</fr:link>, I am independently researching <fr:link href="https://www.forester-notes.org/tfmt-0001/" title="Designing tools for scientific thought" uri="https://www.forester-notes.org/tfmt-0001/" display-uri="https://www.forester-notes.org/tfmt-0001/" type="local">tools for scientific thought</fr:link> and developing software like <fr:link href="https://www.forester-notes.org/index/" title="Forester" uri="https://www.forester-notes.org/index/" display-uri="https://www.forester-notes.org/index/" type="local">Forester</fr:link> that you can use to unlock your brain. <html:mark>If you have benefited from this work or the writings on my <fr:link href="/jms-007W/" title="Jon Sterling › Blog" uri="https://www.jonmsterling.com/jms-007W/" display-uri="jms-007W" type="local">blog</fr:link>, please considering supporting me with a <fr:link href="https://ko-fi.com/jonmsterling" type="external">sponsorship on Ko-fi</fr:link>.</html:mark></html:p></fr:mainmatter></fr:tree>
  

</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>5</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/chapman-grothendieck-2022/</fr:uri>
            <fr:display-uri>chapman-grothendieck-2022</fr:display-uri>
            <fr:route>/chapman-grothendieck-2022/</fr:route>
            <fr:title text="Grothendieck Conference">Grothendieck Conference</fr:title>
            <fr:taxon>Conference</fr:taxon>
            <fr:meta name="external">https://www.chapman.edu/scst/conferences-and-events/grothendieck-conference.aspx</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Chapman University hosted a conference honoring and exploring the contributions of <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link> to the field of Mathematics. This conference was sponsored by Chapman University and the University of Paris. We were honored to have our eminent guests here to speak to us on the revolutionary nature of <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Grothendieck</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/frct-003O/</fr:uri>
            <fr:display-uri>frct-003O</fr:display-uri>
            <fr:route>/frct-003O/</fr:route>
            <fr:title text="Internal categories">Internal categories</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We have already seen in our discussion of  <fr:link href="/frct-000G/" title="Warmup: locally small family fibrations" uri="https://www.jonmsterling.com/frct-000G/" display-uri="frct-000G" type="local">locally small</fr:link> and <fr:link href="/frct-000L/" title="Globally small categories" uri="https://www.jonmsterling.com/frct-000L/" display-uri="frct-000L" type="local">globally small</fr:link> categories that smallness in the fibered sense appropriately generalizes the ordinary notion of smallness for categories over <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>. Another perspective on smallness is given by the <html:em>internal language</html:em>, in which a category is viewed as an algebra for the “theory of categories” computed in another category with enough structure. The notion of internal categories is credited (independently) to <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link> and Charles Ehresmann.</html:p>
            <html:p>The notion of a (meta-)category is an essentially algebraic theory. As such it is possible to compute <html:em>models</html:em> of this theory in any category that has finite limits.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-001A/</fr:uri>
                <fr:display-uri>frct-001A</fr:display-uri>
                <fr:route>/frct-001A/</fr:route>
                <fr:title text="Internal category">Internal category</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[E]]></fr:tex> be a category with finite limits; then an <html:em>internal category</html:em>
in <fr:tex display="inline"><![CDATA[E]]></fr:tex> is defined by the following data:</html:p>
                <html:ol><html:li>an object of objects <fr:tex display="inline"><![CDATA[C_{0}\in  E]]></fr:tex>,</html:li>
<html:li>an object of morphisms <fr:tex display="inline"><![CDATA[C_{1}\in  E]]></fr:tex>,</html:li>
<html:li>source and target morphisms <fr:tex display="inline"><![CDATA[s,t:C_{1}\to  C_{0}]]></fr:tex>,</html:li>
<html:li>a generic identity morphism <fr:tex display="inline"><![CDATA[C_{0}\to  C_{1}]]></fr:tex>,</html:li>
<html:li>a generic composition morphism <fr:tex display="inline"><![CDATA[C_{1}\times _{C_{0}}C_{1}\to  C_{1}]]></fr:tex>,</html:li>
<html:li>satisfying a number of laws corresponding to those of a category.</html:li></html:ol>
                <html:p>For the details of these laws, we refer to any standard source.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:contributor>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:contributor>
                </fr:authors>
                <fr:uri>https://www.jonmsterling.com/frct-000V/</fr:uri>
                <fr:display-uri>frct-000V</fr:display-uri>
                <fr:route>/frct-000V/</fr:route>
                <fr:title text="The externalization of an internal category">The externalization of an internal category</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001R/</fr:uri>
                    <fr:display-uri>frct-001R</fr:display-uri>
                    <fr:route>/frct-001R/</fr:route>
                    <fr:title text="Externalization">Externalization</fr:title>
                    <fr:taxon>Construction</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[C]]></fr:tex> be an internal category in <fr:tex display="inline"><![CDATA[E]]></fr:tex>. We may define a fibered category <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [C\right  ]\mathclose {}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[E]]></fr:tex> called the <html:em>externalization</html:em> of <fr:tex display="inline"><![CDATA[C]]></fr:tex>.</html:p>
                    <html:ol><html:li>Given <fr:tex display="inline"><![CDATA[x\in  E]]></fr:tex>, an object of <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [C\right  ]\mathclose {}}_{x}]]></fr:tex> is defined to be a morphism <fr:tex display="inline"><![CDATA[x\to  C_{0}]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex>.</html:li>

  <html:li><html:p>Given <fr:tex display="inline"><![CDATA[x,y\in  E]]></fr:tex> and <fr:tex display="inline"><![CDATA[f:x\to  y]]></fr:tex> and <fr:tex display="inline"><![CDATA[u \in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[v\in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{y}]]></fr:tex>, a morphism <fr:tex display="inline"><![CDATA[u\xrightarrow [f]{} v]]></fr:tex> is defined to be a morphism <fr:tex display="inline"><![CDATA[h : x\to  C_{1}]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex> such that the following diagram commutes:</html:p>

    
 
  
  <html:figure><fr:resource hash="1e37082a2d8adf73fbe8bc458424a0a5"><fr:resource-content><html:img src="/1e37082a2d8adf73fbe8bc458424a0a5.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (x) {$x$};
        \node  (y) [below = of x] {$y$};
        \node  (C/1) [right = of x] {$C_{1}$};
        \node  (C/0) [below = of C/1] {$C_{0}$};
        \node  (C/0') [above = of C/1] {$C_{0}$};
        \draw [->] (x) to node [upright desc] {$h$} (C/1);
        \draw [->] (C/1) to node [right] {$t$} (C/0);
        \draw [->] (C/1) to node [right] {$s$} (C/0');
        \draw [->] (y) to node [below] {$v$} (C/0);
        \draw [->] (x) to node [left] {$f$} (y);
        \draw [->] (x) to node [sloped,above] {$u$} (C/0');
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-000W/</fr:uri>
                    <fr:display-uri>frct-000W</fr:display-uri>
                    <fr:route>/frct-000W/</fr:route>
                    <fr:title text="Cartesian lifts in the externalization">Cartesian lifts in the externalization</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> is a cartesian fibration.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Given an object <fr:tex display="inline"><![CDATA[v\in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{y}]]></fr:tex> and a morphism <fr:tex display="inline"><![CDATA[f:x\to  y]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex>, we may define a cartesian lift <fr:tex display="inline"><![CDATA[f^{*}v\xrightarrow [f]{} v]]></fr:tex> by setting <fr:tex display="inline"><![CDATA[f^{*}v = v\circ  f : x \to  C_{0}]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-000X/</fr:uri>
                    <fr:display-uri>frct-000X</fr:display-uri>
                    <fr:route>/frct-000X/</fr:route>
                    <fr:title text="Globally small externalization">Globally small externalization</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> is globally small</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We may choose a <fr:link href="/frct-000K/" title="Generic objects" uri="https://www.jonmsterling.com/frct-000K/" display-uri="frct-000K" type="local">generic object</fr:link> for <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [C\right  ]\mathclose {}}]]></fr:tex>, namely the identity element <fr:tex display="inline"><![CDATA[(C_{0},1_{C_{0}})\in  \widetilde {{\mathopen {}\left  [C\right  ]\mathclose {}}}]]></fr:tex>. Given any object <fr:tex display="inline"><![CDATA[(x,u)\in  \widetilde {{\mathopen {}\left  [C\right  ]\mathclose {}}}]]></fr:tex> the cartesian map <fr:tex display="inline"><![CDATA[(x,u)\to  (C_{0},1_{C_{0}})]]></fr:tex> is given as follows:</html:p>

  
 
  
  <html:figure><fr:resource hash="4762475f1b1bff8893dbac58f2d4b60b"><fr:resource-content><html:img src="/4762475f1b1bff8893dbac58f2d4b60b.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \node  (x) {$x$};
      \node  (y) [below = of x] {$C_{0}$};
      \node  (C/1) [right = of x] {$C_{1}$};
      \node  (C/0) [below = of C/1] {$C_{0}$};
      \node  (C/0') [above = of C/1] {$C_{0}$};
      \draw [->] (x) to node [upright desc] {$\mathsf {idn}_{u}$} (C/1);
      \draw [->] (C/1) to node [right] {$t$} (C/0);
      \draw [->] (C/1) to node [right] {$s$} (C/0');
      \draw [->] (y) to node [below] {$1_{C_{0}}$} (C/0);
      \draw [->] (x) to node [left] {$u$} (y);
      \draw [->] (x) to node [sloped,above] {$u$} (C/0');
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>
 

</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:uri>https://www.jonmsterling.com/frct-000Y/</fr:uri>
                    <fr:display-uri>frct-000Y</fr:display-uri>
                    <fr:route>/frct-000Y/</fr:route>
                    <fr:title text="Locally small externalization">Locally small externalization</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> is locally small.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:p>Fix <fr:tex display="inline"><![CDATA[x\in  E]]></fr:tex> and <fr:tex display="inline"><![CDATA[u,v\in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{x}]]></fr:tex>, we must exhibit a terminal object to the (total) category <fr:tex display="inline"><![CDATA[\widetilde {\mathbf {H}_{{\mathopen {}\left  [C\right  ]\mathclose {}}_{x}}(u,v)}]]></fr:tex> of <fr:link href="/frct-000I/" title="The definition of local smallness" uri="https://www.jonmsterling.com/frct-000I/" display-uri="frct-000I" type="local">“hom candidates”</fr:link>. First we define <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [u,v\right  ]\mathclose {}}]]></fr:tex> to be the following pullback in <fr:tex display="inline"><![CDATA[E]]></fr:tex>:</html:p>


 
  
  <html:figure><fr:resource hash="0782a129619fdeb5bad29ee69ccaaf94"><fr:resource-content><html:img src="/0782a129619fdeb5bad29ee69ccaaf94.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    nw/style = pullback,
    ne = C_{1},
    se = C_{0}\times  C_{0},
    east = {(s,t)},
    south = {(u,v)},
    sw = x,
    nw = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
    west = p,
    north = q,
    west/style = {->,exists},
    north/style = {->,exists},
  }
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>We define <fr:tex display="inline"><![CDATA[\overline {p}:{\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}{u}\xrightarrow [p]{} u\in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{{\mathopen {}\left  [u,v\right  ]\mathclose {}}}]]></fr:tex> to be
the cartesian lift of <fr:tex display="inline"><![CDATA[u\in  {\mathopen {}\left  [C\right  ]\mathclose {}}_{x}]]></fr:tex> along <fr:tex display="inline"><![CDATA[p:{\mathopen {}\left  [u,v\right  ]\mathclose {}}\to  x]]></fr:tex>:</html:p>


 
  
  <html:figure><fr:resource hash="3b2996e19115dff5cd110f6fb334dc02"><fr:resource-content><html:img src="/3b2996e19115dff5cd110f6fb334dc02.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    height = 1.5cm,
    nw/style = pullback,
    west/style = lies over,
    east/style = lies over,
    north/style = {->,exists},
    ne = u,
    nw = {\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u,
    sw = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
    se = x,
    south = p,
    north = \overline {p},
  }
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>We need to define a displayed evaluation map
<fr:tex display="inline"><![CDATA[\epsilon  : {\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u\xrightarrow [p]{} v]]></fr:tex>; unraveling the definition of a displayed
morphism in the externalization of <fr:tex display="inline"><![CDATA[C]]></fr:tex>, we choose the following diagram:</html:p>


 
  
  <html:figure><fr:resource hash="cbec150a738cc44fff728e111549fb7f"><fr:resource-content><html:img src="/cbec150a738cc44fff728e111549fb7f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare {
      ne = C_{1},
      se = C_{0},
      east = t,
      nw = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
      sw = x,
      west = p,
      south = v,
      north = q,
      north/style = {magenta,->},
      north/node/style = upright desc,
    }
    \node  (nne) [above = of ne] {$C_{0}$};
    \node  (nnw) [above = of nw] {$x$};
    \draw [->] (ne) to node [right] {$s$} (nne);
    \draw [->] (nw) to node [left] {$p$} (nnw);
    \draw [->] (nnw) to node [above] {$u$} (nne);
    \draw [->] (nw) to node [desc] {${\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}{u}$} (nne);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>Putting all this together, we assert that the terminal object of
<fr:tex display="inline"><![CDATA[\widetilde {\mathbf {H}_{{\mathopen {}\left  [C\right  ]\mathclose {}}_{x}}(u,v)}]]></fr:tex> is the following span in <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [C\right  ]\mathclose {}}]]></fr:tex>:</html:p>


 
  
  <html:figure><fr:resource hash="b4a72578154761402ad06d001d807c1f"><fr:resource-content><html:img src="/b4a72578154761402ad06d001d807c1f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <l/>{
      height = 1.5cm,
      west/style = lies over,
      east/style = lies over,
      north/style = <-,
      south/style = <-,
      ne/style = ne pullback,
      ne = {\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}{u},
      se = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
      sw = x,
      nw = u,
      south = p,
      north = \bar {p},
    }
    \SpliceDiagramSquare <r/>{
      height = 1.5cm,
      west/style = lies over,
      east/style = lies over,
      glue = west,
      glue target = l/,
      ne = v,
      se = x,
      north = \epsilon ,
      south = p,
    }
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>Fixing another such candidate hom span <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{u \leftarrow  \bar {h}\rightarrow  v\right \}\mathclose {}}\in \widetilde {\mathbf {H}_{{\mathopen {}\left  [C\right  ]\mathclose {}}_{x}}(u,v)}]]></fr:tex>, we <fr:link href="/frct-000I/" title="The definition of local smallness" uri="https://www.jonmsterling.com/frct-000I/" display-uri="frct-000I" type="local">must exhibit</fr:link> a unique cartesian morphism <fr:tex display="inline"><![CDATA[\bar \alpha  : \bar {h}\to  {\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}{u}]]></fr:tex> making the following diagram commute:</html:p>


 
  
  <html:figure><fr:resource hash="a0593f282d12f527669aa660e54ecfb6"><fr:resource-content><html:img src="/a0593f282d12f527669aa660e54ecfb6.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (u) {$u$};
    \node  (h) [above right = 1.5cm of u,xshift=.5cm] {$\bar {h}$};
    \node  (hom) [below right = 1.5cm of u,xshift=.5cm] {${\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}{u}$};
    \node  (v) [below right = 1.5cm of h,xshift=.5cm] {$v$};
    \draw [->] (hom) to node [sloped,below] {$\bar {p}$} (u);
    \draw [->] (h) to node [sloped,above] {$\bar {p}_{h}$} (u);
    \draw [->] (hom) to node [sloped,below] {$\epsilon $} (v);
    \draw [->] (h) to node [sloped,above] {$\epsilon _{h}$} (v);
    \draw [->] (h) to node [upright desc] {$\bar \alpha $} (hom);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>First we note that the evaluation map <fr:tex display="inline"><![CDATA[\epsilon _{h} : \bar {h}\to  v]]></fr:tex> amounts
to an internal morphism <fr:tex display="inline"><![CDATA[h\to  C_{1}]]></fr:tex> satisfying the appropriate
compatibility conditions. Therefore we may define the base <fr:tex display="inline"><![CDATA[\alpha :h\to  {\mathopen {}\left  [u,v\right  ]\mathclose {}}]]></fr:tex> of
the universal map using the universal property of the pullback that defines <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [u,v\right  ]\mathclose {}}]]></fr:tex>:</html:p>


 
  
  <html:figure><fr:resource hash="dd50c215e2ef5908a6e365e1027d7b70"><fr:resource-content><html:img src="/dd50c215e2ef5908a6e365e1027d7b70.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare {
      nw/style = pullback,
      ne = C_{1},
      se = C_{0}\times  C_{0},
      east = {(s,t)},
      south = {(u,v)},
      sw = x,
      nw = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
      west = p,
      north = q,
      north/node/style = upright desc,
      west/node/style = upright desc,
    }
    \node  (h) [above left = of nw] {$h$};
    \draw [->,bend right=30] (h) to node [left] {$p_h$} (sw);
    \draw [->,bend left=30] (h) to node [sloped,above] {$\epsilon _h$} (ne);
    \draw [->,exists] (h) to node [desc] {$\alpha $} (nw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>The morphism <fr:tex display="inline"><![CDATA[\alpha :h\to  {\mathopen {}\left  [u,v\right  ]\mathclose {}}]]></fr:tex> defined above is the <html:em>unique</html:em> map in <fr:tex display="inline"><![CDATA[E]]></fr:tex>
satisfying the conditions required of the base for <fr:tex display="inline"><![CDATA[\bar \alpha ]]></fr:tex>; therefore, it
suffices to show that there exists a cartesian morphism
<fr:tex display="inline"><![CDATA[\bar \alpha :\bar {h}\xrightarrow [\alpha ]{}{\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u]]></fr:tex> since it will be unique if it
exists. We define <fr:tex display="inline"><![CDATA[\bar \alpha ]]></fr:tex> using the universal property of the cartesian lift:</html:p>


 
  
  <html:figure><fr:resource hash="548b857e21f669a1215268ca4a9b7673"><fr:resource-content><html:img src="/548b857e21f669a1215268ca4a9b7673.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <l/>{
      ne/style = pullback,
      nw/style = dotted pullback,
      west/style = lies over,
      east/style = lies over,
      height = 1.5cm,
      se = {\mathopen {}\left  [u,v\right  ]\mathclose {}},
      ne = {\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u,
      sw = h,
      nw = \bar {h},
      south = \alpha ,
      north = \bar \alpha ,
      north/style = {->,exists},
      north/node/style = upright desc,
      south/node/style = upright desc,
    }
    \SpliceDiagramSquare <r/>{
      glue = west,
      glue target = l/,
      east/style = lies over,
      height = 1.5cm,
      ne = u,
      se = x,
      south = p,
      north = \bar {p},
      north/node/style = upright desc,
      south/node/style = upright desc,
    }
    \draw [->,bend left=30] (l/nw) to node [above] {$\bar {p}_{h}$} (r/ne);
    \draw [->,bend right=30] (l/sw) to node [below] {$p_{h}$} (r/se);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 


<html:p>That <fr:tex display="inline"><![CDATA[\bar {\alpha }:\bar {h}\xrightarrow [\alpha ]{}{\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u]]></fr:tex> is cartesian follows from <fr:link href="/frct-0014/" title="The generalized pullback lemma" uri="https://www.jonmsterling.com/frct-0014/" display-uri="frct-0014" type="local">the generalized pullback lemma for cartesian morphisms</fr:link>: it suffices
to observe that both <fr:tex display="inline"><![CDATA[\bar {p}_{h}:\bar {h}\to  u]]></fr:tex> and its second factor
<fr:tex display="inline"><![CDATA[\bar {p}:{\mathopen {}\left  [u,v\right  ]\mathclose {}}^{*}u\to  u]]></fr:tex> are cartesian.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-0011/</fr:uri>
                <fr:display-uri>frct-0011</fr:display-uri>
                <fr:route>/frct-0011/</fr:route>
                <fr:title text="The full internal subcategory associated to a displayed object">The full internal subcategory associated to a displayed object</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The <fr:link href="/frct-0010/" title="The full subfibration associated to a displayed object" uri="https://www.jonmsterling.com/frct-0010/" display-uri="frct-0010" type="local">full subfibration</fr:link> associated to a displayed object <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex> of a <fr:link href="/frct-001B/" title="Locally small fibration" uri="https://www.jonmsterling.com/frct-001B/" display-uri="frct-001B" type="local">locally small</fr:link> cartesian fibration <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> can be seen to be equivalent to the externalization of an internal category <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-003Q/</fr:uri>
                    <fr:display-uri>frct-003Q</fr:display-uri>
                    <fr:route>/frct-003Q/</fr:route>
                    <fr:title text="The internal category associated to a displayed object">The internal category associated to a displayed object</fr:title>
                    <fr:taxon>Construction</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex> be a displayed object in a <fr:link href="/frct-001B/" title="Locally small fibration" uri="https://www.jonmsterling.com/frct-001B/" display-uri="frct-001B" type="local">locally small</fr:link> fibration <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex>. We will define the <fr:link href="/frct-001A/" title="Internal category" uri="https://www.jonmsterling.com/frct-001A/" display-uri="frct-001A" type="local">internal category</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[B]]></fr:tex> associated to <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex>. In particular, we let the object of objects <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}_{0}]]></fr:tex> be <fr:tex display="inline"><![CDATA[u]]></fr:tex> itself; defining the object of arrows <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}_{1}]]></fr:tex> is more complex, making critical use of the local smallness of <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:p><html:p>We will think of the fiber category <fr:tex display="inline"><![CDATA[E_{u\times  u}]]></fr:tex> as the category of objects indexed in the <html:em>boundary</html:em> (source and target) of a morphism. Restricting <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex> along the source and target projections, we obtain the displayed objects of “points of the source” and “points of the target” respectively:</html:p>
 
  
  <html:figure><fr:resource hash="24c85c92203941398db367b63411ec63"><fr:resource-content><html:img src="/24c85c92203941398db367b63411ec63.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    height = 1.5cm,
    nw/style = pullback,
    west/style = lies over,
    east/style = lies over,
    nw = \bar {\partial }_{1},
    sw = u\times  u,
    se = u,
    ne = \bar {u},
    south = \pi _{1},
    north = \bar {\pi }_{1},
  }
  \qquad 
  \DiagramSquare {
    height = 1.5cm,
    nw/style = pullback,
    west/style = lies over,
    east/style = lies over,
    nw = \bar {\partial }_{2},
    sw = u\times  u,
    se = u,
    ne = \bar {u},
    south = \pi _{2},
    north = \bar {\pi }_{2}
  }
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Because <fr:tex display="inline"><![CDATA[E]]></fr:tex> is <fr:link href="/frct-001B/" title="Locally small fibration" uri="https://www.jonmsterling.com/frct-001B/" display-uri="frct-001B" type="local">locally small</fr:link>, there is an object <fr:tex display="inline"><![CDATA[\mathbf {hom}_{E_{u\times  u}}{\mathopen {}\left (\bar \partial _{1},\bar \partial _{2}\right )\mathclose {}}\in  {B}_{/u\times  u}]]></fr:tex> that behaves as the “generic hom set”. We define <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}_{1}\in  B]]></fr:tex> and its source and target projections to be this very object.</html:p></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001S/</fr:uri>
                    <fr:display-uri>frct-001S</fr:display-uri>
                    <fr:route>/frct-001S/</fr:route>
                    <fr:title text="Characterization of the externalization">Characterization of the externalization</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}]]></fr:tex> of the internal category <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}]]></fr:tex> <fr:link href="/frct-003Q/" title="The internal category associated to a displayed object" uri="https://www.jonmsterling.com/frct-003Q/" display-uri="frct-003Q" type="local">associated to</fr:link> a displayed object <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex> in a <fr:link href="/frct-001B/" title="Locally small fibration" uri="https://www.jonmsterling.com/frct-001B/" display-uri="frct-001B" type="local">locally small</fr:link> fibered category <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> is equivalent to the <fr:link href="/frct-0010/" title="The full subfibration associated to a displayed object" uri="https://www.jonmsterling.com/frct-0010/" display-uri="frct-0010" type="local">full internal subfibration</fr:link> <fr:tex display="inline"><![CDATA[\mathbf {Full}{\mathopen {}\left (\bar {u}\right )\mathclose {}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We will define a fibred equivalence <fr:tex display="inline"><![CDATA[F : {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}\to  \mathbf {Full}{\mathopen {}\left (\bar {u}\right )\mathclose {}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:p>

  <html:ol><html:li>Fix <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex> and <fr:tex display="inline"><![CDATA[\chi _{x} \in  {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{x}]]></fr:tex>, i.e. <fr:tex display="inline"><![CDATA[\chi _{x} : x\to  u]]></fr:tex>; we define <fr:tex display="inline"><![CDATA[F{\mathopen {}\left (\chi _{x}\right )\mathclose {}}]]></fr:tex> to be an arbitrary cartesian map <fr:tex display="inline"><![CDATA[\phi _{x} : \bar {x}\xrightarrow [\chi _{x}]{} \bar {u}]]></fr:tex>. (Here we have used the <fr:link href="/frct-000R/" title="Foundational assumptions" uri="https://www.jonmsterling.com/frct-000R/" display-uri="frct-000R" type="local">axiom of choice for collections</fr:link>.)</html:li>

    <html:li><html:p>Fix <fr:tex display="inline"><![CDATA[f : x\to  y\in  B]]></fr:tex> and <fr:tex display="inline"><![CDATA[\chi _{x} :x\to  u]]></fr:tex> and <fr:tex display="inline"><![CDATA[\chi _{y}:y\to  u]]></fr:tex> and a diagram representing a displayed morphism <fr:tex display="inline"><![CDATA[h]]></fr:tex> from <fr:tex display="inline"><![CDATA[\chi _{x}]]></fr:tex> to <fr:tex display="inline"><![CDATA[\chi _{y}]]></fr:tex> over <fr:tex display="inline"><![CDATA[f]]></fr:tex> as below:</html:p>

      
 
  
  <html:figure><fr:resource hash="c6184c09aa495eddce3dbb68932c8f54"><fr:resource-content><html:img src="/c6184c09aa495eddce3dbb68932c8f54.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \begin {tikzpicture}[diagram]
          \node  (x) {$x$};
          \node  (y) [below = of x] {$y$};
          \node  (C/1) [right = of x] {${\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1}$};
          \node  (C/0) [below = of C/1] {$u$};
          \node  (C/0') [above = of C/1] {$u$};
          \draw [->,magenta] (x) to node [upright desc] {$h$} (C/1);
          \draw [->] (C/1) to node [right] {$t$} (C/0);
          \draw [->] (C/1) to node [right] {$s$} (C/0');
          \draw [->] (y) to node [below] {$\chi _{y}$} (C/0);
          \draw [->] (x) to node [left] {$f$} (y);
          \draw [->] (x) to node [sloped,above] {$\chi _{x}$} (C/0');
        \end {tikzpicture}
      ]]></fr:resource-source></fr:resource></html:figure>
 


      <html:p>We must define <fr:tex display="inline"><![CDATA[F{\mathopen {}\left (h\right )\mathclose {}}:\bar {x}\xrightarrow [f]{} \bar {y}]]></fr:tex>, fixing arbitrary
      cartesian maps <fr:tex display="inline"><![CDATA[\bar \chi _{x}:\bar {x}\xrightarrow [\chi _{x}]{}\bar {u}]]></fr:tex> and
      <fr:tex display="inline"><![CDATA[\bar \chi _{y}:\bar {y}\xrightarrow [\chi _{y}]{}\bar {u}]]></fr:tex>. First we lift <fr:tex display="inline"><![CDATA[h:x\to  {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1}]]></fr:tex>
      into <fr:tex display="inline"><![CDATA[E]]></fr:tex> using the universal property of the cartesian lift:</html:p>

      
 
  
  <html:figure><fr:resource hash="f98b962f29d54d4842ee47405af87a6b"><fr:resource-content><html:img src="/f98b962f29d54d4842ee47405af87a6b.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \begin {tikzpicture}[diagram]
          \SpliceDiagramSquare <0/>{
            height = 1.5cm,
            west/style = lies over,
            east/style = lies over,
            width = 2.5cm,
            north/node/style = upright desc,
            ne/style = pullback,
            north/style = {->,exists},
            nw = \bar {x},
            sw = x,
            se = {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1},
            ne = {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1}^{*}\bar \partial _{1},
            south = h,
            north = \bar {h},
          }
          \SpliceDiagramSquare <1/>{
            glue = west,
            glue target = 0/,
            height = 1.5cm,
            width = 2.5cm,
            north/node/style = upright desc,
            south/node/style = upright desc,
            east/style = lies over,
            ne/style = pullback,
            ne = \bar \partial _{1},
            se = u\times  u,
            south = p,
            north = \bar {p},
          }
          \SpliceDiagramSquare <2/>{
            glue = west,
            glue target = 1/,
            height = 1.5cm,
            width = 2.5cm,
            north/node/style = upright desc,
            south/node/style = upright desc,
            east/style = lies over,
            ne = \bar {u},
            se = u,
            south = \pi _{1},
            north = \bar \pi _{1},
          }
          \draw [->,bend left=30] (0/nw) to node [above] {$\bar \chi _{x}$} (2/ne);
          \draw [->,bend right=30] (0/se) to node [below] {$s$} (2/se);
        \end {tikzpicture}
      ]]></fr:resource-source></fr:resource></html:figure>
 


      <html:p>By composition with the “evaluation map” for our hom object, we have a map <fr:tex display="inline"><![CDATA[\bar {x}\xrightarrow [f;\chi _{y}]{}\bar {u}]]></fr:tex>:</html:p>

      
 
  
  <html:figure><fr:resource hash="9271e363f2a7d16737c7082afb750d36"><fr:resource-content><html:img src="/9271e363f2a7d16737c7082afb750d36.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \begin {tikzpicture}[diagram]
          \SpliceDiagramSquare <0/>{
            height = 1.5cm,
            west/style = lies over,
            east/style = lies over,
            south/node/style = upright desc,
            width = 2.5cm,
            nw = \bar {x},
            sw = x,
            se = {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1},
            ne = {\mathopen {}\left  [{\mathopen {}\left \langle \bar {u}\right \rangle \mathclose {}}\right  ]\mathclose {}}_{1}^{*}\bar \partial _{1},
            south = h,
            north = \bar {h},
          }
          \SpliceDiagramSquare <1/>{
            glue = west,
            glue target = 0/,
            height = 1.5cm,
            width = 2.5cm,
            south/node/style = upright desc,
            east/style = lies over,
            ne/style = pullback,
            ne = \bar \partial _{2},
            se = u\times  u,
            south = p,
            north = \bar {\epsilon },
          }
          \SpliceDiagramSquare <2/>{
            glue = west,
            glue target = 1/,
            height = 1.5cm,
            width = 2.5cm,
            south/node/style = upright desc,
            east/style = lies over,
            ne = \bar {u},
            se = u,
            south = \pi _{2},
            north = \bar \pi _{2},
          }
          \draw [->,bend right=30] (0/se) to node [upright desc] {$t$} (2/se);
          \node  (y) [between = 0/sw and 2/se, yshift=-2cm] {$y$};
          \draw [bend right=30,->] (0/sw) to node [sloped,below] {$f$} (y);
          \draw [bend right=30,->] (y) to node [sloped,below] {$\chi _{y}$} (2/se);
        \end {tikzpicture}
      ]]></fr:resource-source></fr:resource></html:figure>
 


      <html:p>Next we define <fr:tex display="inline"><![CDATA[F{\mathopen {}\left (h\right )\mathclose {}}:\bar {x}\xrightarrow [f]{}\bar {y}]]></fr:tex> using the universal property of (another) cartesian lift:</html:p>

      
 
  
  <html:figure><fr:resource hash="f92fdcc217fedc2d8540940b1a61204f"><fr:resource-content><html:img src="/f92fdcc217fedc2d8540940b1a61204f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
        \begin {tikzpicture}[diagram]
          \SpliceDiagramSquare <l/>{
            height = 1.5cm,
            east/style = lies over,
            west/style = lies over,
            ne/style = pullback,
            north/style = {->,exists},
            north/node/style = upright desc,
            ne = \bar {y},
            nw = \bar {x},
            se = y,
            sw = x,
            south = f,
            north = F{\mathopen {}\left (h\right )\mathclose {}},
            width = 2.5cm,
          }
          \SpliceDiagramSquare <r/>{
            glue = west,
            glue target = l/,
            height = 1.5cm,
            east/style = lies over,
            north/node/style = upright desc,
            ne = \bar {u},
            se = u,
            south = \chi _{y},
            north = \bar \chi _{y},
          }
          \draw [->,bend left=30] (l/nw) to node [above] {$\bar {h};\bar {\epsilon };\bar \pi _{2}$} (r/ne);
        \end {tikzpicture}
      ]]></fr:resource-source></fr:resource></html:figure></html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-000Z/</fr:uri>
                <fr:display-uri>frct-000Z</fr:display-uri>
                <fr:route>/frct-000Z/</fr:route>
                <fr:title text="The internalization of a small fibration">The internalization of a small fibration</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[E]]></fr:tex> be a <fr:link href="/frct-001Q/" title="Small fibration" uri="https://www.jonmsterling.com/frct-001Q/" display-uri="frct-001Q" type="local">small fibration</fr:link> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> a category with finite limits, i.e. a cartesian fibration that is both <fr:link href="/frct-001B/" title="Locally small fibration" uri="https://www.jonmsterling.com/frct-001B/" display-uri="frct-001B" type="local">locally small</fr:link> and <fr:link href="/frct-000P/" title="Globally small fibration" uri="https://www.jonmsterling.com/frct-000P/" display-uri="frct-000P" type="local">globally small</fr:link>. We will show that <fr:tex display="inline"><![CDATA[E]]></fr:tex> is equivalent to the <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [C\right  ]\mathclose {}}]]></fr:tex> of an <fr:link href="/frct-001A/" title="Internal category" uri="https://www.jonmsterling.com/frct-001A/" display-uri="frct-001A" type="local">internal category</fr:link> <fr:tex display="inline"><![CDATA[C]]></fr:tex> in <fr:tex display="inline"><![CDATA[B]]></fr:tex>, namely the <fr:link href="/frct-003Q/" title="The internal category associated to a displayed object" uri="https://www.jonmsterling.com/frct-003Q/" display-uri="frct-003Q" type="local">full internal subcategory</fr:link> associated to the <fr:link href="/frct-001E/" title="Generic object" uri="https://www.jonmsterling.com/frct-001E/" display-uri="frct-001E" type="local">generic object</fr:link> <fr:tex display="inline"><![CDATA[\bar {u}\in  E]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>By the <fr:link href="/frct-001S/" title="Characterization of the externalization" uri="https://www.jonmsterling.com/frct-001S/" display-uri="frct-001S" type="local">characterization of the externalization</fr:link> we know that the <fr:link href="/frct-001R/" title="Externalization" uri="https://www.jonmsterling.com/frct-001R/" display-uri="frct-001R" type="local">externalization</fr:link> of <fr:tex display="inline"><![CDATA[C]]></fr:tex> so-defined is equivalent to the full subfibration <fr:tex display="inline"><![CDATA[\mathbf {Full}{\mathopen {}\left (\bar {u}\right )\mathclose {}}]]></fr:tex> of <fr:tex display="inline"><![CDATA[E]]></fr:tex> spanned by objects that are “classified” by <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex>. Because <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex> is generic, we know that <html:em>every</html:em> object of <fr:tex display="inline"><![CDATA[E]]></fr:tex> is classified by <fr:tex display="inline"><![CDATA[\bar {u}]]></fr:tex>, so we are done.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1984</fr:year>
              <fr:month>2</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/grothendieck-1984-stacks/</fr:uri>
            <fr:display-uri>grothendieck-1984-stacks</fr:display-uri>
            <fr:route>/grothendieck-1984-stacks/</fr:route>
            <fr:title text="À la poursuite des Champs">À la poursuite des Champs</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2111.01000</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link>
              </fr:author>
              <fr:author>Jean-Louis Verdier</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1972</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sga-4/</fr:uri>
            <fr:display-uri>sga-4</fr:display-uri>
            <fr:route>/sga-4/</fr:route>
            <fr:title text="Théorie des topos et cohomologie étale des schémas (SGA 4)">Théorie des topos et cohomologie étale des schémas (SGA 4)</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/BFb0081551</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1957</fr:year>
              <fr:month>3</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/grothendieck-1957-tohoku/</fr:uri>
            <fr:display-uri>grothendieck-1957-tohoku</fr:display-uri>
            <fr:route>/grothendieck-1957-tohoku/</fr:route>
            <fr:title text="Sur quelques points d’algèbre homologique, I.">Sur quelques points d’algèbre homologique, I.</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.2748/tmj/1178244839</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alexandergrothendieck/" title="Alexander Grothendieck" uri="https://www.jonmsterling.com/alexandergrothendieck/" display-uri="alexandergrothendieck" type="local">Alexander Grothendieck</fr:link>
              </fr:author>
              <fr:author>Michele Raynaud</fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/sga-1/</fr:uri>
            <fr:display-uri>sga-1</fr:display-uri>
            <fr:route>/sga-1/</fr:route>
            <fr:title text="Revêtements étales et groupe fondamental (SGA 1)">Revêtements étales et groupe fondamental (SGA 1)</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/ARXIV.MATH/0206203</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Le texte présente les fondements d’une théorie du groupe fondamental en Géométrie Algébrique, dans le point de vue “kroneckerien” permettant de traiter sur le même pied le cas d’une variété algébrique au sens habituel, et celui d’un anneau des entiers d’un corps de nombres, par exemple.</html:p>
            <html:p>The text presents the foundations of a theory of the fundamental group in Algebraic Geometry from the Kronecker point of view, allowing one to treat on an equal footing the case of an algebraic variety in the usual sense, and that of the ring of integers in a number field, for instance.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>
