<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>1</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
    <fr:display-uri>jms-0013</fr:display-uri>
    <fr:route>/jms-0013/</fr:route>
    <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
    <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
    <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
    <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/thorstenaltenkirch/" title="Thorsten Altenkirch" uri="https://www.jonmsterling.com/thorstenaltenkirch/" display-uri="thorstenaltenkirch" type="local">Thorsten Altenkirch</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/peterdybjer/" title="Peter Dybjer" uri="https://www.jonmsterling.com/peterdybjer/" display-uri="peterdybjer" type="local">Peter Dybjer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/martinhofmann/" title="Martin Hofmann" uri="https://www.jonmsterling.com/martinhofmann/" display-uri="martinhofmann" type="local">Martin Hofmann</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/philipscott/" title="Philip Scott" uri="https://www.jonmsterling.com/philipscott/" display-uri="philipscott" type="local">Philip Scott</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2001</fr:year>
              <fr:month>6</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/</fr:uri>
            <fr:display-uri>altenkirch-dybjer-hofmann-scott-2001</fr:display-uri>
            <fr:route>/altenkirch-dybjer-hofmann-scott-2001/</fr:route>
            <fr:title text="Normalization by evaluation for typed lambda calculus with coproducts">Normalization by evaluation for typed lambda calculus with coproducts</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1109/LICS.2001.932506</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Solves the decision problem for the simply typed lambda calculus with a strong binary sum, or, equivalently, the word problem for free Cartesian closed categories with binary co-products. Our method is based on the semantic technique known as “normalization by evaluation”, and involves inverting the interpretation of the syntax in a suitable sheaf model and, from this, extracting an appropriate unique normal form. There is no rewriting theory involved and the proof is completely constructive, allowing program extraction from the proof.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/alexsimpson/" title="Alex Simpson" uri="https://www.jonmsterling.com/alexsimpson/" display-uri="alexsimpson" type="local">Alex Simpson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1999</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-simpson-1999/</fr:uri>
            <fr:display-uri>fiore-simpson-1999</fr:display-uri>
            <fr:route>/fiore-simpson-1999/</fr:route>
            <fr:title text="Lambda definability with sums via Grothendieck logical relations">Lambda definability with sums via Grothendieck logical relations</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/3-540-48959-2_12</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We introduce a notion of <html:em>Grothendieck logical relation</html:em> and use it to characterise the definability of morphisms in stable bicartesian closed categories by terms of the simply-typed lambda calculus with finite products and finite sums. Our techniques are based on concepts from topos theory, however our exposition is elementary.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/martinhofmann/" title="Martin Hofmann" uri="https://www.jonmsterling.com/martinhofmann/" display-uri="martinhofmann" type="local">Martin Hofmann</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1999</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/hofmann-1999/</fr:uri>
            <fr:display-uri>hofmann-1999</fr:display-uri>
            <fr:route>/hofmann-1999/</fr:route>
            <fr:title text="Semantical analysis of higher-order abstract syntax">Semantical analysis of higher-order abstract syntax</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1109/LICS.1999.782616</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A functor category semantics for higher-order abstract syntax is proposed with the following aims: relating higher-order and first order syntax, justifying induction principles, suggesting new logical principles to reason about higher-order syntax</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/achimjung/" title="Achim Jung" uri="https://www.jonmsterling.com/achimjung/" display-uri="achimjung" type="local">Achim Jung</fr:link>
              </fr:author>
              <fr:author>Jerzy Tiuryn</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1993</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jung-tiuryn-1993/</fr:uri>
            <fr:display-uri>jung-tiuryn-1993</fr:display-uri>
            <fr:route>/jung-tiuryn-1993/</fr:route>
            <fr:title text="A new characterization of lambda definability">A new characterization of lambda definability</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/BFb0037110</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We give a new characterization of lambda definability in Henkin models using logical relations defined over ordered sets with varying arity. The advantage of this over earlier approaches by Plotkin and Statman is its simplicity and universality. Yet, decidability of lambda definability for hereditarily finite Henkin models remains an open problem. But if the variable set allowed in terms is also restricted to be finite then our techniques lead to a decision procedure.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/peterfreyd/" title="Peter Freyd" uri="https://www.jonmsterling.com/peterfreyd/" display-uri="peterfreyd" type="local">Peter Freyd</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1978</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/freyd-1978/</fr:uri>
            <fr:display-uri>freyd-1978</fr:display-uri>
            <fr:route>/freyd-1978/</fr:route>
            <fr:title text="On proving that 1 is an indecomposable projective in various free categories">On proving that 1 is an indecomposable projective in various free categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Unpublished manuscript.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0012/</fr:uri>
            <fr:display-uri>jms-0012</fr:display-uri>
            <fr:route>/jms-0012/</fr:route>
            <fr:title text="Part III: synthetic Tait computability">Part III: synthetic Tait computability</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
                <fr:display-uri>jms-0013</fr:display-uri>
                <fr:route>/jms-0013/</fr:route>
                <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
                <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
                <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
                <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0015/</fr:uri>
                <fr:display-uri>jms-0015</fr:display-uri>
                <fr:route>/jms-0015/</fr:route>
                <fr:title text="Chapter 5: synthetic normalization by evaluation">Chapter 5: synthetic normalization by evaluation</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This chapter develops a more sophisticated application of synthetic Tait computability, the proof of normalization and decidability of Martin-Löf’s type theory with a cumulative hierarchy of universes. The synthetic argument contained in this chapter builds on the work of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link> on categorical normalization by gluing for simply typed λ-calculus, and that of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> on a presheaf-theoretic version of normalization by evaluation for dependent types. Analogous to the external argument of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link>, we construe the syntax of normal and neutral forms as the initial algebra for an internal inductive definition in the language of synthetic Tait computability. The influence of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> is visible in the definition of the <html:em>Tait saturation yoga</html:em> for dependent types in the synthetic setting, an important closure condition for logical predicates that comprised one of the main innovations of <fr:link href="/tait-1967/" title="Intensional interpretations of functionals of finite type I" uri="https://www.jonmsterling.com/tait-1967/" display-uri="tait-1967" type="local">Tait</fr:link> in the context of simply typed combinators. Although this chapter is intended only as “dry run” for the main result (to be exposed in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link>), the normalization argument presented here has intrinsic value: it is the simplest and most direct proof of normalization and decidability for Martin-Löf type theory with <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-laws and cumulative universes that has appeared in the literature so far.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0014/</fr:uri>
            <fr:display-uri>jms-0014</fr:display-uri>
            <fr:route>/jms-0014/</fr:route>
            <fr:title text="Chapter 7: normalization for cubical type theory">Chapter 7: normalization for cubical type theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This chapter reports the main result of the dissertation, normalization for cubical type theory and its corollaries: injectivity of type constructors, and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability of equality &amp; typing</fr:link>. These results were first obtained by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link> for the fragment of cubical type theory <html:em>without</html:em> universes; the present chapter extends the results of <html:em>op. cit.</html:em> to support a cumulative hierarchy of universes.</html:p>
            <html:p>The central innovation of this chapter is to generalize the notion of neutral form to accommodate the computational behavior of terms that have free variables of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> discussed in our <fr:link href="/jms-0017/" title="Chapter 6: cartesian cubical type theory" uri="https://www.jonmsterling.com/jms-0017/" display-uri="jms-0017" type="local">synopsis of Chapter 6</fr:link>.  In the conventional account of neutral and normal forms, neutrals <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> are built up inductively from
<fr:tex display="inline"><![CDATA[x]]></fr:tex> for term variables <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>, function applications to normal forms <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{\bullet }}}{{\color {DarkBlue}{m}}}]]></fr:tex>
and projections from neutral pairs <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.1}}]]></fr:tex>, <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.2}}]]></fr:tex>; our account of neutrals is much the same, except that each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> comes equipped with a <html:strong>“frontier
  of instability”</html:strong> <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{{\color {DarkRed}{e}}}]]></fr:tex>, a predicate on its free <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-variables that indicates when it “needs to compute further”. We think of a neutral form for an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube as being <html:em>undefined</html:em> on its frontier of instability; the process of restricting a neutral to its frontier of instability is then referred to as <html:em>destabilization</html:em>.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[x : A]]></fr:tex> is a variable of an ordinary type, the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\mathopen {}\left ({\color {DarkRed}{\mathsf {var}}}\,{x}\right )\mathclose {}}]]></fr:tex> is empty because variables never need to compute further. Where something new happens is the path type: given a neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,{\mathopen {}\left ({u}\mathrel {{\sim }_{A}}{v}\right )\mathclose {}}]]></fr:tex>
of path type, we have for each term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> a neutral form <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r} : \mathsf {ne}\,A]]></fr:tex> whose frontier of instability is defined like so:</html:p>
            <fr:tex display="block"><![CDATA[  \boldsymbol {\partial }\,{\mathopen {}\left ({{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}\right )\mathclose {}}
=
\boldsymbol {\partial }{\color {DarkRed}{e}}
\lor 
{\mathopen {}\left (r=0\right )\mathclose {}}
\lor 
{\mathopen {}\left (r=1\right )\mathclose {}}
]]></fr:tex>
            <html:p>In other words, the path neutral application <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> needs to compute as soon as e needs to compute, and as soon as the interval term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> becomes equal to a constant. Prior to the introduction of the frontier of instability, the neutrals are embedded into the normals at base types unconditionally, i.e. for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,\mathsf {bool}]]></fr:tex>, we have a normal form <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\lfloor }}{e}{\color {DarkBlue}{\rfloor }} : \mathsf {nf}\,\mathsf {bool}]]></fr:tex>.</html:p>
            <html:p>Now that neutrals are equipped with frontiers of instability, a more refined notion of normal form is needed: when <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> is a neutral form, the corresponding normal form should contain (recursively) normal forms for <fr:tex display="inline"><![CDATA[e]]></fr:tex> that are defined under the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\color {DarkRed}{e}}]]></fr:tex>. To be more concrete,
let <fr:tex display="inline"><![CDATA[x : {\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}]]></fr:tex> be a variable of path type and <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> is a term; then <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}:\mathsf {ne}\,{\mathopen {}\left ({\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}\right )\mathclose {}}]]></fr:tex> is a neutral form for the term <fr:tex display="inline"><![CDATA[xr]]></fr:tex> whose frontier of instability is the boundary <fr:tex display="inline"><![CDATA[(r = 0) \lor  (r = 1)]]></fr:tex>; the corresponding normal form must therefore glue onto <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> additional normal forms for <fr:tex display="inline"><![CDATA[x0]]></fr:tex> and
<fr:tex display="inline"><![CDATA[x1]]></fr:tex>. We refer to the process of completing a neutral with additional data defined on its frontier of instability as stabilization; the <html:em>stabilized</html:em> normal form of <fr:tex display="inline"><![CDATA[xr]]></fr:tex> is then written</html:p>
            <fr:tex display="block"><![CDATA[ {\color {DarkBlue}{\lfloor }}{{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r} \mid  r = 0 \hookrightarrow  {\color {DarkBlue}{\mathsf {tt}}}, r = 1 \hookrightarrow {\color {DarkBlue}{\mathsf {tt}}}}{\color {DarkBlue}{\rfloor }} ]]></fr:tex>
            <html:p>where <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\mathsf {tt}}}]]></fr:tex> is the normal form representing the term <fr:tex display="inline"><![CDATA[\mathsf {tt}]]></fr:tex></html:p>
            <html:p>Just as the embedding of neutrals into normals is “stabilized” by a com patible normal form defined on the neutral’s frontier of instability, so too must the Tait saturation yoga be adjusted. Conventionally one requires the computability predicate for a type <fr:tex display="inline"><![CDATA[A]]></fr:tex> to be equipped with a function that takes neutral forms <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> of terms <fr:tex display="inline"><![CDATA[e : A]]></fr:tex> to computability witnesses for the same term. In the <html:strong>stabilized Tait saturation yoga</html:strong>, we strengthen the induction hypothesis to require for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> a function that extends a computability witness defined only on the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{\color {DarkRed}{e}}]]></fr:tex> to a computability witnessed defined everywhere</html:p>
            <html:p>The twin innovations of <html:em>frontiers of instability</html:em> and <html:em>stabilization</html:em> then suffice to adapt the synthetic normalization argument of <fr:link href="/jms-0015/" title="Chapter 5: synthetic normalization by evaluation" uri="https://www.jonmsterling.com/jms-0015/" display-uri="jms-0015" type="local">Chapter 5</fr:link> to a proof of normalization (and thus decidability) for cubical type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
