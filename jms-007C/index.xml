<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>8</fr:month>
      <fr:day>15</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-007C/</fr:uri>
    <fr:display-uri>jms-007C</fr:display-uri>
    <fr:route>/jms-007C/</fr:route>
    <fr:title text="Policy relevant evidence of the project">Policy relevant evidence of the project</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Research in program semantics and verification is essentially of two kinds. On the one hand, there is work that pushes the envelope of what kinds of programs can be verified — demonstrating (at great exertion and expense) the potential to verify the correctness of the extremely complex software that makes our society work, including onboard software used in air planes, industrial production, agricultural production, artificial intelligence, etc.  On the other hand, there is research that aims to rethink from the ground up the mathematical understanding of programming, radically simplifying the foundations on which the program verification tools are built. Both kinds of research are important and rely heavily on each other. Applied program verification is critical because the need to prevent software faults is ever-present, and in order to get any kind of uptake and adoption, we must demonstrate the capability of our tools to handle the very complex problems that are raised by industrial and governmental use of software. Likewise, foundational research is extremely important because when applied program verification hits its conceptual limitations, it can only advance by becoming bigger and more expensive — requiring larger and larger teams and budgets to make smaller and smaller incremental improvements. In just one year, the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has achieved (through careful attention to building bridges between different mathematical disciplines) what many researchers in this area considered impossible or at least significantly farther off in the future; this experience must be replicated with further grants and fellowships to theoretically and foundationally minded researchers who are willing to undertake interdisciplinary work.</html:p>
    <html:p>At the present time, my perception is that applied program verification is significantly more intelligible to funders and agencies because it speaks directly to the fears and concerns that we all have for our society in the age of software domination, artificial intelligence, and quantum computing; this is understandable, but it has regrettably led to the neglect of foundational research at the time when it is most urgent — it is now that we must lay the foundations for the next generation of program verifiers, before rather than after applied work in program verification reaches the hard limitations that more theoretically-oriented researchers have been working to remove. Therefore, I urge the European Commission and relevant policy makers to increase their consideration of foundational research as an investment in the future, alongside their continued funding of the very important applied direction in program semantics and verification.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0075/</fr:uri>
            <fr:display-uri>jms-0075</fr:display-uri>
            <fr:route>/jms-0075/</fr:route>
            <fr:title text="TypeSynth final report"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> final report</fr:title>
            <fr:taxon>Report</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This is the final report for the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> MSCA project.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0076/</fr:uri>
                <fr:display-uri>jms-0076</fr:display-uri>
                <fr:route>/jms-0076/</fr:route>
                <fr:title text="Context and overall objectives">Context and overall objectives</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction. Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. One of the most extreme forms of computational effect is “higher-order mutable state”, which is when programs can read and write data as well as entire subroutines to the computer’s memory during execution.  Programming languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p>
                <html:p>Recently there have been several significant technical advances in mathematical semantics for programming languages that have been ripe for exploitation. For instance, in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral thesis</fr:link> I developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or “STC” that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, STC enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the STC method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages. Another related advance is the use of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">Synthetic Guarded Domain Theory</fr:link> or “SGDT” as a mathematical language in which to describe and reason about the behavior of computer programs, potentially exhibiting complex interactions with their environment and with other programs. A third advance setting the stage for this project is the development of <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Univalent Foundations and Homotopy Type Theory</fr:link>, a new and backwards-compatible foundation of mathematics that places symmetries and reversible transformations of mathematical structures in the forefront.</html:p>
                <html:p>The goal of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been to combine these three ideas to break a long-standing logjam in the mathematical understanding of computer programming: the denotational semantics and equational separation logic of higher-order mutable state.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0077/</fr:uri>
                <fr:display-uri>jms-0077</fr:display-uri>
                <fr:route>/jms-0077/</fr:route>
                <fr:title text="Work performed and main achievements">Work performed and main achievements</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I highlight the three main achievements of the TypeSynth project below:</html:p>
                <html:ol><html:li>a new denotational semantics of higher-order store;</html:li>
  <html:li>an equational higher-order separation logic based on the above denotational semantics;</html:li>
  <html:li>the extension of <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link> to support computational effects including guarded recursion and higher-order store.</html:li></html:ol>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0078/</fr:uri>
                    <fr:display-uri>jms-0078</fr:display-uri>
                    <fr:route>/jms-0078/</fr:route>
                    <fr:title text="Denotational semantics of higher-order store">Denotational semantics of higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> plan to develop denotational semantics of higher-order store had two components: the first was to develop a practical semantic model of polymorphic higher-order store without garbage collection, and the second was to extend this model to support the equational theory of garbage collection. For the former, the results have greatly outstripped expectations: I have succeeded in constructing not only the indended model of store with polymorphism, but in fact a <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">model of full dependent type theory with higher-order store</fr:link> — posing the prospect for being able to write and verify the correctness of programs in the same language. This result is the first of its kind for higher-order store, and is a significant advance. In the final months of the project, we have also gone further beyond this result in a different direction, and constructed a version of the model of higher-order store satisfying a new gamut of compelling representation independence equations which I refer to as the theory of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link>: in short, two programs can be considered equal even if they allocate memory cells of different types, so long as the two types are in bijection and programs' interaction with the memory cell respects this bijection.</html:p>
                    <html:p>I have begun to extend these results to include the equational theory of garbage collection, but as the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been terminated nearly one year early (due to my recent appointment as Associate Professor at University of Cambridge), this further exploitation of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> methodology will continue beyond the conclusion of the project.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0079/</fr:uri>
                    <fr:display-uri>jms-0079</fr:display-uri>
                    <fr:route>/jms-0079/</fr:route>
                    <fr:title text="Equational higher-order separation logic for higher-order store">Equational higher-order separation logic for higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In collaboration with my colleagues <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Ljerbjerg Aagaard</fr:link> and <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>, I have developed a <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">guarded higher-order separation logic called TULIP</fr:link> over the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational model of higher-order store</fr:link>. This logic represents a significant step forward in the march toward simple, abstract, and compositional reasoning about higher-order stateful programs. Prior program logics (such as Iris and the Verified Software Toolchain) interact with computer programs only indirectly, by verifying properties of a specific “transition function” that simulates the steps that a (highly idealized) computer would take when executing a program; this style is called “operational”. Unfortunately, the important structural properties of programs are highly unnatural to express at the level of transition steps, and as such, existing operationally-based program logics impose a great deal of bureaucracy by forcing those verifying programs to manually mediate the mismatch between the viewpoint of the machine (which cannot see program structure), and the viewpoint of the programmer (which is entirely based on program structure). An equational, or "denotationally-based", program logic like <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> instead treats programs directly without needing to pass through an encoding in terms of machine transitions. An immediate benefit of the equational approach is that program equivalences can be glued together directly in any context, a kind of practical compositionality that is unique to equational and denotationally-based program logics. Our development of the <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> logic is a strong first step in this direction.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-007A/</fr:uri>
                    <fr:display-uri>jms-007A</fr:display-uri>
                    <fr:route>/jms-007A/</fr:route>
                    <fr:title text="Effectful synthetic Tait computability">Effectful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link></fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A third achievement of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project was to extend the highly successful “<fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link>” method, developed in my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link>, to the case of realistic programming languages with computational effects. The purpose of this extension was to achieve strong representation independence results, by which we can show the computational indistinguishability of even two programs that allocate memory cells of different types that are linked not by a bijection but by a mere relation, in contrast to univalent reference types. We have gone quite a bit beyond our expectations, as our account of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local"><fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> for higher-order store</fr:link> applies not only to the simple polymorphic store model, but also to the full dependent type theory. This allows many classic results from the literature that previously required very complicated reasoning with the semantic model to be reconstructed in a simpler and more direct fashion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007B/</fr:uri>
                <fr:display-uri>jms-007B</fr:display-uri>
                <fr:route>/jms-007B/</fr:route>
                <fr:title text="Results beyond the state of the art">Results beyond the state of the art</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The results of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project have gone significantly beyond the state of the art in denotational semantics for computational effects: not only is ours the first typed denotational model of higher-order store compatible with parametric polymorphism, but we have shown that the same construction also gives rise to a model of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">full dependent type theory with higher-order store</fr:link> — a long sought-after result whose implications we have not yet fully exploited. Our model of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link> is also a significant break with the state of the art, and points the way to a new and more fruitful interaction between the fields of programming languages on the one hand, and homotopy type theory and algebraic topology on the other hand.</html:p>
                <html:p>The <fr:link href="/jms-0077/" title="Work performed and main achievements" uri="https://www.jonmsterling.com/jms-0077/" display-uri="jms-0077" type="local">technical achievements</fr:link> of <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> point to healthy growth in the long-neglected area of denotational semantics and equational program logics, but there is an urgent need for further research to bring these superior but comparatively less-developed methods to practical parity with the more established operational paradigm, which currently achieves stronger results in program verification — which we believe can be accounted for by the twenty-year headstart enjoyed by teams favoring operational methods during the relative dormancy of semantic and categorical methods in programming languages.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007C/</fr:uri>
                <fr:display-uri>jms-007C</fr:display-uri>
                <fr:route>/jms-007C/</fr:route>
                <fr:title text="Policy relevant evidence of the project">Policy relevant evidence of the project</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Research in program semantics and verification is essentially of two kinds. On the one hand, there is work that pushes the envelope of what kinds of programs can be verified — demonstrating (at great exertion and expense) the potential to verify the correctness of the extremely complex software that makes our society work, including onboard software used in air planes, industrial production, agricultural production, artificial intelligence, etc.  On the other hand, there is research that aims to rethink from the ground up the mathematical understanding of programming, radically simplifying the foundations on which the program verification tools are built. Both kinds of research are important and rely heavily on each other. Applied program verification is critical because the need to prevent software faults is ever-present, and in order to get any kind of uptake and adoption, we must demonstrate the capability of our tools to handle the very complex problems that are raised by industrial and governmental use of software. Likewise, foundational research is extremely important because when applied program verification hits its conceptual limitations, it can only advance by becoming bigger and more expensive — requiring larger and larger teams and budgets to make smaller and smaller incremental improvements. In just one year, the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has achieved (through careful attention to building bridges between different mathematical disciplines) what many researchers in this area considered impossible or at least significantly farther off in the future; this experience must be replicated with further grants and fellowships to theoretically and foundationally minded researchers who are willing to undertake interdisciplinary work.</html:p>
                <html:p>At the present time, my perception is that applied program verification is significantly more intelligible to funders and agencies because it speaks directly to the fears and concerns that we all have for our society in the age of software domination, artificial intelligence, and quantum computing; this is understandable, but it has regrettably led to the neglect of foundational research at the time when it is most urgent — it is now that we must lay the foundations for the next generation of program verifiers, before rather than after applied work in program verification reaches the hard limitations that more theoretically-oriented researchers have been working to remove. Therefore, I urge the European Commission and relevant policy makers to increase their consideration of foundational research as an investment in the future, alongside their continued funding of the very important applied direction in program semantics and verification.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
            <fr:display-uri>jms-0061</fr:display-uri>
            <fr:route>/jms-0061/</fr:route>
            <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
            <fr:taxon>Fellowship</fr:taxon>
            <fr:meta name="doi">10.3030/101065303</fr:meta>
            <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
