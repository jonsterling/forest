<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>1</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-0014/</fr:uri>
    <fr:display-uri>jms-0014</fr:display-uri>
    <fr:route>/jms-0014/</fr:route>
    <fr:title text="Chapter 7: normalization for cubical type theory">Chapter 7: normalization for cubical type theory</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>This chapter reports the main result of the dissertation, normalization for cubical type theory and its corollaries: injectivity of type constructors, and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability of equality &amp; typing</fr:link>. These results were first obtained by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link> for the fragment of cubical type theory <html:em>without</html:em> universes; the present chapter extends the results of <html:em>op. cit.</html:em> to support a cumulative hierarchy of universes.</html:p>
    <html:p>The central innovation of this chapter is to generalize the notion of neutral form to accommodate the computational behavior of terms that have free variables of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> discussed in our <fr:link href="/jms-0017/" title="Chapter 6: cartesian cubical type theory" uri="https://www.jonmsterling.com/jms-0017/" display-uri="jms-0017" type="local">synopsis of Chapter 6</fr:link>.  In the conventional account of neutral and normal forms, neutrals <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> are built up inductively from
<fr:tex display="inline"><![CDATA[x]]></fr:tex> for term variables <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>, function applications to normal forms <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{\bullet }}}{{\color {DarkBlue}{m}}}]]></fr:tex>
and projections from neutral pairs <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.1}}]]></fr:tex>, <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.2}}]]></fr:tex>; our account of neutrals is much the same, except that each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> comes equipped with a <html:strong>“frontier
  of instability”</html:strong> <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{{\color {DarkRed}{e}}}]]></fr:tex>, a predicate on its free <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-variables that indicates when it “needs to compute further”. We think of a neutral form for an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube as being <html:em>undefined</html:em> on its frontier of instability; the process of restricting a neutral to its frontier of instability is then referred to as <html:em>destabilization</html:em>.</html:p>
    <html:p>When <fr:tex display="inline"><![CDATA[x : A]]></fr:tex> is a variable of an ordinary type, the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\mathopen {}\left ({\color {DarkRed}{\mathsf {var}}}\,{x}\right )\mathclose {}}]]></fr:tex> is empty because variables never need to compute further. Where something new happens is the path type: given a neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,{\mathopen {}\left ({u}\mathrel {{\sim }_{A}}{v}\right )\mathclose {}}]]></fr:tex>
of path type, we have for each term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> a neutral form <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r} : \mathsf {ne}\,A]]></fr:tex> whose frontier of instability is defined like so:</html:p>
    <fr:tex display="block"><![CDATA[  \boldsymbol {\partial }\,{\mathopen {}\left ({{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}\right )\mathclose {}}
=
\boldsymbol {\partial }{\color {DarkRed}{e}}
\lor 
{\mathopen {}\left (r=0\right )\mathclose {}}
\lor 
{\mathopen {}\left (r=1\right )\mathclose {}}
]]></fr:tex>
    <html:p>In other words, the path neutral application <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> needs to compute as soon as e needs to compute, and as soon as the interval term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> becomes equal to a constant. Prior to the introduction of the frontier of instability, the neutrals are embedded into the normals at base types unconditionally, i.e. for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,\mathsf {bool}]]></fr:tex>, we have a normal form <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\lfloor }}{e}{\color {DarkBlue}{\rfloor }} : \mathsf {nf}\,\mathsf {bool}]]></fr:tex>.</html:p>
    <html:p>Now that neutrals are equipped with frontiers of instability, a more refined notion of normal form is needed: when <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> is a neutral form, the corresponding normal form should contain (recursively) normal forms for <fr:tex display="inline"><![CDATA[e]]></fr:tex> that are defined under the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\color {DarkRed}{e}}]]></fr:tex>. To be more concrete,
let <fr:tex display="inline"><![CDATA[x : {\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}]]></fr:tex> be a variable of path type and <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> is a term; then <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}:\mathsf {ne}\,{\mathopen {}\left ({\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}\right )\mathclose {}}]]></fr:tex> is a neutral form for the term <fr:tex display="inline"><![CDATA[xr]]></fr:tex> whose frontier of instability is the boundary <fr:tex display="inline"><![CDATA[(r = 0) \lor  (r = 1)]]></fr:tex>; the corresponding normal form must therefore glue onto <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> additional normal forms for <fr:tex display="inline"><![CDATA[x0]]></fr:tex> and
<fr:tex display="inline"><![CDATA[x1]]></fr:tex>. We refer to the process of completing a neutral with additional data defined on its frontier of instability as stabilization; the <html:em>stabilized</html:em> normal form of <fr:tex display="inline"><![CDATA[xr]]></fr:tex> is then written</html:p>
    <fr:tex display="block"><![CDATA[ {\color {DarkBlue}{\lfloor }}{{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r} \mid  r = 0 \hookrightarrow  {\color {DarkBlue}{\mathsf {tt}}}, r = 1 \hookrightarrow {\color {DarkBlue}{\mathsf {tt}}}}{\color {DarkBlue}{\rfloor }} ]]></fr:tex>
    <html:p>where <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\mathsf {tt}}}]]></fr:tex> is the normal form representing the term <fr:tex display="inline"><![CDATA[\mathsf {tt}]]></fr:tex></html:p>
    <html:p>Just as the embedding of neutrals into normals is “stabilized” by a com patible normal form defined on the neutral’s frontier of instability, so too must the Tait saturation yoga be adjusted. Conventionally one requires the computability predicate for a type <fr:tex display="inline"><![CDATA[A]]></fr:tex> to be equipped with a function that takes neutral forms <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> of terms <fr:tex display="inline"><![CDATA[e : A]]></fr:tex> to computability witnesses for the same term. In the <html:strong>stabilized Tait saturation yoga</html:strong>, we strengthen the induction hypothesis to require for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> a function that extends a computability witness defined only on the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{\color {DarkRed}{e}}]]></fr:tex> to a computability witnessed defined everywhere</html:p>
    <html:p>The twin innovations of <html:em>frontiers of instability</html:em> and <html:em>stabilization</html:em> then suffice to adapt the synthetic normalization argument of <fr:link href="/jms-0015/" title="Chapter 5: synthetic normalization by evaluation" uri="https://www.jonmsterling.com/jms-0015/" display-uri="jms-0015" type="local">Chapter 5</fr:link> to a proof of normalization (and thus decidability) for cubical type theory.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>7</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021/</fr:uri>
            <fr:display-uri>sterling-angiuli-2021</fr:display-uri>
            <fr:route>/sterling-angiuli-2021/</fr:route>
            <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)</fr:meta>
            <fr:meta name="doi">10.1109/LICS52264.2021.9470719</fr:meta>
            <fr:meta name="external">https://arxiv.org/abs/2101.11479</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. Our normalization result is reduction-free, in the sense of yielding a bijection between equivalence classes of terms in context and a tractable language of <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex>/<fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-normal forms. As corollaries we obtain both decidability of judgmental equality and the injectivity of type constructors.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0016/</fr:uri>
            <fr:display-uri>jms-0016</fr:display-uri>
            <fr:route>/jms-0016/</fr:route>
            <fr:title text="Part IV: cubical type theory">Part IV: cubical type theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0017/</fr:uri>
                <fr:display-uri>jms-0017</fr:display-uri>
                <fr:route>/jms-0017/</fr:route>
                <fr:title text="Chapter 6: cartesian cubical type theory">Chapter 6: cartesian cubical type theory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This expository chapter introduces cubical type theory as an extension to Martin-Löf’s type theory by an interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> with two distinct endpoints <fr:tex display="inline"><![CDATA[0, 1 : \mathbb {I}]]></fr:tex>. The interval is a basic “figure” that defines a notion of <html:em>path</html:em> or <html:em>identification</html:em> <fr:tex display="inline"><![CDATA[{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> between two elements of any type; for instance, to identify <fr:tex display="inline"><![CDATA[u,v:A]]></fr:tex> is the same as to construct a function <fr:tex display="inline"><![CDATA[p:\mathbb {I}\to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[p0 = u]]></fr:tex> and <fr:tex display="inline"><![CDATA[p1=v]]></fr:tex>. Terms involving <html:em>variables</html:em> of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> can exhibit complex computational behavior that is difficult to account for: for instance, if <fr:tex display="inline"><![CDATA[p:{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> and <fr:tex display="inline"><![CDATA[i:\mathbb {I}]]></fr:tex> are variables, then the application <fr:tex display="inline"><![CDATA[pi:A]]></fr:tex> is a normal form, but it must nonetheless reduce to either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> when <fr:tex display="inline"><![CDATA[i]]></fr:tex> is substituted for by a constant. Despite appearances, this scenario is fundamentally different from the way that <fr:tex display="inline"><![CDATA[pi]]></fr:tex> must reduce when <fr:tex display="inline"><![CDATA[p]]></fr:tex> is replaced
by a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-abstraction, as normal forms must <html:em>a priori</html:em> be closed under arbitrary <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-substitutions — a necessity, because the normal form of an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube must be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube of normal forms. One of the main technical contributions of this dissertation, introduced in the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">next chapter</fr:link>, is to generalization of the notion of neutral form and the Tait saturation yoga that smoothly accommodates the problematic computational behavior of the interval.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0014/</fr:uri>
                <fr:display-uri>jms-0014</fr:display-uri>
                <fr:route>/jms-0014/</fr:route>
                <fr:title text="Chapter 7: normalization for cubical type theory">Chapter 7: normalization for cubical type theory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This chapter reports the main result of the dissertation, normalization for cubical type theory and its corollaries: injectivity of type constructors, and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability of equality &amp; typing</fr:link>. These results were first obtained by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link> for the fragment of cubical type theory <html:em>without</html:em> universes; the present chapter extends the results of <html:em>op. cit.</html:em> to support a cumulative hierarchy of universes.</html:p>
                <html:p>The central innovation of this chapter is to generalize the notion of neutral form to accommodate the computational behavior of terms that have free variables of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> discussed in our <fr:link href="/jms-0017/" title="Chapter 6: cartesian cubical type theory" uri="https://www.jonmsterling.com/jms-0017/" display-uri="jms-0017" type="local">synopsis of Chapter 6</fr:link>.  In the conventional account of neutral and normal forms, neutrals <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> are built up inductively from
<fr:tex display="inline"><![CDATA[x]]></fr:tex> for term variables <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>, function applications to normal forms <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{\bullet }}}{{\color {DarkBlue}{m}}}]]></fr:tex>
and projections from neutral pairs <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.1}}]]></fr:tex>, <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.2}}]]></fr:tex>; our account of neutrals is much the same, except that each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> comes equipped with a <html:strong>“frontier
  of instability”</html:strong> <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{{\color {DarkRed}{e}}}]]></fr:tex>, a predicate on its free <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-variables that indicates when it “needs to compute further”. We think of a neutral form for an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube as being <html:em>undefined</html:em> on its frontier of instability; the process of restricting a neutral to its frontier of instability is then referred to as <html:em>destabilization</html:em>.</html:p>
                <html:p>When <fr:tex display="inline"><![CDATA[x : A]]></fr:tex> is a variable of an ordinary type, the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\mathopen {}\left ({\color {DarkRed}{\mathsf {var}}}\,{x}\right )\mathclose {}}]]></fr:tex> is empty because variables never need to compute further. Where something new happens is the path type: given a neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,{\mathopen {}\left ({u}\mathrel {{\sim }_{A}}{v}\right )\mathclose {}}]]></fr:tex>
of path type, we have for each term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> a neutral form <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r} : \mathsf {ne}\,A]]></fr:tex> whose frontier of instability is defined like so:</html:p>
                <fr:tex display="block"><![CDATA[  \boldsymbol {\partial }\,{\mathopen {}\left ({{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}\right )\mathclose {}}
=
\boldsymbol {\partial }{\color {DarkRed}{e}}
\lor 
{\mathopen {}\left (r=0\right )\mathclose {}}
\lor 
{\mathopen {}\left (r=1\right )\mathclose {}}
]]></fr:tex>
                <html:p>In other words, the path neutral application <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> needs to compute as soon as e needs to compute, and as soon as the interval term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> becomes equal to a constant. Prior to the introduction of the frontier of instability, the neutrals are embedded into the normals at base types unconditionally, i.e. for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,\mathsf {bool}]]></fr:tex>, we have a normal form <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\lfloor }}{e}{\color {DarkBlue}{\rfloor }} : \mathsf {nf}\,\mathsf {bool}]]></fr:tex>.</html:p>
                <html:p>Now that neutrals are equipped with frontiers of instability, a more refined notion of normal form is needed: when <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> is a neutral form, the corresponding normal form should contain (recursively) normal forms for <fr:tex display="inline"><![CDATA[e]]></fr:tex> that are defined under the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\color {DarkRed}{e}}]]></fr:tex>. To be more concrete,
let <fr:tex display="inline"><![CDATA[x : {\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}]]></fr:tex> be a variable of path type and <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> is a term; then <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}:\mathsf {ne}\,{\mathopen {}\left ({\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}\right )\mathclose {}}]]></fr:tex> is a neutral form for the term <fr:tex display="inline"><![CDATA[xr]]></fr:tex> whose frontier of instability is the boundary <fr:tex display="inline"><![CDATA[(r = 0) \lor  (r = 1)]]></fr:tex>; the corresponding normal form must therefore glue onto <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> additional normal forms for <fr:tex display="inline"><![CDATA[x0]]></fr:tex> and
<fr:tex display="inline"><![CDATA[x1]]></fr:tex>. We refer to the process of completing a neutral with additional data defined on its frontier of instability as stabilization; the <html:em>stabilized</html:em> normal form of <fr:tex display="inline"><![CDATA[xr]]></fr:tex> is then written</html:p>
                <fr:tex display="block"><![CDATA[ {\color {DarkBlue}{\lfloor }}{{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r} \mid  r = 0 \hookrightarrow  {\color {DarkBlue}{\mathsf {tt}}}, r = 1 \hookrightarrow {\color {DarkBlue}{\mathsf {tt}}}}{\color {DarkBlue}{\rfloor }} ]]></fr:tex>
                <html:p>where <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\mathsf {tt}}}]]></fr:tex> is the normal form representing the term <fr:tex display="inline"><![CDATA[\mathsf {tt}]]></fr:tex></html:p>
                <html:p>Just as the embedding of neutrals into normals is “stabilized” by a com patible normal form defined on the neutral’s frontier of instability, so too must the Tait saturation yoga be adjusted. Conventionally one requires the computability predicate for a type <fr:tex display="inline"><![CDATA[A]]></fr:tex> to be equipped with a function that takes neutral forms <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> of terms <fr:tex display="inline"><![CDATA[e : A]]></fr:tex> to computability witnesses for the same term. In the <html:strong>stabilized Tait saturation yoga</html:strong>, we strengthen the induction hypothesis to require for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> a function that extends a computability witness defined only on the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{\color {DarkRed}{e}}]]></fr:tex> to a computability witnessed defined everywhere</html:p>
                <html:p>The twin innovations of <html:em>frontiers of instability</html:em> and <html:em>stabilization</html:em> then suffice to adapt the synthetic normalization argument of <fr:link href="/jms-0015/" title="Chapter 5: synthetic normalization by evaluation" uri="https://www.jonmsterling.com/jms-0015/" display-uri="jms-0015" type="local">Chapter 5</fr:link> to a proof of normalization (and thus decidability) for cubical type theory.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0017/</fr:uri>
            <fr:display-uri>jms-0017</fr:display-uri>
            <fr:route>/jms-0017/</fr:route>
            <fr:title text="Chapter 6: cartesian cubical type theory">Chapter 6: cartesian cubical type theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This expository chapter introduces cubical type theory as an extension to Martin-Löf’s type theory by an interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> with two distinct endpoints <fr:tex display="inline"><![CDATA[0, 1 : \mathbb {I}]]></fr:tex>. The interval is a basic “figure” that defines a notion of <html:em>path</html:em> or <html:em>identification</html:em> <fr:tex display="inline"><![CDATA[{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> between two elements of any type; for instance, to identify <fr:tex display="inline"><![CDATA[u,v:A]]></fr:tex> is the same as to construct a function <fr:tex display="inline"><![CDATA[p:\mathbb {I}\to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[p0 = u]]></fr:tex> and <fr:tex display="inline"><![CDATA[p1=v]]></fr:tex>. Terms involving <html:em>variables</html:em> of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> can exhibit complex computational behavior that is difficult to account for: for instance, if <fr:tex display="inline"><![CDATA[p:{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> and <fr:tex display="inline"><![CDATA[i:\mathbb {I}]]></fr:tex> are variables, then the application <fr:tex display="inline"><![CDATA[pi:A]]></fr:tex> is a normal form, but it must nonetheless reduce to either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> when <fr:tex display="inline"><![CDATA[i]]></fr:tex> is substituted for by a constant. Despite appearances, this scenario is fundamentally different from the way that <fr:tex display="inline"><![CDATA[pi]]></fr:tex> must reduce when <fr:tex display="inline"><![CDATA[p]]></fr:tex> is replaced
by a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-abstraction, as normal forms must <html:em>a priori</html:em> be closed under arbitrary <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-substitutions — a necessity, because the normal form of an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube must be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube of normal forms. One of the main technical contributions of this dissertation, introduced in the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">next chapter</fr:link>, is to generalization of the notion of neutral form and the Tait saturation yoga that smoothly accommodates the problematic computational behavior of the interval.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0015/</fr:uri>
            <fr:display-uri>jms-0015</fr:display-uri>
            <fr:route>/jms-0015/</fr:route>
            <fr:title text="Chapter 5: synthetic normalization by evaluation">Chapter 5: synthetic normalization by evaluation</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This chapter develops a more sophisticated application of synthetic Tait computability, the proof of normalization and decidability of Martin-Löf’s type theory with a cumulative hierarchy of universes. The synthetic argument contained in this chapter builds on the work of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link> on categorical normalization by gluing for simply typed λ-calculus, and that of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> on a presheaf-theoretic version of normalization by evaluation for dependent types. Analogous to the external argument of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link>, we construe the syntax of normal and neutral forms as the initial algebra for an internal inductive definition in the language of synthetic Tait computability. The influence of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> is visible in the definition of the <html:em>Tait saturation yoga</html:em> for dependent types in the synthetic setting, an important closure condition for logical predicates that comprised one of the main innovations of <fr:link href="/tait-1967/" title="Intensional interpretations of functionals of finite type I" uri="https://www.jonmsterling.com/tait-1967/" display-uri="tait-1967" type="local">Tait</fr:link> in the context of simply typed combinators. Although this chapter is intended only as “dry run” for the main result (to be exposed in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link>), the normalization argument presented here has intrinsic value: it is the simplest and most direct proof of normalization and decidability for Martin-Löf type theory with <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-laws and cumulative universes that has appeared in the literature so far.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
            <fr:display-uri>jms-0013</fr:display-uri>
            <fr:route>/jms-0013/</fr:route>
            <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
            <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
            <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
            <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-01A1/</fr:uri>
            <fr:display-uri>jms-01A1</fr:display-uri>
            <fr:route>/jms-01A1/</fr:route>
            <fr:title text="Weeknotes 2025-W15 › Project Pterosaur: yes, I’m building a new proof assistant"><fr:link href="/2025-W15/" title="Weeknotes 2025-W15" uri="https://www.jonmsterling.com/2025-W15/" display-uri="2025-W15" type="local">Weeknotes 2025-W15</fr:link> › <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>: yes, I’m building a new proof assistant</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>I swore after building <fr:link href="https://github.com/RedPRL/cooltt" type="external">cooltt</fr:link>, <fr:link href="https://github.com/RedPRL/redtt" type="external">redtt</fr:link>, and <fr:link href="https://github.com/RedPRL/sml-redprl" type="external">RedPRL</fr:link> that I would never build another proof assistant, as the experience burned around four years of my PhD and resulted (at least directly) in very little publishable work—but, to be fair, I probably would not have made the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">key mathematical discovery</fr:link> of my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">PhD thesis</fr:link> if it were not for these engineering experiments. But I’m back on my bullshit, as the young people say, and hard at work building a new interactive proof assistant that I have code-named <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A2/</fr:uri>
                <fr:display-uri>jms-01A2</fr:display-uri>
                <fr:route>/jms-01A2/</fr:route>
                <fr:title text="Locales in dependent type theory?">Locales in dependent type theory?</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The goal of Pterosaur is to explore the adaptation of <html:em>locales</html:em> from Isabelle to dependent type theory, as a lightweight but extremely expressive alternative to type classes. My colleague <fr:link href="/lawrencepaulson/" title="Lawrence Paulson" uri="https://www.jonmsterling.com/lawrencepaulson/" display-uri="lawrencepaulson" type="local">Larry Paulson</fr:link> has written <fr:link href="https://lawrencecpaulson.github.io/tag/locales" type="external">some great blog posts about locales in Isabelle</fr:link>, and I strongly recommend reading Ballarin’s <fr:link href="https://www21.in.tum.de/~ballarin/publications/jar2019.pdf" type="external">Exploring the Structure of an Algebra Text with Locales</fr:link> to get a feel for what is possible. Here is what locales do:</html:p>
                <html:ol><html:li>Locales appear to completely solve the pain involved when building up hierarchies of mathematical structures and notations, allowing you to effortlessly combine theories along a common core (e.g. defining rings in terms of a multiplicative monoid and an Abelian group sharing the same carrier).</html:li>
      <html:li>Locales allow you to <html:em>add new methods</html:em> to a theory after the fact, and they will magically be available on anything that extended that theory. You can also add new links in the theory graph, and both cycles and diamonds are allowed so long as they are coherent; this is useful if you want to silently regard (e.g.) the space of endomaps on a set as a monoid, etc.</html:li></html:ol>
                <html:p>In comparison to modules and type classes, the strength of locales is that you don’t have to decide ahead of time whether you want to “bundle” fields with their carriers, etc. In contrast, a great deal of the difficult work of mathematical library design and maintainance in tools like Rocq, Agda, and <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link> is figuring out just what things to bundle, and fixing things when your choices inevitably lead to breakage, etc. Locales avoid these problems entirely.</html:p>
                <html:p>Finally, a reasonably usable locale implementation can be obtained <html:em>without any higher-order unification whatsoever</html:em>. I have a feeling that will be extremely important, given how unreliable (and <fr:link href="https://github.com/agda/agda/issues/5837" type="external">incorrect</fr:link>!) most implementations of higher-order unification are; the situation is so bad that it is actually an open problem to define a correct higher-order unification algorithm in the presence of singleton types (such as the unit type). I do think that this can be solved (and may have already been solved by Andras Kovacs), but my point is that the prognosis for unification in dependent type theory is bad.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A3/</fr:uri>
                <fr:display-uri>jms-01A3</fr:display-uri>
                <fr:route>/jms-01A3/</fr:route>
                <fr:title text="Experimental implementation in Lean">Experimental implementation in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The other interesting thing about Pterosaur is that I am implementing it in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link>; I am not verifying anything, and am making free use of Lean’s <html:code>partial</html:code> keyword (which hides potentially divergent code from definitional equality). Instead, I am thinking of Lean as a “better OCaml”: I can’t speak to the quality of the compiler and code generator, but I can absolutely say that from the perspective of day-to-day programming, Lean has a lot of affordances that make it extremely nice to use. On the other hand, Lean’s story for modularity is not so good; but I hope they don’t “fix” it any time soon, because I think that something like locales could be a good option for Lean itself in the future if I am able to demonstrate their potential in the context of Pterosaur’s clean-room implementation.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A4/</fr:uri>
                <fr:display-uri>jms-01A4</fr:display-uri>
                <fr:route>/jms-01A4/</fr:route>
                <fr:title text="A taste of code">A taste of code</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I will have more to say about Pterosaur in the future, but let me leave you with a bit of demo code.</html:p>
                <html:pre><![CDATA[locale Magma { A =>
  car : Type,
  car.isSet : isSet A·car,
  cmp : (x y : A·car) → A·car
}

locale Magma.Hom { f =>
  dom : Magma,
  cod : Magma,
  car : (x : f·dom·car) → f·cod·car,
  cmp : (x y : f·dom·car) → Id f·cod·car (f·car (f·dom·cmp x y)) (f·cod·cmp (f·car x) (f·car y))
}

locale Semigroup { A =>
  splice magma : Magma,
  cmp.assoc : (x y z : A·car) → Id A·car (A·cmp (A·cmp x y) z) (A·cmp x (A·cmp y z))
}

locale Semigroup.Hom {f =>
  dom : Semigroup,
  cod : Semigroup,
  splice magma.hom : Magma.Hom / {dom := f·dom·magma, cod := f·cod·magma}
}

locale Monoid { A =>
  splice semigroup : Semigroup,
  unit : A·car,
  cmp.leftUnit : (x : A·car) → Id A·car (A·cmp A·unit x) x,
  cmp.rightUnit : (x : A·car) → Id A·car (A·cmp x A·unit) x
}

locale Monoid.Hom {f =>
  dom : Monoid,
  cod : Monoid,
  splice semigroup.hom : Semigroup.Hom / {dom := f·dom·semigroup, cod := f·cod·semigroup},
  unit : Id f·cod·car (f·car f·dom·unit) f·cod·unit
}

locale Group { G =>
  splice monoid : Monoid,
  inv : (x : G·car) → G·car,
  inv.inv : (x : G·car) → Id G·car (G·inv (G·inv x)) x
}

locale AbelianGroup { A =>
  splice group : Group,
  splice commutativeOperation : CommutativeOperation / {car := A·car, cmp := A·cmp}
}]]></html:pre>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0017/</fr:uri>
            <fr:display-uri>jms-0017</fr:display-uri>
            <fr:route>/jms-0017/</fr:route>
            <fr:title text="Chapter 6: cartesian cubical type theory">Chapter 6: cartesian cubical type theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This expository chapter introduces cubical type theory as an extension to Martin-Löf’s type theory by an interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> with two distinct endpoints <fr:tex display="inline"><![CDATA[0, 1 : \mathbb {I}]]></fr:tex>. The interval is a basic “figure” that defines a notion of <html:em>path</html:em> or <html:em>identification</html:em> <fr:tex display="inline"><![CDATA[{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> between two elements of any type; for instance, to identify <fr:tex display="inline"><![CDATA[u,v:A]]></fr:tex> is the same as to construct a function <fr:tex display="inline"><![CDATA[p:\mathbb {I}\to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[p0 = u]]></fr:tex> and <fr:tex display="inline"><![CDATA[p1=v]]></fr:tex>. Terms involving <html:em>variables</html:em> of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> can exhibit complex computational behavior that is difficult to account for: for instance, if <fr:tex display="inline"><![CDATA[p:{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> and <fr:tex display="inline"><![CDATA[i:\mathbb {I}]]></fr:tex> are variables, then the application <fr:tex display="inline"><![CDATA[pi:A]]></fr:tex> is a normal form, but it must nonetheless reduce to either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> when <fr:tex display="inline"><![CDATA[i]]></fr:tex> is substituted for by a constant. Despite appearances, this scenario is fundamentally different from the way that <fr:tex display="inline"><![CDATA[pi]]></fr:tex> must reduce when <fr:tex display="inline"><![CDATA[p]]></fr:tex> is replaced
by a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-abstraction, as normal forms must <html:em>a priori</html:em> be closed under arbitrary <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-substitutions — a necessity, because the normal form of an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube must be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube of normal forms. One of the main technical contributions of this dissertation, introduced in the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">next chapter</fr:link>, is to generalization of the notion of neutral form and the Tait saturation yoga that smoothly accommodates the problematic computational behavior of the interval.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0015/</fr:uri>
            <fr:display-uri>jms-0015</fr:display-uri>
            <fr:route>/jms-0015/</fr:route>
            <fr:title text="Chapter 5: synthetic normalization by evaluation">Chapter 5: synthetic normalization by evaluation</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This chapter develops a more sophisticated application of synthetic Tait computability, the proof of normalization and decidability of Martin-Löf’s type theory with a cumulative hierarchy of universes. The synthetic argument contained in this chapter builds on the work of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link> on categorical normalization by gluing for simply typed λ-calculus, and that of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> on a presheaf-theoretic version of normalization by evaluation for dependent types. Analogous to the external argument of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link>, we construe the syntax of normal and neutral forms as the initial algebra for an internal inductive definition in the language of synthetic Tait computability. The influence of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> is visible in the definition of the <html:em>Tait saturation yoga</html:em> for dependent types in the synthetic setting, an important closure condition for logical predicates that comprised one of the main innovations of <fr:link href="/tait-1967/" title="Intensional interpretations of functionals of finite type I" uri="https://www.jonmsterling.com/tait-1967/" display-uri="tait-1967" type="local">Tait</fr:link> in the context of simply typed combinators. Although this chapter is intended only as “dry run” for the main result (to be exposed in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link>), the normalization argument presented here has intrinsic value: it is the simplest and most direct proof of normalization and decidability for Martin-Löf type theory with <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-laws and cumulative universes that has appeared in the literature so far.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000T/</fr:uri>
            <fr:display-uri>jms-000T</fr:display-uri>
            <fr:route>/jms-000T/</fr:route>
            <fr:title text="Decidability of cubical type theory">Decidability of cubical type theory</fr:title>
            <fr:taxon>Conjecture</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The assertions <fr:tex display="inline"><![CDATA[\Gamma \vdash  {A}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash {A\equiv  B}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash  M:A]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\Gamma \vdash  M\equiv  N: A]]></fr:tex> are all decidable.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
