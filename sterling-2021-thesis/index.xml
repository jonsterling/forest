<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2021</fr:year>
      <fr:month>9</fr:month>
      <fr:day>13</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/sterling-2021-thesis/</fr:uri>
    <fr:display-uri>sterling-2021-thesis</fr:display-uri>
    <fr:route>/sterling-2021-thesis/</fr:route>
    <fr:title text="First steps in synthetic Tait computability: the objective metatheory of cubical type theory">First steps in synthetic Tait computability: the objective metatheory of cubical type theory</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="venue">Doctoral dissertation, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta>
    <fr:meta name="bibtex"><![CDATA[@phdthesis{sterling-2021-thesis,
  author = {Sterling, Jonathan},
  school = {Carnegie Mellon University},
  year = {2021},
  doi = {10.5281/zenodo.6990769},
  note = {Version 1.1, revised May 2022},
  number = {CMU-CS-21-142},
  title = {First Steps in Synthetic {Tait} Computability: The Objective Metatheory of Cubical Type Theory},
}]]></fr:meta>
    <fr:meta name="doi">10.5281/zenodo.6990769</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>The implementation and semantics of dependent type theories can be studied in a syntax-independent way: the objective metatheory of dependent type theories exploits the universal properties of their syntactic categories to endow them with computational content, mathematical meaning, and practical implementation (normalization, type checking, elaboration). The semantic methods of the objective metatheory inform the design and implementation of correct-by-construction elaboration algorithms, promising a principled interface between real proof assistants and ideal mathematics.</html:p>
    <html:p>In this dissertation, I add synthetic Tait computability to the arsenal of the objective metatheorist. Synthetic Tait computability is a mathematical machine to reduce difficult problems of type theory and programming languages to trivial theorems of topos theory. First employed by <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link> to reconstruct the theory of program modules and their phase separated parametricity, synthetic Tait computability is deployed here to resolve the last major open question in the syntactic metatheory of cubical type theory: normalization of open terms.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>12</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2021/</fr:uri>
            <fr:display-uri>sterling-harper-2021</fr:display-uri>
            <fr:route>/sterling-harper-2021/</fr:route>
            <fr:title text="Logical relations as types: proof-relevant parametricity for program modules">Logical relations as types: proof-relevant parametricity for program modules</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><fr:link href="/jacm/" title="Journal of the ACM" uri="https://www.jonmsterling.com/jacm/" display-uri="jacm" type="local">Journal of the ACM</fr:link>, Volume 68, Issue 6</fr:meta>
            <fr:meta name="doi">10.1145/3474834</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the <html:em>phase distinction</html:em>, <html:em>computational effects</html:em>, and <html:em>type abstraction</html:em>. We contribute a fresh “synthetic” take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a <html:em>lax modality</html:em> that encapsulates computational effects, placing <html:em>projectibility</html:em> of module expressions on a type-theoretic basis.</html:p>
            <html:p>Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a <html:em>parametricity structure</html:em>. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-<html:em>relevant</html:em> families, where there may be non-trivial evidence witnessing the relatedness of two programs—simplifying the metatheory of strong sums over the collection of types, for although there can be no “relation classifying relations,” one easily accommodates a “family classifying small families.”</html:p>
            <html:p>Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan <html:em>logical relations as types</html:em>, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic <html:em>Artin gluing</html:em> construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2021</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0060/</fr:uri>
                <fr:display-uri>jms-0060</fr:display-uri>
                <fr:route>/jms-0060/</fr:route>
                <fr:title text="Minor mistakes in logical relations as types">Minor mistakes in <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">logical relations as types</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>After going to press, we have fixed the following mistakes:</html:p>
                <html:ol><html:li>In the definition of a logos, we mistakenly said that "colimits commute with finite limits" but we meant to say that they are preserved by pullback. We thank <fr:link href="/sarahzrf/" title="Sarah Z. Rovner-Frydman" uri="https://www.jonmsterling.com/sarahzrf/" display-uri="sarahzrf" type="local">Sarah Z. Rovner-Frydman</fr:link> for noticing this mistake.</html:li>
  <html:li>In Remark 5.15, we used the notation for the closed immersion prior to introducing it.</html:li>
  <html:li>We have fixed a few broken links in the bibliography.</html:li></html:ol>
                <html:p>The local copy hosted here has the corrections implemented</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/karlcrary/" title="Karl Crary" uri="https://www.jonmsterling.com/karlcrary/" display-uri="karlcrary" type="local">Karl Crary</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-009J/</fr:uri>
            <fr:display-uri>jms-009J</fr:display-uri>
            <fr:route>/jms-009J/</fr:route>
            <fr:title text="2022 Edmund M. Clarke Dissertation Award">2022 Edmund M. Clarke Dissertation Award</fr:title>
            <fr:taxon>Award</fr:taxon>
            <fr:meta name="venue">Computer Science Department, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta>
            <fr:meta name="external">https://www.cs.cmu.edu/~scsfacts/csd-dissertation.html</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This award, established in 2018, is endowed with a generous contribution from Emeritus Professor Ed Clarke and his wife Martha. It is presented annually to an outstanding dissertation in the Computer Science Department.</html:p>
            <fr:tree show-metadata="true" expanded="false" numbered="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/karlcrary/" title="Karl Crary" uri="https://www.jonmsterling.com/karlcrary/" display-uri="karlcrary" type="local">Karl Crary</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>9</fr:month>
                  <fr:day>22</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-009L/</fr:uri>
                <fr:display-uri>jms-009L</fr:display-uri>
                <fr:route>/jms-009L/</fr:route>
                <fr:title text="Edmund M. Clarke Dissertation Award">Edmund M. Clarke Dissertation Award</fr:title>
                <fr:taxon>Letter</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Dear friends,</html:p>
                <html:p>I am delighted to announce that <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link> has been selected as the winner of the 2022 Edmund M. Clarke Dissertation Award in CSD for his thesis:</html:p>
                <html:p><fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">First Steps in Synthetic Tait Computability</fr:link>, October 2021</html:p>
                <html:p><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>’s PhD research was advised by <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
                <html:p>This award, endowed by a generous contribution from Professor Ed Clarke and his wife Martha, is given annually to an outstanding dissertation in the Computer Science Department.</html:p>
                <html:p>Congratulations <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>!</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="true" expanded="false" numbered="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2021</fr:year>
                  <fr:month>9</fr:month>
                  <fr:day>13</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/sterling-2021-thesis/</fr:uri>
                <fr:display-uri>sterling-2021-thesis</fr:display-uri>
                <fr:route>/sterling-2021-thesis/</fr:route>
                <fr:title text="First steps in synthetic Tait computability: the objective metatheory of cubical type theory">First steps in synthetic Tait computability: the objective metatheory of cubical type theory</fr:title>
                <fr:taxon>Reference</fr:taxon>
                <fr:meta name="venue">Doctoral dissertation, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta>
                <fr:meta name="bibtex"><![CDATA[@phdthesis{sterling-2021-thesis,
  author = {Sterling, Jonathan},
  school = {Carnegie Mellon University},
  year = {2021},
  doi = {10.5281/zenodo.6990769},
  note = {Version 1.1, revised May 2022},
  number = {CMU-CS-21-142},
  title = {First Steps in Synthetic {Tait} Computability: The Objective Metatheory of Cubical Type Theory},
}]]></fr:meta>
                <fr:meta name="doi">10.5281/zenodo.6990769</fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The implementation and semantics of dependent type theories can be studied in a syntax-independent way: the objective metatheory of dependent type theories exploits the universal properties of their syntactic categories to endow them with computational content, mathematical meaning, and practical implementation (normalization, type checking, elaboration). The semantic methods of the objective metatheory inform the design and implementation of correct-by-construction elaboration algorithms, promising a principled interface between real proof assistants and ideal mathematics.</html:p>
                <html:p>In this dissertation, I add synthetic Tait computability to the arsenal of the objective metatheorist. Synthetic Tait computability is a mathematical machine to reduce difficult problems of type theory and programming languages to trivial theorems of topos theory. First employed by <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link> to reconstruct the theory of program modules and their phase separated parametricity, synthetic Tait computability is deployed here to resolve the last major open question in the syntactic metatheory of cubical type theory: normalization of open terms.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>24</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>5</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2024-universes/</fr:uri>
            <fr:display-uri>gratzer-shulman-sterling-2024-universes</fr:display-uri>
            <fr:route>/gratzer-shulman-sterling-2024-universes/</fr:route>
            <fr:title text="Strict universes for Grothendieck topoi">Strict universes for Grothendieck topoi</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2024-universes,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2024},
  month = may,
  doi = {10.48550/arXiv.2202.12012},
  eprint = {2202.12012},
  eprintclass = {math.CT},
  eprinttype = {arXiv},
  note = {Unpublished manuscript},
  title = {Strict universes for Grothendieck topoi},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.12012</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> famously showed how to lift Grothendieck universes into presheaf topoi, and <fr:link href="/streicher-2005/" title="Universes in toposes" uri="https://www.jonmsterling.com/streicher-2005/" display-uri="streicher-2005" type="local">Streicher</fr:link> has extended their result to the case of sheaf topoi by
sheafification. In parallel, <fr:link href="/van-den-berg-moerdijk-2012/" title="Aspects of predicative algebraic set theory III: sheaves" uri="https://www.jonmsterling.com/van-den-berg-moerdijk-2012/" display-uri="van-den-berg-moerdijk-2012" type="local">van den Berg and Moerdijk</fr:link> have shown in the context of algebraic set theory that similar constructions continue to apply even in weaker metatheories. Unfortunately, sheafification seems not to preserve an important <html:em>realignment</html:em> property enjoyed by presheaf universes that plays a critical role in models of univalent type theory as well as <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link>. When <html:em>multiple</html:em> universes are present, realignment also implies a coherent interpretation of connectives across all universes that justifies the cumulativity laws present in popular formulations of Martin-Löf type theory.</html:p>
            <html:p>We observe that a slight adjustment to an argument of <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link> constructs a cumulative universe hierarchy satisfying the realignment property at every level in any Grothendieck topos. Hence one has direct-style interpretations of Martin-Löf type theory with cumulative universes into all Grothendieck topoi. A further implication is to extend the reach of recent synthetic methods in the semantics of cubical type theory and the syntactic metatheory of type theory and programming languages to all Grothendieck topoi.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/taichiuemura/" title="Taichi Uemura" uri="https://www.jonmsterling.com/taichiuemura/" display-uri="taichiuemura" type="local">Taichi Uemura</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/uemura-2024-diagrams/</fr:uri>
            <fr:display-uri>uemura-2024-diagrams</fr:display-uri>
            <fr:route>/uemura-2024-diagrams/</fr:route>
            <fr:title text="Homotopy type theory as internal languages of diagrams of ∞-logoses">Homotopy type theory as internal languages of diagrams of ∞-logoses</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2212.02444</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We show that certain diagrams of ∞-logoses are reconstructed in internal languages of their oplax limits via lex, accessible modalities, which enables us to use plain homotopy type theory to reason about not only a single ∞-logos but also a diagram of ∞-logoses. This also provides a higher dimensional version of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">Sterling’s synthetic Tait computability</fr:link> — a type theory for higher dimensional logical relations. To prove the main result, we establish a precise correspondence between the lex, accessible localizations of an ∞-logos and the lex, accessible modalities in the internal language of the ∞-logos. To do this, we also partly develop the Kripke-Joyal semantics of homotopy type theory in ∞-logoses.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/treborhuang/" title="Trebor Huang" uri="https://www.jonmsterling.com/treborhuang/" display-uri="treborhuang" type="local">Trebor Huang</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/huang-2023/</fr:uri>
            <fr:display-uri>huang-2023</fr:display-uri>
            <fr:route>/huang-2023/</fr:route>
            <fr:title text="Synthetic Tait computability the hard way">Synthetic Tait computability the hard way</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2310.02051</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We walk through a few proofs of canonicity and normalization, each one with more aspects dissected and re-expressed in category theory, so that readers can compare the difference across proofs. During this process we isolate the different ideas that make up the proofs. Finally we arrive at <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> as proposed by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">J. Sterling</fr:link>. We also give a synthetic proof for parametricity of system F.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/karlcrary/" title="Karl Crary" uri="https://www.jonmsterling.com/karlcrary/" display-uri="karlcrary" type="local">Karl Crary</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-009L/</fr:uri>
            <fr:display-uri>jms-009L</fr:display-uri>
            <fr:route>/jms-009L/</fr:route>
            <fr:title text="Edmund M. Clarke Dissertation Award">Edmund M. Clarke Dissertation Award</fr:title>
            <fr:taxon>Letter</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Dear friends,</html:p>
            <html:p>I am delighted to announce that <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link> has been selected as the winner of the 2022 Edmund M. Clarke Dissertation Award in CSD for his thesis:</html:p>
            <html:p><fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">First Steps in Synthetic Tait Computability</fr:link>, October 2021</html:p>
            <html:p><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>’s PhD research was advised by <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
            <html:p>This award, endowed by a generous contribution from Professor Ed Clarke and his wife Martha, is given annually to an outstanding dissertation in the Computer Science Department.</html:p>
            <html:p>Congratulations <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>!</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0094/</fr:uri>
            <fr:display-uri>jms-0094</fr:display-uri>
            <fr:route>/jms-0094/</fr:route>
            <fr:title text="On the relationship between QTT and STC">On the relationship between <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> and <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>I have been thinking again about the relationship between <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">quantitative type theory</fr:link> and <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> and other approaches to type refinements. One of the defining characteristics of <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> that I thought distinguished it from <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> was the treatment of types: <html:strong>in <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link>, types only depend on the “computational” / unrefined aspect of their context, whereas types in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> are allowed to depend on everything</html:strong>. In the past, I mistakenly believed that this was due to the <html:em>realizability-style interpretation</html:em> of <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link>, in contrast with <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link>’s <html:em>gluing interpretation</html:em>. It is now clear to me that (1) <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> is actually glued (in the sense of <html:em>q-realizability</html:em>, no pun intended), and (2) <html:mark>the nonstandard interpretation of types in <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> corresponds to adding an <html:em>additional</html:em> axiom to <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link>, namely the tininess of the generic proposition.</html:mark></html:p><html:p>It has been suggested to me by <fr:link href="/neelkrishnaswami/" title="Neel Krishnaswami" uri="https://www.jonmsterling.com/neelkrishnaswami/" display-uri="neelkrishnaswami" type="local">Neel Krishnaswami</fr:link> that this property of <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> may not be desirable in all cases (sometimes you want the types to depend on quantitative information), and that for this reason, <html:em>graded type theories</html:em> might be a better way forward in some applications. My results today show that <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> is, in essence, what you get when you relax the <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link>’s assumption that types do not depend on quantitative information. This suggests that we should explore the idea of multiplicities within the context of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> — as any monoidal product on the subuniverse spanned by closed-modal types induces quite directly a form of variable multiplicity in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link>, I expect this direction to be fruitful.</html:p><html:p>My thoughts on the precise relationship between the <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link> models and Artin gluing will be elucidated at a different time. Today, I will restrict myself to sketching an interpretation of a QTT-style language in STC assuming the generic proposition is internally tiny.</html:p><html:p>Let <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex> be an elementary topos equipped with a subterminal object <fr:tex display="inline"><![CDATA[\P \hookrightarrow \mathbf {1}]]></fr:tex> inducing an open subtopos <fr:tex display="inline"><![CDATA[\mathscr {E}\simeq {\mathscr {Q}}_{/\P }\hookrightarrow \mathscr {Q}]]></fr:tex> and its complementary closed subtopos <fr:tex display="inline"><![CDATA[\mathscr {F}\hookrightarrow \mathscr {Q}]]></fr:tex>. This structure is the basis of the interpretation of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link>; if you think of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> in terms of refinements, then stuff from <fr:tex display="inline"><![CDATA[\mathscr {E}]]></fr:tex> is “computational” and stuff from <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is “logical”.</html:p><html:p>We now consider the interpretation of a language of (potentially quantitative) refinements into <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex>. A context <fr:tex display="inline"><![CDATA[\Gamma ]]></fr:tex> is interpreted by an object of <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex>; a type <fr:tex display="inline"><![CDATA[\Gamma \vdash  A]]></fr:tex> is interpreted by a family <fr:tex display="inline"><![CDATA[A\to  \bigcirc {\Gamma }]]></fr:tex>; a term <fr:tex display="inline"><![CDATA[\Gamma \vdash  a : A]]></fr:tex> is interpreted as a map <fr:tex display="inline"><![CDATA[\Gamma \to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\Gamma \to  A \to  \bigcirc \Gamma ]]></fr:tex> is the unit of the monad.</html:p><html:p>So far we have not needed anything beyond the base structure of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">STC</fr:link> in order to give an interpretation of types in <fr:link href="/atkey-2018/" title="The syntax and semantics of Quantitative Type Theory" uri="https://www.jonmsterling.com/atkey-2018/" display-uri="atkey-2018" type="local">QTT</fr:link>’s style. But to extend this interpretation to a universe, we must additionally assume that <fr:tex display="inline"><![CDATA[\P ]]></fr:tex> is internally tiny, in the sense that the exponential functor <fr:tex display="inline"><![CDATA[{\mathopen {}\left (-\right )\mathclose {}}^\P ]]></fr:tex> is a left adjoint. Under these circumstances, the idempotent monad <fr:tex display="inline"><![CDATA[\bigcirc  \equiv  j_*j^* : \mathscr {Q}\to \mathscr {Q}]]></fr:tex> corresponding to the open immersion <fr:tex display="inline"><![CDATA[j : \mathscr {E}\hookrightarrow \mathscr {Q}]]></fr:tex> has a right adjoint <fr:tex display="inline"><![CDATA[\square  : \mathscr {Q}\to  \mathscr {Q}]]></fr:tex>, an idempotent comonad.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>9</fr:month><fr:day>17</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>As <fr:tex display="inline"><![CDATA[\bigcirc  \equiv  j_*j^*]]></fr:tex> is the exponential functor <fr:tex display="inline"><![CDATA[{\mathopen {}\left (-\right )\mathclose {}}^\P ]]></fr:tex>, its right adjoint <fr:tex display="inline"><![CDATA[\square ]]></fr:tex> is therefore the “root functor” <fr:tex display="inline"><![CDATA[{\mathopen {}\left (-\right )\mathclose {}}_\P ]]></fr:tex> that exhibits <fr:tex display="inline"><![CDATA[\P ]]></fr:tex> as an internally tiny object.</html:p>
</fr:mainmatter></fr:tree>
 
<html:p>Although <fr:tex display="inline"><![CDATA[\square ]]></fr:tex> lifts to each slice of <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex>, these liftings do not commute with base change; this will, however, not be an obstacle for us.</html:p><html:p>We will now see how to use the adjunction <fr:tex display="inline"><![CDATA[\bigcirc \dashv \square ]]></fr:tex> to interpret a universe, either for the purpose of interpreting universes of refinement types, or for the purpose of strictifying the model that we have sketched. Let <fr:tex display="inline"><![CDATA[\mathcal {V}]]></fr:tex> be a (standard) universe in <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex>, e.g. a <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann–Streicher universe</fr:link>; we shall then interpret the corresponding universe of refinements as <fr:tex display="inline"><![CDATA[\mathcal {U}:\equiv  \square \mathcal {V}]]></fr:tex>. To see that <fr:tex display="inline"><![CDATA[\mathcal {U}]]></fr:tex> classifies <fr:tex display="inline"><![CDATA[\mathcal {V}]]></fr:tex>-small families of refinements, we compute as follows:</html:p><html:ol><html:li>A code <fr:tex display="inline"><![CDATA[\Gamma \vdash \hat {A} : \mathcal {U}]]></fr:tex> amounts to nothing more than a morphism <fr:tex display="inline"><![CDATA[\hat {A}:\Gamma \to \square {\mathcal {V}}]]></fr:tex>.</html:li>
  <html:li>By adjoint transpose, this is the same as a morphism <fr:tex display="inline"><![CDATA[\hat {A}^\sharp  : \bigcirc {\Gamma }\to \mathcal {V}]]></fr:tex>.</html:li></html:ol><html:p>Thus we see that if <fr:tex display="inline"><![CDATA[\mathcal {V}]]></fr:tex> is generic for <fr:tex display="inline"><![CDATA[\mathcal {V}]]></fr:tex>-small families of (arbitrary) types in <fr:tex display="inline"><![CDATA[\mathscr {Q}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathcal {U} \equiv  \square \mathcal {V}]]></fr:tex> is generic for <fr:tex display="inline"><![CDATA[\mathcal {V}]]></fr:tex>-small families of type refinements, i.e. types whose context is <fr:tex display="inline"><![CDATA[\bigcirc ]]></fr:tex>-modal.</html:p><html:p>Finally, we comment that the tininess of <fr:tex display="inline"><![CDATA[\P ]]></fr:tex> is satisfied in many standard examples, the simplest of which is the Sierpiński topos <fr:tex display="inline"><![CDATA[\mathbf {Set}^{\to }]]></fr:tex>.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-008M/</fr:uri>
            <fr:display-uri>jms-008M</fr:display-uri>
            <fr:route>/jms-008M/</fr:route>
            <fr:title text="Professional history">Professional history</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>From September 2023, I am an <fr:link href="https://www.cst.cam.ac.uk/people/js2878" type="external"><html:em>Associate Professor in Logical Foundations and Formal Methods</html:em></fr:link> at University of Cambridge.</html:p>
            <html:p>From 2022, I was a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> working with <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>.</html:p>
            <html:p>From 2016 to 2021, I was a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Professor Robert Harper</fr:link> at <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link>, where I wrote my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link> on <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link> and its application to <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">normalization for cubical type theory</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0076/</fr:uri>
            <fr:display-uri>jms-0076</fr:display-uri>
            <fr:route>/jms-0076/</fr:route>
            <fr:title text="Context and overall objectives">Context and overall objectives</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction. Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. One of the most extreme forms of computational effect is “higher-order mutable state”, which is when programs can read and write data as well as entire subroutines to the computer’s memory during execution.  Programming languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p>
            <html:p>Recently there have been several significant technical advances in mathematical semantics for programming languages that have been ripe for exploitation. For instance, in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral thesis</fr:link> I developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or “STC” that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, STC enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the STC method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages. Another related advance is the use of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">Synthetic Guarded Domain Theory</fr:link> or “SGDT” as a mathematical language in which to describe and reason about the behavior of computer programs, potentially exhibiting complex interactions with their environment and with other programs. A third advance setting the stage for this project is the development of <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Univalent Foundations and Homotopy Type Theory</fr:link>, a new and backwards-compatible foundation of mathematics that places symmetries and reversible transformations of mathematical structures in the forefront.</html:p>
            <html:p>The goal of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been to combine these three ideas to break a long-standing logjam in the mathematical understanding of computer programming: the denotational semantics and equational separation logic of higher-order mutable state.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-007A/</fr:uri>
            <fr:display-uri>jms-007A</fr:display-uri>
            <fr:route>/jms-007A/</fr:route>
            <fr:title text="Effectful synthetic Tait computability">Effectful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A third achievement of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project was to extend the highly successful “<fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link>” method, developed in my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link>, to the case of realistic programming languages with computational effects. The purpose of this extension was to achieve strong representation independence results, by which we can show the computational indistinguishability of even two programs that allocate memory cells of different types that are linked not by a bijection but by a mere relation, in contrast to univalent reference types. We have gone quite a bit beyond our expectations, as our account of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local"><fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> for higher-order store</fr:link> applies not only to the simple polymorphic store model, but also to the full dependent type theory. This allows many classic results from the literature that previously required very complicated reasoning with the semantic model to be reconstructed in a simpler and more direct fashion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>6</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/harper-2023-calco-mfps/</fr:uri>
            <fr:display-uri>harper-2023-calco-mfps</fr:display-uri>
            <fr:route>/harper-2023-calco-mfps/</fr:route>
            <fr:title text="Integrating cost and behavior in type theory">Integrating cost and behavior in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">http://www.cs.cmu.edu/~rwh/talks/calco-mfps-2023.pdf</fr:meta>
            <fr:meta name="venue"> Plenary invited lecture for CALCO/MFPS 2023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Joint work with <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link> (Carnegie Mellon), <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> (Carnegie Mellon), and <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> (Cambridge).</html:p>
            <html:p>The computational view of intuitionistic dependent type theory is as an intrinsic logic of (functional) programs in which types are viewed as specifications of their behavior. Equational reasoning is particularly relevant in the functional case, where correctness can be formulated as equality between two implementations of the same behavior. Besides behavior, it is also important to specify and verify the cost of programs, measured in terms of their resource usage, with respect to both sequential and parallel evaluation. Although program cost can—and has been—verified in type theory using an extrinsic formulation of programs as data objects, what we seek here is, instead, an intrinsic account within type theory itself.</html:p>
            <html:p>In this talk we discuss Calf, the <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Cost-Aware Logical Framework</fr:link>, which is an extension of dependent call-by-push-value type theory that provides an intrinsic account of both parallel and sequential resource usage for a variety of problem-specific measures of cost. Thus, for example, it is possible to prove that insertion sort and merge sort are equal as regards behavior, but differ in terms of the number of comparisons required to achieve the same results. But how can equal functions have different cost? To provide an intrinsic account of both intensional and extensional properties of programs, we make use of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">Sterling's notion of Synthetic Tait Computability</fr:link>, a generalization of Tait's method originally developed for the study of higher type theory. In STC the concept of a “phase” plays a central role: originally as the distinction between the syntactic and semantic aspects of a computability structure, but more recently applied to the formulation of type theories for program modules and for information flow properties of programs. In Calf we distinguish two phases, the intensional and extensional, which differ as regards the significance of cost accounting—extensionally it is neglected, intensionally it is of paramount importance. Thus, in the extensional phase insertion sort and merge sort are equal, but in the intensional phase they are distinct, and indeed one is proved to have optimal behavior as regards comparisons, and the other not. Importantly, both phases are needed in a cost verification—the proof of the complexity of an algorithm usually relies on aspects of its correctness.</html:p>
            <html:p>We will provide an overview of Calf itself, and of its application in the verification of the cost and behavior of a variety of programs. So far we have been able to verify cost bounds on Euclid's Algorithm, amortized bounds on batched queues, parallel cost bounds on a joinable form of red-black trees, and the equivalence and cost of the aforementioned sorting methods. In a <fr:link href="/grodin-harper-2023-calco/" title="Amortized analysis via coinduction" uri="https://www.jonmsterling.com/grodin-harper-2023-calco/" display-uri="grodin-harper-2023-calco" type="local">companion paper</fr:link> at this meeting <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Grodin</fr:link> and I develop an account of amortization that relates the standard inductive view of instruction sequences with the coinductive view of data structures characterized by the same operations. In ongoing work we are extending the base of verified deterministic algorithms to those taught in the undergraduate parallel algorithms course at Carnegie Mellon, and are extending Calf itself to account for probabilistic methods, which are also used in that course.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000V/</fr:uri>
            <fr:display-uri>jms-000V</fr:display-uri>
            <fr:route>/jms-000V/</fr:route>
            <fr:title text="Detailed overview of First Steps in Synthetic Tait Computability">Detailed overview of <html:em>First Steps in Synthetic Tait Computability</html:em></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We give a chapter-by-chapter overview of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local"><html:em>First Steps in Synthetic Tait Computability</html:em></fr:link>. The novel contributions are contained in Chapters 4, 5, 7, and 8; the remaining Chapters 0-3 and 6 are primarily expository.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000W/</fr:uri>
                <fr:display-uri>jms-000W</fr:display-uri>
                <fr:route>/jms-000W/</fr:route>
                <fr:title text="Part I: dependent dype theory">Part I: dependent dype theory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000X/</fr:uri>
                    <fr:display-uri>jms-000X</fr:display-uri>
                    <fr:route>/jms-000X/</fr:route>
                    <fr:title text="Chapter 0: conspectus on type theory">Chapter 0: conspectus on type theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This chapter situates the motivations and applications of type theory in mathematics and computer science, and poses these against the semantic and syntactic properties of type theory that are needed to substantiate these applications. On the semantic side, type theory needs a number of properties including function extensionality, function comprehension, propositional univalence, effective quotients, etc.; on the syntactic side, type theory needs to be at least consistent, and many applications require both canonicity and decidability. Combining these syntactic and semantic properties into a single system has been a challenge, and cubical type theory was designed with the intention of satisfying them all. Prior to this dissertation, only the decidability conjecture remained open; thus with the present contribution, we regard the <html:em>Cubical Hypothesis</html:em> confirmed.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000Y/</fr:uri>
                    <fr:display-uri>jms-000Y</fr:display-uri>
                    <fr:route>/jms-000Y/</fr:route>
                    <fr:title text="Chapter 1: objective syntax of dependent types">Chapter 1: objective syntax of dependent types</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>To state and prove theorems like <fr:link href="/jms-000S/" title="Cubical canonicity" uri="https://www.jonmsterling.com/jms-000S/" display-uri="jms-000S" type="local">canonicity</fr:link> and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability</fr:link> for a type theory, we must have a mathematical definition of the <html:em>syntax</html:em> of type theory. Conventionally, the syntax of type theory has been studied in several layers: one starts with a definition of “raw” syntax as trees labeled by the names of the generating operations, quotients these trees under permutation of bound variables, and then layers on top of this an additional inductively defined formalism expressing the well-formedness of types, well-formedness of terms, definitional equality of types, and definitional equality of terms. After this, one verifies that definitional equivalence classes of well-formed types and terms can be used as the raw materials to construct a universal model of the type theory that has a universal property: any other model of type theory can be equipped with a unique structure-preserving homomorphism from the universal model. The described universal property determines the universal model up to unique isomorphism, if such a model exists.</html:p>
                    <html:p>We refer to the painstaking process described above as the subjective metatheory, building on the <fr:link href="/hegel-sol/" title="Wissenschaft der Logik" uri="https://www.jonmsterling.com/hegel-sol/" display-uri="hegel-sol" type="local">Hegel</fr:link>–<fr:link href="/lawvere-1994/" title="Tools for the advancement of objective logic: closed categories and toposes" uri="https://www.jonmsterling.com/lawvere-1994/" display-uri="lawvere-1994" type="local">Lawvere</fr:link> <fr:link href="/lawvere-schanuel-2009/" title="Conceptual mathematics: a first introduction to categories" uri="https://www.jonmsterling.com/lawvere-schanuel-2009/" display-uri="lawvere-schanuel-2009" type="local">distinction</fr:link> between objective and subjective approaches to logic. The objective metatheory, in contrast, involves stating and proving results about type theories and programming languages relying only on the universal property of the universal model and not on any specifics of its presentation; the advantage of the objective metatheory is that it is simpler, more direct, more modular, and more composable.</html:p>
                    <html:p>Chapter 1 argues that the subjective metatheory in the sense described is redundant: the decidability conjecture can be stated with respect to any representative of the universal model and does not depend in any way on the raw syntax of type theory, and moreover, for all the type theories considered in this dissertation the existence of at least one representative of the universal model is guaranteed for somewhat trivial reasons that have nothing to do with the specifics of type theory. In this chapter, we develop a logical framework for specifying type theories modularly and working with their universal models in an objective fashion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000Z/</fr:uri>
                <fr:display-uri>jms-000Z</fr:display-uri>
                <fr:route>/jms-000Z/</fr:route>
                <fr:title text="Part II: mathematical Background">Part II: mathematical Background</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0010/</fr:uri>
                    <fr:display-uri>jms-0010</fr:display-uri>
                    <fr:route>/jms-0010/</fr:route>
                    <fr:title text="Chapter 2: the language of topoi">Chapter 2: the language of topoi</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Much of this dissertation is stated and proved by exploiting the language of (Grothendieck) topoi, a concept that leads a dual life as a kind of generalized logic <html:em>and</html:em> as a kind of generalized topology. The viewpoint of topos theory <html:em>qua</html:em> generalized topology plays an important role in this dissertation, and yet it nonetheless remains unfamiliar to most computer scientists and logicians. For this reason, Chapter 2 is provided as sufficient exposition to understand the use of topoi in the remainder of the dissertation, focusing on the <html:em>recollement</html:em> or <html:em>gluing</html:em> of a topos from a pair of complementary open and closed subtopoi, a classical construction that provides the geometrical basis for synthetic Tait computability.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0011/</fr:uri>
                    <fr:display-uri>jms-0011</fr:display-uri>
                    <fr:route>/jms-0011/</fr:route>
                    <fr:title text="Chapter 3: the theory of universes">Chapter 3: the theory of universes</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Universes started their life in the <fr:link href="/sga-4/" title="Théorie des topos et cohomologie étale des schémas (SGA 4)" uri="https://www.jonmsterling.com/sga-4/" display-uri="sga-4" type="local">Grothendieck school of algebraic geometry</fr:link> as a technical device to circumvent the annoyance that there cannot be a “set of all sets”; a universe is a set of enough sets, and whilst a universe cannot contain itself, it may nonetheless lie within an even bigger universe. Several important developments in the theory of universes from the 1970s onward by <fr:link href="/jeanb%C3%A9nabou/" title="Jean Bénabou" uri="https://www.jonmsterling.com/jeanbénabou/" display-uri="jeanbénabou" type="local">Bénabou</fr:link>, <fr:link href="/permartinl%C3%B6f/" title="Per Martin-Löf" uri="https://www.jonmsterling.com/permartinlöf/" display-uri="permartinlöf" type="local">Martin-Löf</fr:link>, <fr:link href="/peterdybjer/" title="Peter Dybjer" uri="https://www.jonmsterling.com/peterdybjer/" display-uri="peterdybjer" type="local">Dybjer</fr:link>, <fr:link href="/martinhofmann/" title="Martin Hofmann" uri="https://www.jonmsterling.com/martinhofmann/" display-uri="martinhofmann" type="local">Hofmann</fr:link>, <fr:link href="/thomasstreicher/" title="Thomas Streicher" uri="https://www.jonmsterling.com/thomasstreicher/" display-uri="thomasstreicher" type="local">Streicher</fr:link>, <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Awodey</fr:link>, and others have collided to deliver the present-day understanding of the centrality of universes in semantics: a model of type theory is just a special kind of universe in a special kind of category. This chapter provides expository background on the theory of universes, including a novel account of open and closed subuniverses to reflect the recollement theory of topoi from <fr:link href="/jms-0010/" title="Chapter 2: the language of topoi" uri="https://www.jonmsterling.com/jms-0010/" display-uri="jms-0010" type="local">Chapter 2</fr:link>. These open and closed subuniverses will play a critical role in the development of synthetic Tait computability in subsequent chapters.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0012/</fr:uri>
                <fr:display-uri>jms-0012</fr:display-uri>
                <fr:route>/jms-0012/</fr:route>
                <fr:title text="Part III: synthetic Tait computability">Part III: synthetic Tait computability</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
                    <fr:display-uri>jms-0013</fr:display-uri>
                    <fr:route>/jms-0013/</fr:route>
                    <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
                    <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
                    <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
                    <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0015/</fr:uri>
                    <fr:display-uri>jms-0015</fr:display-uri>
                    <fr:route>/jms-0015/</fr:route>
                    <fr:title text="Chapter 5: synthetic normalization by evaluation">Chapter 5: synthetic normalization by evaluation</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This chapter develops a more sophisticated application of synthetic Tait computability, the proof of normalization and decidability of Martin-Löf’s type theory with a cumulative hierarchy of universes. The synthetic argument contained in this chapter builds on the work of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link> on categorical normalization by gluing for simply typed λ-calculus, and that of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> on a presheaf-theoretic version of normalization by evaluation for dependent types. Analogous to the external argument of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link>, we construe the syntax of normal and neutral forms as the initial algebra for an internal inductive definition in the language of synthetic Tait computability. The influence of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> is visible in the definition of the <html:em>Tait saturation yoga</html:em> for dependent types in the synthetic setting, an important closure condition for logical predicates that comprised one of the main innovations of <fr:link href="/tait-1967/" title="Intensional interpretations of functionals of finite type I" uri="https://www.jonmsterling.com/tait-1967/" display-uri="tait-1967" type="local">Tait</fr:link> in the context of simply typed combinators. Although this chapter is intended only as “dry run” for the main result (to be exposed in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link>), the normalization argument presented here has intrinsic value: it is the simplest and most direct proof of normalization and decidability for Martin-Löf type theory with <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-laws and cumulative universes that has appeared in the literature so far.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0016/</fr:uri>
                <fr:display-uri>jms-0016</fr:display-uri>
                <fr:route>/jms-0016/</fr:route>
                <fr:title text="Part IV: cubical type theory">Part IV: cubical type theory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0017/</fr:uri>
                    <fr:display-uri>jms-0017</fr:display-uri>
                    <fr:route>/jms-0017/</fr:route>
                    <fr:title text="Chapter 6: cartesian cubical type theory">Chapter 6: cartesian cubical type theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This expository chapter introduces cubical type theory as an extension to Martin-Löf’s type theory by an interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> with two distinct endpoints <fr:tex display="inline"><![CDATA[0, 1 : \mathbb {I}]]></fr:tex>. The interval is a basic “figure” that defines a notion of <html:em>path</html:em> or <html:em>identification</html:em> <fr:tex display="inline"><![CDATA[{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> between two elements of any type; for instance, to identify <fr:tex display="inline"><![CDATA[u,v:A]]></fr:tex> is the same as to construct a function <fr:tex display="inline"><![CDATA[p:\mathbb {I}\to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[p0 = u]]></fr:tex> and <fr:tex display="inline"><![CDATA[p1=v]]></fr:tex>. Terms involving <html:em>variables</html:em> of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> can exhibit complex computational behavior that is difficult to account for: for instance, if <fr:tex display="inline"><![CDATA[p:{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> and <fr:tex display="inline"><![CDATA[i:\mathbb {I}]]></fr:tex> are variables, then the application <fr:tex display="inline"><![CDATA[pi:A]]></fr:tex> is a normal form, but it must nonetheless reduce to either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> when <fr:tex display="inline"><![CDATA[i]]></fr:tex> is substituted for by a constant. Despite appearances, this scenario is fundamentally different from the way that <fr:tex display="inline"><![CDATA[pi]]></fr:tex> must reduce when <fr:tex display="inline"><![CDATA[p]]></fr:tex> is replaced
by a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-abstraction, as normal forms must <html:em>a priori</html:em> be closed under arbitrary <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-substitutions — a necessity, because the normal form of an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube must be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube of normal forms. One of the main technical contributions of this dissertation, introduced in the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">next chapter</fr:link>, is to generalization of the notion of neutral form and the Tait saturation yoga that smoothly accommodates the problematic computational behavior of the interval.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0014/</fr:uri>
                    <fr:display-uri>jms-0014</fr:display-uri>
                    <fr:route>/jms-0014/</fr:route>
                    <fr:title text="Chapter 7: normalization for cubical type theory">Chapter 7: normalization for cubical type theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This chapter reports the main result of the dissertation, normalization for cubical type theory and its corollaries: injectivity of type constructors, and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability of equality &amp; typing</fr:link>. These results were first obtained by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link> for the fragment of cubical type theory <html:em>without</html:em> universes; the present chapter extends the results of <html:em>op. cit.</html:em> to support a cumulative hierarchy of universes.</html:p>
                    <html:p>The central innovation of this chapter is to generalize the notion of neutral form to accommodate the computational behavior of terms that have free variables of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> discussed in our <fr:link href="/jms-0017/" title="Chapter 6: cartesian cubical type theory" uri="https://www.jonmsterling.com/jms-0017/" display-uri="jms-0017" type="local">synopsis of Chapter 6</fr:link>.  In the conventional account of neutral and normal forms, neutrals <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> are built up inductively from
<fr:tex display="inline"><![CDATA[x]]></fr:tex> for term variables <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>, function applications to normal forms <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{\bullet }}}{{\color {DarkBlue}{m}}}]]></fr:tex>
and projections from neutral pairs <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.1}}]]></fr:tex>, <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.2}}]]></fr:tex>; our account of neutrals is much the same, except that each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> comes equipped with a <html:strong>“frontier
  of instability”</html:strong> <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{{\color {DarkRed}{e}}}]]></fr:tex>, a predicate on its free <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-variables that indicates when it “needs to compute further”. We think of a neutral form for an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube as being <html:em>undefined</html:em> on its frontier of instability; the process of restricting a neutral to its frontier of instability is then referred to as <html:em>destabilization</html:em>.</html:p>
                    <html:p>When <fr:tex display="inline"><![CDATA[x : A]]></fr:tex> is a variable of an ordinary type, the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\mathopen {}\left ({\color {DarkRed}{\mathsf {var}}}\,{x}\right )\mathclose {}}]]></fr:tex> is empty because variables never need to compute further. Where something new happens is the path type: given a neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,{\mathopen {}\left ({u}\mathrel {{\sim }_{A}}{v}\right )\mathclose {}}]]></fr:tex>
of path type, we have for each term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> a neutral form <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r} : \mathsf {ne}\,A]]></fr:tex> whose frontier of instability is defined like so:</html:p>
                    <fr:tex display="block"><![CDATA[  \boldsymbol {\partial }\,{\mathopen {}\left ({{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}\right )\mathclose {}}
=
\boldsymbol {\partial }{\color {DarkRed}{e}}
\lor 
{\mathopen {}\left (r=0\right )\mathclose {}}
\lor 
{\mathopen {}\left (r=1\right )\mathclose {}}
]]></fr:tex>
                    <html:p>In other words, the path neutral application <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> needs to compute as soon as e needs to compute, and as soon as the interval term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> becomes equal to a constant. Prior to the introduction of the frontier of instability, the neutrals are embedded into the normals at base types unconditionally, i.e. for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,\mathsf {bool}]]></fr:tex>, we have a normal form <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\lfloor }}{e}{\color {DarkBlue}{\rfloor }} : \mathsf {nf}\,\mathsf {bool}]]></fr:tex>.</html:p>
                    <html:p>Now that neutrals are equipped with frontiers of instability, a more refined notion of normal form is needed: when <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> is a neutral form, the corresponding normal form should contain (recursively) normal forms for <fr:tex display="inline"><![CDATA[e]]></fr:tex> that are defined under the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\color {DarkRed}{e}}]]></fr:tex>. To be more concrete,
let <fr:tex display="inline"><![CDATA[x : {\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}]]></fr:tex> be a variable of path type and <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> is a term; then <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}:\mathsf {ne}\,{\mathopen {}\left ({\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}\right )\mathclose {}}]]></fr:tex> is a neutral form for the term <fr:tex display="inline"><![CDATA[xr]]></fr:tex> whose frontier of instability is the boundary <fr:tex display="inline"><![CDATA[(r = 0) \lor  (r = 1)]]></fr:tex>; the corresponding normal form must therefore glue onto <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> additional normal forms for <fr:tex display="inline"><![CDATA[x0]]></fr:tex> and
<fr:tex display="inline"><![CDATA[x1]]></fr:tex>. We refer to the process of completing a neutral with additional data defined on its frontier of instability as stabilization; the <html:em>stabilized</html:em> normal form of <fr:tex display="inline"><![CDATA[xr]]></fr:tex> is then written</html:p>
                    <fr:tex display="block"><![CDATA[ {\color {DarkBlue}{\lfloor }}{{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r} \mid  r = 0 \hookrightarrow  {\color {DarkBlue}{\mathsf {tt}}}, r = 1 \hookrightarrow {\color {DarkBlue}{\mathsf {tt}}}}{\color {DarkBlue}{\rfloor }} ]]></fr:tex>
                    <html:p>where <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\mathsf {tt}}}]]></fr:tex> is the normal form representing the term <fr:tex display="inline"><![CDATA[\mathsf {tt}]]></fr:tex></html:p>
                    <html:p>Just as the embedding of neutrals into normals is “stabilized” by a com patible normal form defined on the neutral’s frontier of instability, so too must the Tait saturation yoga be adjusted. Conventionally one requires the computability predicate for a type <fr:tex display="inline"><![CDATA[A]]></fr:tex> to be equipped with a function that takes neutral forms <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> of terms <fr:tex display="inline"><![CDATA[e : A]]></fr:tex> to computability witnesses for the same term. In the <html:strong>stabilized Tait saturation yoga</html:strong>, we strengthen the induction hypothesis to require for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> a function that extends a computability witness defined only on the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{\color {DarkRed}{e}}]]></fr:tex> to a computability witnessed defined everywhere</html:p>
                    <html:p>The twin innovations of <html:em>frontiers of instability</html:em> and <html:em>stabilization</html:em> then suffice to adapt the synthetic normalization argument of <fr:link href="/jms-0015/" title="Chapter 5: synthetic normalization by evaluation" uri="https://www.jonmsterling.com/jms-0015/" display-uri="jms-0015" type="local">Chapter 5</fr:link> to a proof of normalization (and thus decidability) for cubical type theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0018/</fr:uri>
                <fr:display-uri>jms-0018</fr:display-uri>
                <fr:route>/jms-0018/</fr:route>
                <fr:title text="Part V: prospects">Part V: prospects</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0019/</fr:uri>
                    <fr:display-uri>jms-0019</fr:display-uri>
                    <fr:route>/jms-0019/</fr:route>
                    <fr:title text="Chapter 8: a plan for PL">Chapter 8: a plan for PL</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This dissertation has focused almost solely on the development and applications of synthetic Tait computability in the context of pure type theory, but the author originally invented synthetic Tait computability to solve problems in core programming languages, as part of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s re-analysis of the <html:em>phase distinction</html:em> in <fr:link href="/harper-mitchell-moggi-1990/" title="Higher-order modules and the phase distinction" uri="https://www.jonmsterling.com/harper-mitchell-moggi-1990/" display-uri="harper-mitchell-moggi-1990" type="local">ML-style</fr:link> <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">module systems</fr:link> between static (compiletime) and dynamic (runtime) code. The purpose of this chapter is to identify several applications of synthetic Tait computability to core programming languages, and set an agenda for future work — some of which has been executed and published following the completion of this dissertation</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-001A/</fr:uri>
                        <fr:display-uri>jms-001A</fr:display-uri>
                        <fr:route>/jms-001A/</fr:route>
                        <fr:title text="§ 8.1: two phase distinctions for program modules">§ 8.1: two phase distinctions for program modules</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A brief overview is given of the applications of synthetic Tait computability to program modules, material that is published in the <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Journal of the ACM</fr:link>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-001B/</fr:uri>
                        <fr:display-uri>jms-001B</fr:display-uri>
                        <fr:route>/jms-001B/</fr:route>
                        <fr:title text="§ 8.2: type refinements and program extraction">§ 8.2: type refinements and program extraction</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The modal language of synthetic Tait computability promises a new and more abstract account of <html:em>refinement types</html:em> and <html:em>program extraction</html:em> via a phase distinction between <html:em>computation</html:em> and <html:em>specification</html:em>. Refinement types are often thought of as a kind of subtype, but there is a fundamental difference: when <fr:tex display="inline"><![CDATA[{\phi }\sqsubset {A}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\psi }\sqsubset {B}]]></fr:tex> are refinements of types <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> respectively, then <fr:tex display="inline"><![CDATA[\phi \to \psi ]]></fr:tex> refines <fr:tex display="inline"><![CDATA[A\to  B]]></fr:tex>. In contrast, subtyping laws for function spaces are contravariant in the domain. The refinements available in synthetic Tait computability are moreover proof-relevant in the sense that specification-level code can contain data in addition to properties. The application to proof-relevant refinement types is employed by <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu, Sterling, Grodin, and Harper</fr:link> to develop a logical framework for simultaneously verifying behavior and complexity of functional programs.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>20</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-001C/</fr:uri>
                        <fr:display-uri>jms-001C</fr:display-uri>
                        <fr:route>/jms-001C/</fr:route>
                        <fr:title text="§ 8.3: information-flow and noninterference">§ 8.3: information-flow and noninterference</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Finally, an application of synthetic Tait computability to <html:em>security</html:em> and <html:em>information flow control</html:em> is identified: a security class is a phase distinction between low and high security. The preliminary results presented in this section have been substantially improved upon by <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">Sterling and Harper</fr:link>, adding support for general recursion and termination-insensitive noninterference by combining synthetic Tait computability with <fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000U/</fr:uri>
            <fr:display-uri>jms-000U</fr:display-uri>
            <fr:route>/jms-000U/</fr:route>
            <fr:title text="Contributions of First Steps in Synthetic Tait Computability">Contributions of <html:em>First Steps in Synthetic Tait Computability</html:em></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">dissertation</fr:link> positively resolves the <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability conjecture</fr:link> for cubical type theory, the last remaining open question in its syntactic metatheory. Standard techniques proved inadequate for tackling this problem, so the bulk of this dissertation focuses on developing a new mathematical technique called <html:strong>synthetic Tait computability</html:strong> that generalizes and abstracts the method of <html:em>Tait computability</html:em> or <html:em>logical predicates</html:em>; in the past two years, synthetic Tait computability has played a central role in solving several problems in both type theory and core programming languages, suggesting that this dissertation presents a lasting and transformative contribution to the state of the art.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000Q/</fr:uri>
            <fr:display-uri>jms-000Q</fr:display-uri>
            <fr:route>/jms-000Q/</fr:route>
            <fr:title text="Dissertation overview: first steps in synthetic Tait computability">Dissertation overview: <html:em>first steps in synthetic Tait computability</html:em></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This is a chapter-by-chapter overview of the <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">dissertation of Jonathan Sterling</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000R/</fr:uri>
                <fr:display-uri>jms-000R</fr:display-uri>
                <fr:route>/jms-000R/</fr:route>
                <fr:title text="Background on homotopy and cubical type theory">Background on homotopy and cubical type theory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>For more than four decades, dependent type theory has been positioned as the “common language” that can finally <fr:link href="/martin-loef-1982/" title="Constructive mathematics and computer programming" uri="https://www.jonmsterling.com/martin-loef-1982/" display-uri="martin-loef-1982" type="local">unify mathematics and computer programming</fr:link>: while it has never been controversial that a computer program is a form of mathematical construction, the running hypothesis of the type theoretic community has been the converse to this claim, namely that mathematical constructions should be viewed as programs that can in principle be executed by a physical machine — roughly, <html:strong>sets</html:strong> = <html:strong>types</html:strong> and <html:strong>elements</html:strong> = <html:strong>programs</html:strong>. Thus the struggle to realize this type theoretic hypothesis has been a two-way process, punctuated by moments at which the mathematical meaning of a programming construct is elucidated, or at which the computational content of a mathematical construct is uncovered.</html:p>
                <html:p>In the current millennium, a new identification has been taking shape in which <html:strong>types</html:strong> = <html:strong><html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-groupoids</html:span></html:strong> (homotopy types), which are an infinite-dimensional generalization of sets; the origins of this new perspective on type theory lie with <fr:link href="/hofmann-streicher-1998/" title="The groupoid interpretation of type theory" uri="https://www.jonmsterling.com/hofmann-streicher-1998/" display-uri="hofmann-streicher-1998" type="local">Hofmann and Streicher’s 1998 groupoid interpretation of type theory</fr:link>, combined with the revolutionary contributions of <fr:link href="/voevodsky-2006/" title="A very short note on the homotopy λ-calculus" uri="https://www.jonmsterling.com/voevodsky-2006/" display-uri="voevodsky-2006" type="local">Voevodsky</fr:link> and <fr:link href="/awodey-warren-2009/" title="Homotopy theoretic models of identity types" uri="https://www.jonmsterling.com/awodey-warren-2009/" display-uri="awodey-warren-2009" type="local">Awodey and Warren</fr:link> respectively. The main feature of the new language, dubbed <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local"><html:strong>homotopy type theory</html:strong></fr:link> or <html:strong>HoTT</html:strong>, is that isomorphisms between types are equipped with a new induction rule called univalence stating that all type theoretic constructs respect isomorphisms: to a first approximation, if <fr:tex display="inline"><![CDATA[A \cong  B]]></fr:tex> then <fr:tex display="inline"><![CDATA[P(A) \cong  P(B)]]></fr:tex> for any <fr:tex display="inline"><![CDATA[P]]></fr:tex>. The univalence principle is motivated by the phenomenon of homotopy invariance that pervades the large-scale structure of modern-day mathematics, from algebraic topology to algebraic geometry to mathematical physics; as a programming construct, univalence suggests <fr:link href="/acmz-2021/" title="Internalizing representation independence with univalence" uri="https://www.jonmsterling.com/acmz-2021/" display-uri="acmz-2021" type="local">new approaches</fr:link> to both generic and modular programming.</html:p>
                <html:p>Thus one of the main projects for the first decade of homotopy type theory was to substantiate the relationship between HoTT and mathematics on the one hand, and between HoTT and computer programming on the other hand. The question of whether homotopy type theoretic language can be interpreted in sheaves on arbitrary infinite-dimensional spaces (<html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-topoi</html:span>) has finally been resolved satisfactorily by <fr:link href="/shulman-2019/" title="All (∞,1)-toposes have strict univalent universes" uri="https://www.jonmsterling.com/shulman-2019/" display-uri="shulman-2019" type="local">Shulman</fr:link> in 2019. On the other hand, the computational interpretation of homotopy type theory has involved a reformulation of HoTT called <html:strong><fr:link href="/abchfl-2021/" title="Syntax and models of Cartesian cubical type theory" uri="https://www.jonmsterling.com/abchfl-2021/" display-uri="abchfl-2021" type="local">cubical</fr:link> <fr:link href="/angiuli-favonia-harper-2018/" title="Cartesian cubical computational type theory: constructive reasoning with paths and equalities" uri="https://www.jonmsterling.com/angiuli-favonia-harper-2018/" display-uri="angiuli-favonia-harper-2018" type="local">type</fr:link> <fr:link href="/cchm-2017/" title="Cubical type theory: a constructive interpretation of the univalence axiom" uri="https://www.jonmsterling.com/cchm-2017/" display-uri="cchm-2017" type="local">theory</fr:link></html:strong> that reorganizes the higher-dimensional structure discussed by considering all the points, lines, squares, cubes, hypercubes, and so-on that one can draw in a given type. The computational interpretation of the new cubical type theory can be split into two different conjectures:</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000S/</fr:uri>
                    <fr:display-uri>jms-000S</fr:display-uri>
                    <fr:route>/jms-000S/</fr:route>
                    <fr:title text="Cubical canonicity">Cubical canonicity</fr:title>
                    <fr:taxon>Conjecture</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>For any closed term <fr:tex display="inline"><![CDATA[\cdot \vdash  N:\mathsf {nat}]]></fr:tex> of cubical type theory, there exists a unique natural number <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\cdot \vdash  N\equiv  \bar {n}:\mathsf {nat}]]></fr:tex> where <fr:tex display="inline"><![CDATA[\bar {n}]]></fr:tex> is the encoding of the number <fr:tex display="inline"><![CDATA[n]]></fr:tex> as a term in the type theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000T/</fr:uri>
                    <fr:display-uri>jms-000T</fr:display-uri>
                    <fr:route>/jms-000T/</fr:route>
                    <fr:title text="Decidability of cubical type theory">Decidability of cubical type theory</fr:title>
                    <fr:taxon>Conjecture</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The assertions <fr:tex display="inline"><![CDATA[\Gamma \vdash  {A}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash {A\equiv  B}\ \textit {type}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Gamma \vdash  M:A]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\Gamma \vdash  M\equiv  N: A]]></fr:tex> are all decidable.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>The <fr:link href="/jms-000S/" title="Cubical canonicity" uri="https://www.jonmsterling.com/jms-000S/" display-uri="jms-000S" type="local">canonicity conjecture</fr:link> ensures that terms written in cubical type theory can be thought of as computer programs, and was verified independently by <fr:link href="/huber-2018/" title="Canonicity for cubical type theory" uri="https://www.jonmsterling.com/huber-2018/" display-uri="huber-2018" type="local">Huber</fr:link> and <fr:link href="/angiuli-2019/" title="Computational semantics of cartesian cubical type theory" uri="https://www.jonmsterling.com/angiuli-2019/" display-uri="angiuli-2019" type="local">Angiuli</fr:link> for different variants of cubical type theory. The <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability conjecture</fr:link> is no less important, as it is a necessary ingredient to implement a <html:em>typechecker</html:em> or a <html:em>compiler</html:em> for a programming language based on cubical type theory.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000U/</fr:uri>
                <fr:display-uri>jms-000U</fr:display-uri>
                <fr:route>/jms-000U/</fr:route>
                <fr:title text="Contributions of First Steps in Synthetic Tait Computability">Contributions of <html:em>First Steps in Synthetic Tait Computability</html:em></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">dissertation</fr:link> positively resolves the <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability conjecture</fr:link> for cubical type theory, the last remaining open question in its syntactic metatheory. Standard techniques proved inadequate for tackling this problem, so the bulk of this dissertation focuses on developing a new mathematical technique called <html:strong>synthetic Tait computability</html:strong> that generalizes and abstracts the method of <html:em>Tait computability</html:em> or <html:em>logical predicates</html:em>; in the past two years, synthetic Tait computability has played a central role in solving several problems in both type theory and core programming languages, suggesting that this dissertation presents a lasting and transformative contribution to the state of the art.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000V/</fr:uri>
                <fr:display-uri>jms-000V</fr:display-uri>
                <fr:route>/jms-000V/</fr:route>
                <fr:title text="Detailed overview of First Steps in Synthetic Tait Computability">Detailed overview of <html:em>First Steps in Synthetic Tait Computability</html:em></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We give a chapter-by-chapter overview of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local"><html:em>First Steps in Synthetic Tait Computability</html:em></fr:link>. The novel contributions are contained in Chapters 4, 5, 7, and 8; the remaining Chapters 0-3 and 6 are primarily expository.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000W/</fr:uri>
                    <fr:display-uri>jms-000W</fr:display-uri>
                    <fr:route>/jms-000W/</fr:route>
                    <fr:title text="Part I: dependent dype theory">Part I: dependent dype theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-000X/</fr:uri>
                        <fr:display-uri>jms-000X</fr:display-uri>
                        <fr:route>/jms-000X/</fr:route>
                        <fr:title text="Chapter 0: conspectus on type theory">Chapter 0: conspectus on type theory</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>This chapter situates the motivations and applications of type theory in mathematics and computer science, and poses these against the semantic and syntactic properties of type theory that are needed to substantiate these applications. On the semantic side, type theory needs a number of properties including function extensionality, function comprehension, propositional univalence, effective quotients, etc.; on the syntactic side, type theory needs to be at least consistent, and many applications require both canonicity and decidability. Combining these syntactic and semantic properties into a single system has been a challenge, and cubical type theory was designed with the intention of satisfying them all. Prior to this dissertation, only the decidability conjecture remained open; thus with the present contribution, we regard the <html:em>Cubical Hypothesis</html:em> confirmed.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-000Y/</fr:uri>
                        <fr:display-uri>jms-000Y</fr:display-uri>
                        <fr:route>/jms-000Y/</fr:route>
                        <fr:title text="Chapter 1: objective syntax of dependent types">Chapter 1: objective syntax of dependent types</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>To state and prove theorems like <fr:link href="/jms-000S/" title="Cubical canonicity" uri="https://www.jonmsterling.com/jms-000S/" display-uri="jms-000S" type="local">canonicity</fr:link> and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability</fr:link> for a type theory, we must have a mathematical definition of the <html:em>syntax</html:em> of type theory. Conventionally, the syntax of type theory has been studied in several layers: one starts with a definition of “raw” syntax as trees labeled by the names of the generating operations, quotients these trees under permutation of bound variables, and then layers on top of this an additional inductively defined formalism expressing the well-formedness of types, well-formedness of terms, definitional equality of types, and definitional equality of terms. After this, one verifies that definitional equivalence classes of well-formed types and terms can be used as the raw materials to construct a universal model of the type theory that has a universal property: any other model of type theory can be equipped with a unique structure-preserving homomorphism from the universal model. The described universal property determines the universal model up to unique isomorphism, if such a model exists.</html:p>
                        <html:p>We refer to the painstaking process described above as the subjective metatheory, building on the <fr:link href="/hegel-sol/" title="Wissenschaft der Logik" uri="https://www.jonmsterling.com/hegel-sol/" display-uri="hegel-sol" type="local">Hegel</fr:link>–<fr:link href="/lawvere-1994/" title="Tools for the advancement of objective logic: closed categories and toposes" uri="https://www.jonmsterling.com/lawvere-1994/" display-uri="lawvere-1994" type="local">Lawvere</fr:link> <fr:link href="/lawvere-schanuel-2009/" title="Conceptual mathematics: a first introduction to categories" uri="https://www.jonmsterling.com/lawvere-schanuel-2009/" display-uri="lawvere-schanuel-2009" type="local">distinction</fr:link> between objective and subjective approaches to logic. The objective metatheory, in contrast, involves stating and proving results about type theories and programming languages relying only on the universal property of the universal model and not on any specifics of its presentation; the advantage of the objective metatheory is that it is simpler, more direct, more modular, and more composable.</html:p>
                        <html:p>Chapter 1 argues that the subjective metatheory in the sense described is redundant: the decidability conjecture can be stated with respect to any representative of the universal model and does not depend in any way on the raw syntax of type theory, and moreover, for all the type theories considered in this dissertation the existence of at least one representative of the universal model is guaranteed for somewhat trivial reasons that have nothing to do with the specifics of type theory. In this chapter, we develop a logical framework for specifying type theories modularly and working with their universal models in an objective fashion.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000Z/</fr:uri>
                    <fr:display-uri>jms-000Z</fr:display-uri>
                    <fr:route>/jms-000Z/</fr:route>
                    <fr:title text="Part II: mathematical Background">Part II: mathematical Background</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0010/</fr:uri>
                        <fr:display-uri>jms-0010</fr:display-uri>
                        <fr:route>/jms-0010/</fr:route>
                        <fr:title text="Chapter 2: the language of topoi">Chapter 2: the language of topoi</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Much of this dissertation is stated and proved by exploiting the language of (Grothendieck) topoi, a concept that leads a dual life as a kind of generalized logic <html:em>and</html:em> as a kind of generalized topology. The viewpoint of topos theory <html:em>qua</html:em> generalized topology plays an important role in this dissertation, and yet it nonetheless remains unfamiliar to most computer scientists and logicians. For this reason, Chapter 2 is provided as sufficient exposition to understand the use of topoi in the remainder of the dissertation, focusing on the <html:em>recollement</html:em> or <html:em>gluing</html:em> of a topos from a pair of complementary open and closed subtopoi, a classical construction that provides the geometrical basis for synthetic Tait computability.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0011/</fr:uri>
                        <fr:display-uri>jms-0011</fr:display-uri>
                        <fr:route>/jms-0011/</fr:route>
                        <fr:title text="Chapter 3: the theory of universes">Chapter 3: the theory of universes</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Universes started their life in the <fr:link href="/sga-4/" title="Théorie des topos et cohomologie étale des schémas (SGA 4)" uri="https://www.jonmsterling.com/sga-4/" display-uri="sga-4" type="local">Grothendieck school of algebraic geometry</fr:link> as a technical device to circumvent the annoyance that there cannot be a “set of all sets”; a universe is a set of enough sets, and whilst a universe cannot contain itself, it may nonetheless lie within an even bigger universe. Several important developments in the theory of universes from the 1970s onward by <fr:link href="/jeanb%C3%A9nabou/" title="Jean Bénabou" uri="https://www.jonmsterling.com/jeanbénabou/" display-uri="jeanbénabou" type="local">Bénabou</fr:link>, <fr:link href="/permartinl%C3%B6f/" title="Per Martin-Löf" uri="https://www.jonmsterling.com/permartinlöf/" display-uri="permartinlöf" type="local">Martin-Löf</fr:link>, <fr:link href="/peterdybjer/" title="Peter Dybjer" uri="https://www.jonmsterling.com/peterdybjer/" display-uri="peterdybjer" type="local">Dybjer</fr:link>, <fr:link href="/martinhofmann/" title="Martin Hofmann" uri="https://www.jonmsterling.com/martinhofmann/" display-uri="martinhofmann" type="local">Hofmann</fr:link>, <fr:link href="/thomasstreicher/" title="Thomas Streicher" uri="https://www.jonmsterling.com/thomasstreicher/" display-uri="thomasstreicher" type="local">Streicher</fr:link>, <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Awodey</fr:link>, and others have collided to deliver the present-day understanding of the centrality of universes in semantics: a model of type theory is just a special kind of universe in a special kind of category. This chapter provides expository background on the theory of universes, including a novel account of open and closed subuniverses to reflect the recollement theory of topoi from <fr:link href="/jms-0010/" title="Chapter 2: the language of topoi" uri="https://www.jonmsterling.com/jms-0010/" display-uri="jms-0010" type="local">Chapter 2</fr:link>. These open and closed subuniverses will play a critical role in the development of synthetic Tait computability in subsequent chapters.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0012/</fr:uri>
                    <fr:display-uri>jms-0012</fr:display-uri>
                    <fr:route>/jms-0012/</fr:route>
                    <fr:title text="Part III: synthetic Tait computability">Part III: synthetic Tait computability</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
                        <fr:display-uri>jms-0013</fr:display-uri>
                        <fr:route>/jms-0013/</fr:route>
                        <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
                        <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
                        <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
                        <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0015/</fr:uri>
                        <fr:display-uri>jms-0015</fr:display-uri>
                        <fr:route>/jms-0015/</fr:route>
                        <fr:title text="Chapter 5: synthetic normalization by evaluation">Chapter 5: synthetic normalization by evaluation</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>This chapter develops a more sophisticated application of synthetic Tait computability, the proof of normalization and decidability of Martin-Löf’s type theory with a cumulative hierarchy of universes. The synthetic argument contained in this chapter builds on the work of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link> on categorical normalization by gluing for simply typed λ-calculus, and that of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> on a presheaf-theoretic version of normalization by evaluation for dependent types. Analogous to the external argument of <fr:link href="/fiore-2002/" title="Semantic analysis of normalisation by evaluation for typed lambda calculus" uri="https://www.jonmsterling.com/fiore-2002/" display-uri="fiore-2002" type="local">Fiore</fr:link>, we construe the syntax of normal and neutral forms as the initial algebra for an internal inductive definition in the language of synthetic Tait computability. The influence of <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> is visible in the definition of the <html:em>Tait saturation yoga</html:em> for dependent types in the synthetic setting, an important closure condition for logical predicates that comprised one of the main innovations of <fr:link href="/tait-1967/" title="Intensional interpretations of functionals of finite type I" uri="https://www.jonmsterling.com/tait-1967/" display-uri="tait-1967" type="local">Tait</fr:link> in the context of simply typed combinators. Although this chapter is intended only as “dry run” for the main result (to be exposed in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link>), the normalization argument presented here has intrinsic value: it is the simplest and most direct proof of normalization and decidability for Martin-Löf type theory with <fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-laws and cumulative universes that has appeared in the literature so far.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0016/</fr:uri>
                    <fr:display-uri>jms-0016</fr:display-uri>
                    <fr:route>/jms-0016/</fr:route>
                    <fr:title text="Part IV: cubical type theory">Part IV: cubical type theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0017/</fr:uri>
                        <fr:display-uri>jms-0017</fr:display-uri>
                        <fr:route>/jms-0017/</fr:route>
                        <fr:title text="Chapter 6: cartesian cubical type theory">Chapter 6: cartesian cubical type theory</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>This expository chapter introduces cubical type theory as an extension to Martin-Löf’s type theory by an interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> with two distinct endpoints <fr:tex display="inline"><![CDATA[0, 1 : \mathbb {I}]]></fr:tex>. The interval is a basic “figure” that defines a notion of <html:em>path</html:em> or <html:em>identification</html:em> <fr:tex display="inline"><![CDATA[{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> between two elements of any type; for instance, to identify <fr:tex display="inline"><![CDATA[u,v:A]]></fr:tex> is the same as to construct a function <fr:tex display="inline"><![CDATA[p:\mathbb {I}\to  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[p0 = u]]></fr:tex> and <fr:tex display="inline"><![CDATA[p1=v]]></fr:tex>. Terms involving <html:em>variables</html:em> of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> can exhibit complex computational behavior that is difficult to account for: for instance, if <fr:tex display="inline"><![CDATA[p:{u}\mathrel {{\sim }_{A}}{v}]]></fr:tex> and <fr:tex display="inline"><![CDATA[i:\mathbb {I}]]></fr:tex> are variables, then the application <fr:tex display="inline"><![CDATA[pi:A]]></fr:tex> is a normal form, but it must nonetheless reduce to either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> when <fr:tex display="inline"><![CDATA[i]]></fr:tex> is substituted for by a constant. Despite appearances, this scenario is fundamentally different from the way that <fr:tex display="inline"><![CDATA[pi]]></fr:tex> must reduce when <fr:tex display="inline"><![CDATA[p]]></fr:tex> is replaced
by a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-abstraction, as normal forms must <html:em>a priori</html:em> be closed under arbitrary <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-substitutions — a necessity, because the normal form of an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube must be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube of normal forms. One of the main technical contributions of this dissertation, introduced in the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">next chapter</fr:link>, is to generalization of the notion of neutral form and the Tait saturation yoga that smoothly accommodates the problematic computational behavior of the interval.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0014/</fr:uri>
                        <fr:display-uri>jms-0014</fr:display-uri>
                        <fr:route>/jms-0014/</fr:route>
                        <fr:title text="Chapter 7: normalization for cubical type theory">Chapter 7: normalization for cubical type theory</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>This chapter reports the main result of the dissertation, normalization for cubical type theory and its corollaries: injectivity of type constructors, and <fr:link href="/jms-000T/" title="Decidability of cubical type theory" uri="https://www.jonmsterling.com/jms-000T/" display-uri="jms-000T" type="local">decidability of equality &amp; typing</fr:link>. These results were first obtained by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link> for the fragment of cubical type theory <html:em>without</html:em> universes; the present chapter extends the results of <html:em>op. cit.</html:em> to support a cumulative hierarchy of universes.</html:p>
                        <html:p>The central innovation of this chapter is to generalize the notion of neutral form to accommodate the computational behavior of terms that have free variables of type <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> discussed in our <fr:link href="/jms-0017/" title="Chapter 6: cartesian cubical type theory" uri="https://www.jonmsterling.com/jms-0017/" display-uri="jms-0017" type="local">synopsis of Chapter 6</fr:link>.  In the conventional account of neutral and normal forms, neutrals <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> are built up inductively from
<fr:tex display="inline"><![CDATA[x]]></fr:tex> for term variables <fr:tex display="inline"><![CDATA[x : A]]></fr:tex>, function applications to normal forms <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{\bullet }}}{{\color {DarkBlue}{m}}}]]></fr:tex>
and projections from neutral pairs <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.1}}]]></fr:tex>, <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}{\color {DarkRed}{.2}}]]></fr:tex>; our account of neutrals is much the same, except that each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> comes equipped with a <html:strong>“frontier
  of instability”</html:strong> <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{{\color {DarkRed}{e}}}]]></fr:tex>, a predicate on its free <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>-variables that indicates when it “needs to compute further”. We think of a neutral form for an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-cube as being <html:em>undefined</html:em> on its frontier of instability; the process of restricting a neutral to its frontier of instability is then referred to as <html:em>destabilization</html:em>.</html:p>
                        <html:p>When <fr:tex display="inline"><![CDATA[x : A]]></fr:tex> is a variable of an ordinary type, the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\mathopen {}\left ({\color {DarkRed}{\mathsf {var}}}\,{x}\right )\mathclose {}}]]></fr:tex> is empty because variables never need to compute further. Where something new happens is the path type: given a neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,{\mathopen {}\left ({u}\mathrel {{\sim }_{A}}{v}\right )\mathclose {}}]]></fr:tex>
of path type, we have for each term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> a neutral form <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r} : \mathsf {ne}\,A]]></fr:tex> whose frontier of instability is defined like so:</html:p>
                        <fr:tex display="block"><![CDATA[  \boldsymbol {\partial }\,{\mathopen {}\left ({{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}\right )\mathclose {}}
=
\boldsymbol {\partial }{\color {DarkRed}{e}}
\lor 
{\mathopen {}\left (r=0\right )\mathclose {}}
\lor 
{\mathopen {}\left (r=1\right )\mathclose {}}
]]></fr:tex>
                        <html:p>In other words, the path neutral application <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{e}}}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> needs to compute as soon as e needs to compute, and as soon as the interval term <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> becomes equal to a constant. Prior to the introduction of the frontier of instability, the neutrals are embedded into the normals at base types unconditionally, i.e. for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}} : \mathsf {ne}\,\mathsf {bool}]]></fr:tex>, we have a normal form <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\lfloor }}{e}{\color {DarkBlue}{\rfloor }} : \mathsf {nf}\,\mathsf {bool}]]></fr:tex>.</html:p>
                        <html:p>Now that neutrals are equipped with frontiers of instability, a more refined notion of normal form is needed: when <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> is a neutral form, the corresponding normal form should contain (recursively) normal forms for <fr:tex display="inline"><![CDATA[e]]></fr:tex> that are defined under the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }\,{\color {DarkRed}{e}}]]></fr:tex>. To be more concrete,
let <fr:tex display="inline"><![CDATA[x : {\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}]]></fr:tex> be a variable of path type and <fr:tex display="inline"><![CDATA[r : \mathbb {I}]]></fr:tex> is a term; then <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}:\mathsf {ne}\,{\mathopen {}\left ({\mathsf {tt}}\mathrel {{\sim }_{\mathsf {bool}}}{\mathsf {tt}}\right )\mathclose {}}]]></fr:tex> is a neutral form for the term <fr:tex display="inline"><![CDATA[xr]]></fr:tex> whose frontier of instability is the boundary <fr:tex display="inline"><![CDATA[(r = 0) \lor  (r = 1)]]></fr:tex>; the corresponding normal form must therefore glue onto <fr:tex display="inline"><![CDATA[{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r}]]></fr:tex> additional normal forms for <fr:tex display="inline"><![CDATA[x0]]></fr:tex> and
<fr:tex display="inline"><![CDATA[x1]]></fr:tex>. We refer to the process of completing a neutral with additional data defined on its frontier of instability as stabilization; the <html:em>stabilized</html:em> normal form of <fr:tex display="inline"><![CDATA[xr]]></fr:tex> is then written</html:p>
                        <fr:tex display="block"><![CDATA[ {\color {DarkBlue}{\lfloor }}{{{\color {DarkRed}{\mathsf {var}}}\,x}\mathrel {{\color {DarkRed}{@}}}{r} \mid  r = 0 \hookrightarrow  {\color {DarkBlue}{\mathsf {tt}}}, r = 1 \hookrightarrow {\color {DarkBlue}{\mathsf {tt}}}}{\color {DarkBlue}{\rfloor }} ]]></fr:tex>
                        <html:p>where <fr:tex display="inline"><![CDATA[{\color {DarkBlue}{\mathsf {tt}}}]]></fr:tex> is the normal form representing the term <fr:tex display="inline"><![CDATA[\mathsf {tt}]]></fr:tex></html:p>
                        <html:p>Just as the embedding of neutrals into normals is “stabilized” by a com patible normal form defined on the neutral’s frontier of instability, so too must the Tait saturation yoga be adjusted. Conventionally one requires the computability predicate for a type <fr:tex display="inline"><![CDATA[A]]></fr:tex> to be equipped with a function that takes neutral forms <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> of terms <fr:tex display="inline"><![CDATA[e : A]]></fr:tex> to computability witnesses for the same term. In the <html:strong>stabilized Tait saturation yoga</html:strong>, we strengthen the induction hypothesis to require for each neutral form <fr:tex display="inline"><![CDATA[{\color {DarkRed}{e}}]]></fr:tex> a function that extends a computability witness defined only on the frontier of instability <fr:tex display="inline"><![CDATA[\boldsymbol {\partial }{\color {DarkRed}{e}}]]></fr:tex> to a computability witnessed defined everywhere</html:p>
                        <html:p>The twin innovations of <html:em>frontiers of instability</html:em> and <html:em>stabilization</html:em> then suffice to adapt the synthetic normalization argument of <fr:link href="/jms-0015/" title="Chapter 5: synthetic normalization by evaluation" uri="https://www.jonmsterling.com/jms-0015/" display-uri="jms-0015" type="local">Chapter 5</fr:link> to a proof of normalization (and thus decidability) for cubical type theory.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0018/</fr:uri>
                    <fr:display-uri>jms-0018</fr:display-uri>
                    <fr:route>/jms-0018/</fr:route>
                    <fr:title text="Part V: prospects">Part V: prospects</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>19</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0019/</fr:uri>
                        <fr:display-uri>jms-0019</fr:display-uri>
                        <fr:route>/jms-0019/</fr:route>
                        <fr:title text="Chapter 8: a plan for PL">Chapter 8: a plan for PL</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>This dissertation has focused almost solely on the development and applications of synthetic Tait computability in the context of pure type theory, but the author originally invented synthetic Tait computability to solve problems in core programming languages, as part of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s re-analysis of the <html:em>phase distinction</html:em> in <fr:link href="/harper-mitchell-moggi-1990/" title="Higher-order modules and the phase distinction" uri="https://www.jonmsterling.com/harper-mitchell-moggi-1990/" display-uri="harper-mitchell-moggi-1990" type="local">ML-style</fr:link> <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">module systems</fr:link> between static (compiletime) and dynamic (runtime) code. The purpose of this chapter is to identify several applications of synthetic Tait computability to core programming languages, and set an agenda for future work — some of which has been executed and published following the completion of this dissertation</html:p>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2023</fr:year>
                              <fr:month>1</fr:month>
                              <fr:day>19</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-001A/</fr:uri>
                            <fr:display-uri>jms-001A</fr:display-uri>
                            <fr:route>/jms-001A/</fr:route>
                            <fr:title text="§ 8.1: two phase distinctions for program modules">§ 8.1: two phase distinctions for program modules</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>A brief overview is given of the applications of synthetic Tait computability to program modules, material that is published in the <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Journal of the ACM</fr:link>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2023</fr:year>
                              <fr:month>1</fr:month>
                              <fr:day>19</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-001B/</fr:uri>
                            <fr:display-uri>jms-001B</fr:display-uri>
                            <fr:route>/jms-001B/</fr:route>
                            <fr:title text="§ 8.2: type refinements and program extraction">§ 8.2: type refinements and program extraction</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>The modal language of synthetic Tait computability promises a new and more abstract account of <html:em>refinement types</html:em> and <html:em>program extraction</html:em> via a phase distinction between <html:em>computation</html:em> and <html:em>specification</html:em>. Refinement types are often thought of as a kind of subtype, but there is a fundamental difference: when <fr:tex display="inline"><![CDATA[{\phi }\sqsubset {A}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\psi }\sqsubset {B}]]></fr:tex> are refinements of types <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> respectively, then <fr:tex display="inline"><![CDATA[\phi \to \psi ]]></fr:tex> refines <fr:tex display="inline"><![CDATA[A\to  B]]></fr:tex>. In contrast, subtyping laws for function spaces are contravariant in the domain. The refinements available in synthetic Tait computability are moreover proof-relevant in the sense that specification-level code can contain data in addition to properties. The application to proof-relevant refinement types is employed by <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu, Sterling, Grodin, and Harper</fr:link> to develop a logical framework for simultaneously verifying behavior and complexity of functional programs.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2023</fr:year>
                              <fr:month>1</fr:month>
                              <fr:day>20</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-001C/</fr:uri>
                            <fr:display-uri>jms-001C</fr:display-uri>
                            <fr:route>/jms-001C/</fr:route>
                            <fr:title text="§ 8.3: information-flow and noninterference">§ 8.3: information-flow and noninterference</fr:title>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>Finally, an application of synthetic Tait computability to <html:em>security</html:em> and <html:em>information flow control</html:em> is identified: a security class is a phase distinction between low and high security. The preliminary results presented in this section have been substantially improved upon by <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">Sterling and Harper</fr:link>, adding support for general recursion and termination-insensitive noninterference by combining synthetic Tait computability with <fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000P/</fr:uri>
            <fr:display-uri>jms-000P</fr:display-uri>
            <fr:route>/jms-000P/</fr:route>
            <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Logical relations are the main tool for proving positive properties of logics, type theories, and programming languages: canonicity, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with non-syntactic objects that are parameretized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos’ <fr:link href="/halmos-1974/" title="Naïve set theory" uri="https://www.jonmsterling.com/halmos-1974/" display-uri="halmos-1974" type="local"><html:em>Naïve Set Theory</html:em></fr:link>, we advance a new viewpoint on logical relations based on <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local"><html:strong>synthetic Tait computability</html:strong></fr:link>, an internal language for categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000I/</fr:uri>
                <fr:display-uri>jms-000I</fr:display-uri>
                <fr:route>/jms-000I/</fr:route>
                <fr:title text="Synthesis, analysis, and the axiomatic method">Synthesis, analysis, and the axiomatic method</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The axiomatic method in mathematics is a tug of war between analysis and synthesis: analysis studies an object by modeling it with some substance that reliably behaves like the object in question, whereas synthesis takes stock of the competing models for an object and proceeds from an axiomatization of their essential properties. Analysis is important because it allows scientists to distinguish between empty fantasies and concepts that are grounded in reality by proceeding from the general to the particular; synthesis is no less important because it sharpens our view of the objects we study by summating our historical (analytical) experience in the form of axioms.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000L/</fr:uri>
                    <fr:display-uri>jms-000L</fr:display-uri>
                    <fr:route>/jms-000L/</fr:route>
                    <fr:title text="Euclid’s synthetic plane geometry">Euclid’s synthetic plane geometry</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The canonical example of the synthetic method is the ancient Greek mathematician Euclid’s plane geometry, which starts from an axiomatization of the properties of points, lines, circles, and angles as primitive notions. For instance:</html:p>
                    <html:ol><html:li>A straight line can be drawn between any two points.</html:li>
  <html:li>A line segment can be extended to a straight line.</html:li>
  <html:li>There exists a circle with any center and radius.</html:li>
  <html:li>All right angles are equal to each other.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>The postulates above are descriptive of many <html:strong>different</html:strong> “models” for the concept of a line: this can be seen by considering the <fr:link href="/jms-000J/" title="Euclid’s parallel postulate" uri="https://www.jonmsterling.com/jms-000J/" display-uri="jms-000J" type="local">parallel postulate</fr:link>, whose affirmation and negation are both consistent with the four postulates above. The revolution in modern mathematics brought on by the introduction of <html:em>analytic</html:em> (coordinate-based) methods under Descartes and Fermat should be understood as affirming the need for a plurality of models given that useful axiomatic systems can almost never uniquely determine their subject matter.</html:p>
                <html:p>Analytic methods have been utterly dominant in recent mathematics: today, almost no mathematics is done purely synthetically, i.e. without reference whatsoever to a model. The modern viewpoint however accommodates (and greatly relies upon) the summation of analytic experience in the form of axioms, e.g. the <fr:link href="/lawvere-1964-etcs/" title="An elementary theory of the category of sets" uri="https://www.jonmsterling.com/lawvere-1964-etcs/" display-uri="lawvere-1964-etcs" type="local">axioms of set theory</fr:link>, the <fr:link href="/grothendieck-1957-tohoku/" title="Sur quelques points d’algèbre homologique, I." uri="https://www.jonmsterling.com/grothendieck-1957-tohoku/" display-uri="grothendieck-1957-tohoku" type="local">axioms of abelian categories</fr:link>, or the <fr:link href="/eilenberg-steenrod-1945/" title="Axiomatic approach to homology theory" uri="https://www.jonmsterling.com/eilenberg-steenrod-1945/" display-uri="eilenberg-steenrod-1945" type="local">axioms of homology theories</fr:link>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000K/</fr:uri>
                <fr:display-uri>jms-000K</fr:display-uri>
                <fr:route>/jms-000K/</fr:route>
                <fr:title text="The relationship between internal and external language">The relationship between internal and external language</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The development of axiomatic set theory followed by the discovery of <html:em>sheaves</html:em> and <html:em>forcing</html:em> has led to a new style of synthetic mathematics that differs somewhat from <fr:link href="/jms-000L/" title="Euclid’s synthetic plane geometry" uri="https://www.jonmsterling.com/jms-000L/" display-uri="jms-000L" type="local">Euclid’s</fr:link>. In the new synthetic method, we start from a concrete domain concept (such as <html:strong>topological spaces</html:strong>, <html:strong>smooth manifolds</html:strong>, <html:strong>computational datatypes</html:strong>, <html:strong>homotopy types</html:strong>, etc.) and summon as if from the void a new kind of set theory in which instances of the original domain concept are treated <html:em>naïvely</html:em> as though they were just special sets.</html:p>
                <html:p>The advantage of this approach is that we can completely do away with the complexities of checking the well-definedness (e.g. continuity, computability, etc.) of <html:em>functions</html:em> between domain objects, because these become just ordinary functions between sets. For instance, in ordinary topology we must be careful to ensure that functions are continuous; a special case of this arises in computer science, where we must constantly check that a function between <html:em>domains</html:em> (e.g. directed-complete partial orders, <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\omega -cpos]]></fr:tex></html:span>, Scott domains, etc.) preserves the appropriate directed suprema, an essentially bureaucratic task whose derilication can nonetheless lead to serious mistakes. Likewise in the context of theory of computation, we likewise have to check that a function between datatypes is tracked by a Turing machine.</html:p>
                <html:p>In contrast, when (spaces, domains, datatypes, etc.) are viewed synthetically as if they were simply sets, any function between them will do. Obviously this sounds too good to be true, so there must be something that we have to give up in return for this simplicity; indeed, we must give up in many cases the unrestricted use of <html:em>classical logic</html:em>, in particular the law of the excluded middle and the axiom of choice. Thus the “set theory” generated by a given domain concept must be in general an <html:strong>intuitionistic</html:strong> set theory.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000M/</fr:uri>
                    <fr:display-uri>jms-000M</fr:display-uri>
                    <fr:route>/jms-000M/</fr:route>
                    <fr:title text="Well-pointedness vs. function extensionality">Well-pointedness vs. function extensionality</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>One of the consequences of passing to an intuitionistic set theory is that we must deal with distinctions that did not have significance in the classical setting, such as the <html:strong>failure of well-pointedness</html:strong>. In classical set theory, well-pointedness means that a function <fr:tex display="inline"><![CDATA[f : A \to  B]]></fr:tex> is completely determined by its behavior on global elements <fr:tex display="inline"><![CDATA[x\in  A]]></fr:tex> (i.e. functions <fr:tex display="inline"><![CDATA[x : 1\to  A]]></fr:tex>), whereas in intuitionistic set theory this need not hold (indeed, well-pointedness in this sense implies the law of the excluded middle).</html:p>
                    <html:p>In an intuitionistic setting, we must instead consider the composition of <fr:tex display="inline"><![CDATA[f : A \to  B]]></fr:tex> with <html:em>arbitrary</html:em> functions <fr:tex display="inline"><![CDATA[a : I \to  A]]></fr:tex> in order to fully characterize its behavior. (In some cases, the domains <fr:tex display="inline"><![CDATA[I]]></fr:tex> of these functions that we must probe by can be drawn from a more restricted class (or even a set) of distinguished set.) In such a setting, therefore, it is convenient to think of a function <fr:tex display="inline"><![CDATA[a : I \to  A]]></fr:tex> as a <html:strong>generalized element</html:strong> of <fr:tex display="inline"><![CDATA[A]]></fr:tex>; then we are saying that <fr:tex display="inline"><![CDATA[f : A \to  B]]></fr:tex> is determined by its behavior on not only global elements but also generalized elements.</html:p>
                    <html:p>The new significance of generalized elements in intuitionistic set theories gives rise to a distinction between two kinds of language: <html:strong>internal</html:strong> and <html:strong>external</html:strong> language. External language is just ordinary mathematics, where we are explicit about the domains of generalized elements; external language thus allows us to distinguish between a global element and a parameterized element. In contrast, internal language expresses only that which applies to arbitrary generalized elements; internal statements can always be translated mechanically to external ones by explicitly reparameterizing all variable elements as generalized elements (this is called Kripke-Joyal semantics).</html:p>
                    <html:p>For example, even though the external statement of well-pointedness may not hold, the internal one does hold because its externalization is trivial:</html:p>
                    <html:blockquote>
                      <html:p><html:strong>Internal:</html:strong> for any functions <fr:tex display="inline"><![CDATA[f,g:A\to  B]]></fr:tex>, if for all <fr:tex display="inline"><![CDATA[x:A]]></fr:tex> we have <fr:tex display="inline"><![CDATA[fx=gx]]></fr:tex>, then <fr:tex display="inline"><![CDATA[f=g]]></fr:tex>.</html:p>
                    </html:blockquote>
                    <html:blockquote>
                      <html:p><html:strong>Externalization:</html:strong> for any set <fr:tex display="inline"><![CDATA[I]]></fr:tex> and functions <fr:tex display="inline"><![CDATA[f,g:I\times  A \to  B]]></fr:tex>, if for all <fr:tex display="inline"><![CDATA[i:J\to  I]]></fr:tex> and <fr:tex display="inline"><![CDATA[a:J\to  A]]></fr:tex> we have <fr:tex display="inline"><![CDATA[f \circ  {\mathopen {}\left \langle i,a\right \rangle \mathclose {}} = g\circ {\mathopen {}\left \langle i,a\right \rangle \mathclose {}}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[f=g]]></fr:tex>.</html:p>
                    </html:blockquote>
                    <html:p>The two statements above are nothing more than the (equivalent) internal and external formulations of the <html:strong>function extensionality</html:strong> principle, which is always true in any adequate foundation for mathematics. If the internal statement is read directly as if it were external already, it would be exactly the statement of <html:strong>well-pointedness</html:strong>, which is much stronger than function extensionality.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-000N/</fr:uri>
                    <fr:display-uri>jms-000N</fr:display-uri>
                    <fr:route>/jms-000N/</fr:route>
                    <fr:title text="Category theory vs. type theory">Category theory vs. type theory</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><html:strong>Category theory</html:strong> is the language that is best equipped to express external statements and arguments, because category theory is explicit about the “domain of definition” of a given (generalized) element. In contrast, <html:strong>type theory</html:strong> is the language of internal mathematics; in type theory one works naïvely with “elements” <fr:tex display="inline"><![CDATA[x:A]]></fr:tex>, and the constraints of the language ensure that everything you do is compatible with these formal elements being realized by <html:em>generalized</html:em> elements <fr:tex display="inline"><![CDATA[x:I\to  A]]></fr:tex>.</html:p>
                    <html:p>Many aspects of synthetic mathematics are best realized in the internal / type theoretic manner, as it is natural for many objects to vary over a “domain of definition”; for instance, in computer science, a program <fr:tex display="inline"><![CDATA[\Gamma \vdash  M : A]]></fr:tex> can be thought of as a generalized element <fr:tex display="inline"><![CDATA[M:\Gamma \to  A]]></fr:tex>, but it is often useful to speak simply of “elements of type <fr:tex display="inline"><![CDATA[A]]></fr:tex>” without intending to make any assumptions about whether these “elements” are closed or not.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-000O/</fr:uri>
                <fr:display-uri>jms-000O</fr:display-uri>
                <fr:route>/jms-000O/</fr:route>
                <fr:title text="Using synthetic methods to prove analytical facts">Using synthetic methods to prove analytical facts</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Today when synthetic methods are employed, it is usually with the intention of proving something about a concrete (analytically constituted) object. For instance, <fr:link href="/kock-2006/" title="Synthetic differential geometry" uri="https://www.jonmsterling.com/kock-2006/" display-uri="kock-2006" type="local">synthetic differential geometry</fr:link> is used to prove things about actual smooth manifolds; synthetic domain theory <fr:link href="/fiore-plotkin-1997/" title="An extension of models of Axiomatic Domain Theory to models of Synthetic Domain Theory" uri="https://www.jonmsterling.com/fiore-plotkin-1997/" display-uri="fiore-plotkin-1997" type="local">can be used</fr:link> to prove things about actual <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\omega -cpos]]></fr:tex></html:span>. Likewise, <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> can be used to prove things about the actual syntax of actual programming languages!</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-000O/</fr:uri>
            <fr:display-uri>jms-000O</fr:display-uri>
            <fr:route>/jms-000O/</fr:route>
            <fr:title text="Using synthetic methods to prove analytical facts">Using synthetic methods to prove analytical facts</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Today when synthetic methods are employed, it is usually with the intention of proving something about a concrete (analytically constituted) object. For instance, <fr:link href="/kock-2006/" title="Synthetic differential geometry" uri="https://www.jonmsterling.com/kock-2006/" display-uri="kock-2006" type="local">synthetic differential geometry</fr:link> is used to prove things about actual smooth manifolds; synthetic domain theory <fr:link href="/fiore-plotkin-1997/" title="An extension of models of Axiomatic Domain Theory to models of Synthetic Domain Theory" uri="https://www.jonmsterling.com/fiore-plotkin-1997/" display-uri="fiore-plotkin-1997" type="local">can be used</fr:link> to prove things about actual <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\omega -cpos]]></fr:tex></html:span>. Likewise, <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> can be used to prove things about the actual syntax of actual programming languages!</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>11</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-logsem/</fr:uri>
            <fr:display-uri>sterling-2021-logsem</fr:display-uri>
            <fr:route>/sterling-2021-logsem/</fr:route>
            <fr:title text="Between abstraction and composition...">Between abstraction and composition...</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmibvdmy674htuxiv72zuvqwhdzjsygbcvw3zcishgnlucuoc3q35iq.pdf</fr:meta>
            <fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The fundamental contradiction of programming and program verification can be located in the tension between abstraction and composition. We make programs more abstract in order to prevent bad interactions between components; on the other side of the coin, we impede the composition of components when we abstract them. Modern programming practice evinces many distinct levels of abstraction that must be considered at the same time — for instance, compilers break module boundaries during linking, complexity analysis breaks the abstraction of extensional equivalence, and logical relations proofs break the abstraction of closure under substitution. What is needed to meet this challenge is linguistic tools that smoothly interpolate between these different levels of abstraction. Building on <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral dissertation</fr:link> and <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">joint work with Bob Harper</fr:link>, I introduce a new plan for modal programming languages and logics that treat the transition between different abstraction levels as a first-class notion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-01A1/</fr:uri>
            <fr:display-uri>jms-01A1</fr:display-uri>
            <fr:route>/jms-01A1/</fr:route>
            <fr:title text="Weeknotes 2025-W15 › Project Pterosaur: yes, I’m building a new proof assistant"><fr:link href="/2025-W15/" title="Weeknotes 2025-W15" uri="https://www.jonmsterling.com/2025-W15/" display-uri="2025-W15" type="local">Weeknotes 2025-W15</fr:link> › <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>: yes, I’m building a new proof assistant</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>I swore after building <fr:link href="https://github.com/RedPRL/cooltt" type="external">cooltt</fr:link>, <fr:link href="https://github.com/RedPRL/redtt" type="external">redtt</fr:link>, and <fr:link href="https://github.com/RedPRL/sml-redprl" type="external">RedPRL</fr:link> that I would never build another proof assistant, as the experience burned around four years of my PhD and resulted (at least directly) in very little publishable work—but, to be fair, I probably would not have made the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">key mathematical discovery</fr:link> of my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">PhD thesis</fr:link> if it were not for these engineering experiments. But I’m back on my bullshit, as the young people say, and hard at work building a new interactive proof assistant that I have code-named <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A2/</fr:uri>
                <fr:display-uri>jms-01A2</fr:display-uri>
                <fr:route>/jms-01A2/</fr:route>
                <fr:title text="Locales in dependent type theory?">Locales in dependent type theory?</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The goal of Pterosaur is to explore the adaptation of <html:em>locales</html:em> from Isabelle to dependent type theory, as a lightweight but extremely expressive alternative to type classes. My colleague <fr:link href="/lawrencepaulson/" title="Lawrence Paulson" uri="https://www.jonmsterling.com/lawrencepaulson/" display-uri="lawrencepaulson" type="local">Larry Paulson</fr:link> has written <fr:link href="https://lawrencecpaulson.github.io/tag/locales" type="external">some great blog posts about locales in Isabelle</fr:link>, and I strongly recommend reading Ballarin’s <fr:link href="https://www21.in.tum.de/~ballarin/publications/jar2019.pdf" type="external">Exploring the Structure of an Algebra Text with Locales</fr:link> to get a feel for what is possible. Here is what locales do:</html:p>
                <html:ol><html:li>Locales appear to completely solve the pain involved when building up hierarchies of mathematical structures and notations, allowing you to effortlessly combine theories along a common core (e.g. defining rings in terms of a multiplicative monoid and an Abelian group sharing the same carrier).</html:li>
      <html:li>Locales allow you to <html:em>add new methods</html:em> to a theory after the fact, and they will magically be available on anything that extended that theory. You can also add new links in the theory graph, and both cycles and diamonds are allowed so long as they are coherent; this is useful if you want to silently regard (e.g.) the space of endomaps on a set as a monoid, etc.</html:li></html:ol>
                <html:p>In comparison to modules and type classes, the strength of locales is that you don’t have to decide ahead of time whether you want to “bundle” fields with their carriers, etc. In contrast, a great deal of the difficult work of mathematical library design and maintainance in tools like Rocq, Agda, and <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link> is figuring out just what things to bundle, and fixing things when your choices inevitably lead to breakage, etc. Locales avoid these problems entirely.</html:p>
                <html:p>Finally, a reasonably usable locale implementation can be obtained <html:em>without any higher-order unification whatsoever</html:em>. I have a feeling that will be extremely important, given how unreliable (and <fr:link href="https://github.com/agda/agda/issues/5837" type="external">incorrect</fr:link>!) most implementations of higher-order unification are; the situation is so bad that it is actually an open problem to define a correct higher-order unification algorithm in the presence of singleton types (such as the unit type). I do think that this can be solved (and may have already been solved by Andras Kovacs), but my point is that the prognosis for unification in dependent type theory is bad.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A3/</fr:uri>
                <fr:display-uri>jms-01A3</fr:display-uri>
                <fr:route>/jms-01A3/</fr:route>
                <fr:title text="Experimental implementation in Lean">Experimental implementation in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The other interesting thing about Pterosaur is that I am implementing it in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link>; I am not verifying anything, and am making free use of Lean’s <html:code>partial</html:code> keyword (which hides potentially divergent code from definitional equality). Instead, I am thinking of Lean as a “better OCaml”: I can’t speak to the quality of the compiler and code generator, but I can absolutely say that from the perspective of day-to-day programming, Lean has a lot of affordances that make it extremely nice to use. On the other hand, Lean’s story for modularity is not so good; but I hope they don’t “fix” it any time soon, because I think that something like locales could be a good option for Lean itself in the future if I am able to demonstrate their potential in the context of Pterosaur’s clean-room implementation.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A4/</fr:uri>
                <fr:display-uri>jms-01A4</fr:display-uri>
                <fr:route>/jms-01A4/</fr:route>
                <fr:title text="A taste of code">A taste of code</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I will have more to say about Pterosaur in the future, but let me leave you with a bit of demo code.</html:p>
                <html:pre><![CDATA[locale Magma { A =>
  car : Type,
  car.isSet : isSet A·car,
  cmp : (x y : A·car) → A·car
}

locale Magma.Hom { f =>
  dom : Magma,
  cod : Magma,
  car : (x : f·dom·car) → f·cod·car,
  cmp : (x y : f·dom·car) → Id f·cod·car (f·car (f·dom·cmp x y)) (f·cod·cmp (f·car x) (f·car y))
}

locale Semigroup { A =>
  splice magma : Magma,
  cmp.assoc : (x y z : A·car) → Id A·car (A·cmp (A·cmp x y) z) (A·cmp x (A·cmp y z))
}

locale Semigroup.Hom {f =>
  dom : Semigroup,
  cod : Semigroup,
  splice magma.hom : Magma.Hom / {dom := f·dom·magma, cod := f·cod·magma}
}

locale Monoid { A =>
  splice semigroup : Semigroup,
  unit : A·car,
  cmp.leftUnit : (x : A·car) → Id A·car (A·cmp A·unit x) x,
  cmp.rightUnit : (x : A·car) → Id A·car (A·cmp x A·unit) x
}

locale Monoid.Hom {f =>
  dom : Monoid,
  cod : Monoid,
  splice semigroup.hom : Semigroup.Hom / {dom := f·dom·semigroup, cod := f·cod·semigroup},
  unit : Id f·cod·car (f·car f·dom·unit) f·cod·unit
}

locale Group { G =>
  splice monoid : Monoid,
  inv : (x : G·car) → G·car,
  inv.inv : (x : G·car) → Id G·car (G·inv (G·inv x)) x
}

locale AbelianGroup { A =>
  splice group : Group,
  splice commutativeOperation : CommutativeOperation / {car := A·car, cmp := A·cmp}
}]]></html:pre>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/cmu/</fr:uri>
            <fr:display-uri>cmu</fr:display-uri>
            <fr:route>/cmu/</fr:route>
            <fr:title text="Carnegie Mellon University">Carnegie Mellon University</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="external">https://www.cmu.edu/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
