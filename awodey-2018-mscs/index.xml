<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Steve Awodey</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2018</fr:year>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/awodey-2018-mscs/</fr:uri>
    <fr:display-uri>awodey-2018-mscs</fr:display-uri>
    <fr:route>/awodey-2018-mscs/</fr:route>
    <fr:title text="Natural models of homotopy type theory">Natural models of homotopy type theory</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="venue">
      <fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link>
    </fr:meta>
    <fr:meta name="doi">10.1017/S0960129516000268</fr:meta>
    <fr:meta name="bibtex"><![CDATA[@article{awodey-2018-mscs,
  author = {Awodey, Steve},
  publisher = {Cambridge University Press},
  year = {2018},
  doi = {10.1017/S0960129516000268},
  eprint = {1406.3219},
  eprintclass = {math.CT},
  eprinttype = {arXiv},
  journal = {Mathematical Structures in Computer Science},
  number = {2},
  pages = {241--286},
  title = {Natural models of homotopy type theory},
  volume = {28},
}]]></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>The notion of a <html:em>natural model</html:em> of type theory is defined in terms of that of a <html:em>representable natural transformation</html:em> of presheaves. It is shown that such models agree exactly with the concept of a <html:em>category with families</html:em> in the sense of <fr:link href="/dybjer-1996/" title="Internal type theory" uri="https://www.jonmsterling.com/dybjer-1996/" display-uri="dybjer-1996" type="local">Dybjer</fr:link>, which can be regarded as an algebraic formulation of type theory. We determine conditions for such models to satisfy the inference rules for dependent sums Σ, dependent products Π and intensional identity types Id, as used in homotopy type theory. It is then shown that a category admits such a model if it has a class of maps that behave like the abstract fibrations in axiomatic homotopy theory: They should be stable under pullback, closed under composition and relative products, and there should be weakly orthogonal factorizations into the class. It follows that many familiar settings for homotopy theory also admit natural models of the basic system of homotopy type theory.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/peterdybjer/" title="Peter Dybjer" uri="https://www.jonmsterling.com/peterdybjer/" display-uri="peterdybjer" type="local">Peter Dybjer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1996</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/dybjer-1996/</fr:uri>
            <fr:display-uri>dybjer-1996</fr:display-uri>
            <fr:route>/dybjer-1996/</fr:route>
            <fr:title text="Internal type theory">Internal type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">TYPES ’95</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@incollection{dybjer:1996,
  author = {Dybjer, Peter},
  editor = {Berardi, Stefano and Coppo, Mario},
  address = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  booktitle = {Types for Proofs and Programs: International Workshop, TYPES '95 Torino, Italy, June 5--8, 1995 Selected Papers},
  year = {1996},
  isbn = {978-3-540-70722-6},
  pages = {120--134},
  title = {Internal type theory},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>11</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00F7/</fr:uri>
            <fr:display-uri>jms-00F7</fr:display-uri>
            <fr:route>/jms-00F7/</fr:route>
            <fr:title text="Left lifting structures">Left lifting structures</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:meta name="source">
              <fr:link href="/awodey-2018-mscs/" title="Natural models of homotopy type theory" uri="https://www.jonmsterling.com/awodey-2018-mscs/" display-uri="awodey-2018-mscs" type="local">[awodey-2018-mscs]</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[{U}\xrightarrow {{l}}{V}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{r}}{B}]]></fr:tex> be two morphisms in a category <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> with pullbacks, such that <fr:tex display="inline"><![CDATA[U,V]]></fr:tex> are exponentiable. Working in the codomain bifibration of <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex>, we consider the vertical factor of the square <fr:tex display="inline"><![CDATA[{p^V}\xrightarrow {{p^f}}{p^U}]]></fr:tex> as depicted below:</html:p>
 
  
  <html:figure><fr:resource hash="11057bfdd601b5e1777ce2a6946af29f"><fr:resource-content><html:img src="/11057bfdd601b5e1777ce2a6946af29f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    height = 1.5cm,
    nw = A^V,
    sw = B^V,
    west = p^V,
    ne = A^U,
    se = B^U,
    east = p^U,
    south = B^f,
    north = A^f,
  }
  \qquad 
  \begin {tikzpicture}[diagram,baseline=(sq/sw.base)]
    \SpliceDiagramSquare <sq/>{
      ne = p^U,
      se = B^U,
      sw = A^U,
      nw = {\mathopen {}\left (f^U\right )\mathclose {}}^*p^U,
      south = f^U,
      north = h_{p^f},
      nw/style = pullback,
      west/style = lies over,
      east/style = lies over,
      north/node/style = upright desc,
      width = 2.5cm,
      height = 1.5cm,
    }
    \node [above = of sq/nw] (nw) {$p^V$};
    \draw [->] (nw) to node[sloped,above] {$p^f$} (sq/ne);
    \draw [->,exists] (nw) to node[upright desc] {$v_{p^f}$} (sq/nw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>A <html:em>(weak, strong) left lifting structure</html:em> for <fr:tex display="inline"><![CDATA[{U}\xrightarrow {{l}}{V}]]></fr:tex> against <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{r}}{B}]]></fr:tex> is then defined to be a (section, inverse) to the vertical factor <fr:tex display="inline"><![CDATA[{p^V}\xrightarrow {{v_{p^f}}}{{\mathopen {}\left (f^U\right )\mathclose {}}^*p^U}]]></fr:tex> in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/A^U}]]></fr:tex> depicted above — or equivalently a (section, inverse) to the underlying morphism in <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> of the vertical factor.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>11</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00E3/</fr:uri>
            <fr:display-uri>jms-00E3</fr:display-uri>
            <fr:route>/jms-00E3/</fr:route>
            <fr:title text="Presheaf-theoretic description of natural models">Presheaf-theoretic description of natural models</fr:title>
            <fr:taxon>Definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/fiore-2012-icalp/" title="Discrete generalised polynomial functors" uri="https://www.jonmsterling.com/fiore-2012-icalp/" display-uri="fiore-2012-icalp" type="local">[fiore-2012-icalp]</fr:link>, <fr:link href="/awodey-2018-mscs/" title="Natural models of homotopy type theory" uri="https://www.jonmsterling.com/awodey-2018-mscs/" display-uri="awodey-2018-mscs" type="local">[awodey-2018-mscs]</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <html:em>natural model</html:em> is defined to be a small category <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> with a terminal object together with a representable map <fr:tex display="inline"><![CDATA[{E}\xrightarrow {{p}}{U}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\operatorname {Pr}\mathcal {C}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/mscs/</fr:uri>
            <fr:display-uri>mscs</fr:display-uri>
            <fr:route>/mscs/</fr:route>
            <fr:title text="Mathematical Structures in Computer Science">Mathematical Structures in Computer Science</fr:title>
            <fr:taxon>Journal</fr:taxon>
            <fr:meta name="external">https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
