<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://www.jonmsterling.com/marcelofiore/</fr:uri>
    <fr:display-uri>marcelofiore</fr:display-uri>
    <fr:route>/marcelofiore/</fr:route>
    <fr:title text="Marcelo Fiore">Marcelo Fiore</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:meta name="position">Professor</fr:meta>
    <fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>, <fr:link href="/jms-00GF/" title="Christ’s College" uri="https://www.jonmsterling.com/jms-00GF/" display-uri="jms-00GF" type="local">Christ’s College</fr:link></fr:meta>
    <fr:meta name="external">https://www.cl.cam.ac.uk/~mpf23/</fr:meta>
    <fr:meta name="orcid">0000-0001-8558-3492</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:blockquote><html:strong>Interests:</html:strong> Mathematical models of computation; denotational and operational semantics of programming languages and interactive systems; type systems and program logics for functional and concurrent computation; applications of category theory to computer science.</html:blockquote>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>12</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-015R/</fr:uri>
            <fr:display-uri>jms-015R</fr:display-uri>
            <fr:route>/jms-015R/</fr:route>
            <fr:title text="Why can’t I do a summer internship with you?">Why can’t I do a summer internship with you?</fr:title>
            <fr:taxon>FAQ</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>I get many queries about doing summer research internships, e.g. from students who wish to get a head start on Part III or are just otherwise interested. A summer internship is a great idea—and I had a <fr:link href="/zhiyiliu/" title="Zhiyi Liu" uri="https://www.jonmsterling.com/zhiyiliu/" display-uri="zhiyiliu" type="local">great summer intern</fr:link> in 2024 who has gone on to do Part III with me and <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>—but I will not be offering any more internships in the foreseeable future, even though I am very happy to spend my time working with and teaching motivated students during the summer.</html:p>
            <html:p>The unfortunate reason is that the <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Department</fr:link>’s approach to official/paid summer internships creates intolerable levels of administrative work and bureaucratic hazard for <html:em>me</html:em>. Most students come to me with funding from their College, but what I found is that in order to supervise a College-funded student over the summer, I have to approve timesheets every Friday before end-of-day (which would already be intolerable). In fact, the process is even more bizarre than this:</html:p>
            <html:ol><html:li>The intern submits their timesheet to HR.</html:li>
 <html:li>Then I am supposed to write separately to HR telling them how many hours the student worked. (Note that at no point in this process have I <html:em>seen</html:em> the timesheet, so I am just guessing / hoping that the number of hours I “report” matches whatever number is needed for the student to get full-time pay.)</html:li>
 <html:li>Then, I suppose, the time worked that the student reports had better match with whatever I guessed or else <html:em>someone</html:em> is going to be caught in a lie.</html:li></html:ol>
            <html:p>What a strange and hazardous process that no scientist could have designed, given that research of any kind is not at all quantifiable by number of hours anyway… And I personally don’t have time to play the weekly hours-guessing-game with HR. To be fair, I am not certain how much of this dysfunction is caused by Departmental policy and how much is caused by College policy, or the dreaded interaction between the two.</html:p>
            <html:p>Another fun aspect of the <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Department</fr:link>’s approach to summer internships is: if the Department miscalculates the amount of funding needed to pay a summer intern (e.g. non-stipendiary costs, like taxes), after they bill the student’s College for the incorrect (but agreed upon) amount, they then come to <html:em>me</html:em> asking for money to cover the difference. Naturally, I refused and told them to find the money elsewhere to cover their own mistake, as the funding has nothing to do with me whatsoever—I am simply <html:em>volunteering</html:em> my time to teach students out of my own sense of charity, whom I have no contractual duty to teach whatsoever, so it is really baffling to be asked to pay for the privilege to do so. This experience has sadly led me to permanently recuse myself from any involvement in summer internships here, which I regret.</html:p>
            <html:p>Naturally, I will be very happy to reconsider my position if the Department should ever adopt a rational and lightweight approach to paid summer internships.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>13</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0090/</fr:uri>
            <fr:display-uri>jms-0090</fr:display-uri>
            <fr:route>/jms-0090/</fr:route>
            <fr:title text="Exponentials of the form i_!A\Rightarrow  i_!B">Exponentials of the form <fr:tex display="inline"><![CDATA[i_!A\Rightarrow  i_!B]]></fr:tex></fr:title>
            <fr:taxon>Lemma</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathscr {D}]]></fr:tex> be cartesian closed categories, and let <fr:tex display="inline"><![CDATA[\rho ^*\dashv  \rho _*:\mathscr {C}\to \mathscr {D}]]></fr:tex> be an adjunction. Define <fr:tex display="inline"><![CDATA[\mathscr {G}]]></fr:tex> to be the Artin gluing of the right adjoint <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{\rho _*}}{\mathscr {D}}]]></fr:tex>. Involving <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>, we have an adjunction <fr:tex display="inline"><![CDATA[j^*\dashv  j_*:\mathscr {C}\hookrightarrow \mathscr {G}]]></fr:tex>; involving <fr:tex display="inline"><![CDATA[\mathscr {D}]]></fr:tex>, we have an adjoint triple <fr:tex display="inline"><![CDATA[i_!\dashv  i^*\dashv  i_*:\mathscr {D}\hookrightarrow \mathscr {G}]]></fr:tex>. We have canonical isomorphism <fr:tex display="inline"><![CDATA[i^*{\mathopen {}\left ({i_!B}^{i_!A}\right )\mathclose {}}\cong  B^A]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>9</fr:month><fr:day>13</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>

  <html:p>We describe the actions of all these functors on objects below:</html:p>

  <fr:tex display="block"><![CDATA[
    \begin {aligned}
      j^*{\mathopen {}\left (D\to \rho _*C\right )\mathclose {}} &= C
      \\
      i^*{\mathopen {}\left (D\to  \rho _*C\right )\mathclose {}} &= D
    \end {aligned}
    \qquad 
    \begin {aligned}
      j_*C  &= {\mathopen {}\left ({\rho _*C}\xrightarrow {{1_{\rho _*C}}}{\rho _*C}\right )\mathclose {}}
      \\
      i_*D &= {\mathopen {}\left ({D}\xrightarrow {{!_D}}{\rho _*\mathbf {1}}\right )\mathclose {}}
      \\
      i_!D &= {\mathopen {}\left ({D}\xrightarrow {{\eta _D}}{\rho _*\rho ^*D}\right )\mathclose {}}
    \end {aligned}
  ]]></fr:tex>

  <html:p>We recall the standard computation of the glued exponential <fr:tex display="inline"><![CDATA[i_!A\Rightarrow  {i_!B}]]></fr:tex> as the pulled back family below, in which the lower left map is defined using the fact that <fr:tex display="inline"><![CDATA[\rho _*]]></fr:tex> preserves binary products:</html:p>

  
 
  
  <html:figure><fr:resource hash="7d25c586980290a48134370333e64ed1"><fr:resource-content><html:img src="/7d25c586980290a48134370333e64ed1.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
    \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
        nw/style = pullback,
        width = 5cm,
        nw = i^*{\mathopen {}\left (i_!A\Rightarrow  i_!B\right )\mathclose {}},
        ne = {i^*i_!A}\Rightarrow {i^*i_!B},
        sw = \rho _*{\mathopen {}\left ({j^*i_!A}\Rightarrow {j^*i_!B}\right )\mathclose {}},
        se = i^*i_!A\Rightarrow  {\rho _*j^*i_!B},
        east = i^*i_!A\Rightarrow  p_{i_!B},
        west = p_{i_!A\Rightarrow  i_!B},
        south = h,
        south/node/style = upright desc,
      }
      \node [between = sw and se, yshift=-1.5cm] (sc) {$\rho _*j^*i_!A\Rightarrow  \rho _*j^*i_!B$};
      \draw [->] (sc) to node[right] {\small $p_{i_!A}\Rightarrow \rho _*j^*i_!B$} (se);
      \draw [->] (sw) to node[sloped,below] {${\phi _\Rightarrow }$} (sc);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>
 


  <html:p>We may simplify the above using our explicit computations of all the adjoints, noting that <fr:tex display="inline"><![CDATA[i^*i_! = 1]]></fr:tex> and <fr:tex display="inline"><![CDATA[j^*i_! = \rho ^*]]></fr:tex>:</html:p>

  
 
  
  <html:figure><fr:resource hash="b3c3094fbb9526a0b3bb011ef1da2a4f"><fr:resource-content><html:img src="/b3c3094fbb9526a0b3bb011ef1da2a4f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
    \begin {tikzpicture}{diagram}
      \SpliceDiagramSquare {
        nw/style = pullback,
        width = 4cm,
        nw = i^*{\mathopen {}\left (i_!A\Rightarrow  i_!B\right )\mathclose {}},
        ne = A\Rightarrow  B,
        sw = \rho _*{\mathopen {}\left ({\rho ^*A}\Rightarrow {\rho ^*B}\right )\mathclose {}},
        se = A\Rightarrow {\rho _*\rho ^*B},
        east = A\Rightarrow  \eta _B,
        south = h,
        south/node/style = upright desc,
      }
      \node [between = sw and se, yshift=-1.5cm] (sc) {$\rho _*\rho ^*A\Rightarrow \rho _*\rho ^*B$};
      \draw [->] (sc) to node[right,xshift=.25cm] {\small $\eta _A\Rightarrow  \rho _*\rho ^*B$} (se);
      \draw [->] (sw) to node[sloped,below] {${\phi _\Rightarrow }$} (sc);
    \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>
 


  <html:p>It is possible to construct a likely inverse to the lower composite. In particular, we will show that the following natural isomorphism is given by postcomposition with <fr:tex display="inline"><![CDATA[h]]></fr:tex>:</html:p>

  <fr:tex display="block"><![CDATA[
    \begin {aligned}
      {\mathopen {}\left  [X,\rho _*{\mathopen {}\left (\rho ^*A\Rightarrow \rho ^*B\right )\mathclose {}}\right  ]\mathclose {}}
      &\cong 
      {\mathopen {}\left  [\rho ^*X, \rho ^*A\to \rho ^*B\right  ]\mathclose {}}
      \\
      &\cong 
      {\mathopen {}\left  [\rho ^*X\times \rho ^*A, \rho ^*B\right  ]\mathclose {}}
      \\
      &\cong 
      {\mathopen {}\left  [\rho ^*{\mathopen {}\left (X\times  A\right )\mathclose {}}, \rho ^*B\right  ]\mathclose {}}
      \\
      &\cong 
      {\mathopen {}\left  [X\times  A, \rho _*\rho ^*B\right  ]\mathclose {}}
      \\
      &\cong 
      {\mathopen {}\left  [X,A\Rightarrow  \rho _*\rho ^*B\right  ]\mathclose {}}
    \end {aligned}
  ]]></fr:tex>

  <html:p>(I didn't have time to finish writing that proof. Maybe there is a better way that doesn’t involve this awful computation? I believe that <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link> has independently proved it this afternoon.)</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-008J/</fr:uri>
            <fr:display-uri>jms-008J</fr:display-uri>
            <fr:route>/jms-008J/</fr:route>
            <fr:title text="Classifying topoi and generalised abstract syntax">Classifying topoi and generalised abstract syntax</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>For any small category <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>, <fr:link href="/fiore-2007-ct/" title="Towards a mathematical theory of substitution" uri="https://www.jonmsterling.com/fiore-2007-ct/" display-uri="fiore-2007-ct" type="local">Fiore</fr:link> <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">treats</fr:link> <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-sorted abstract syntax in the functor category <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [\mathscr {C},\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}{\mathscr {C}}\right )\mathclose {}}\right  ]\mathclose {}}]]></fr:tex> where <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is some 2-monad on <fr:tex display="inline"><![CDATA[\mathbf {Cat}]]></fr:tex>; any such functor <fr:tex display="inline"><![CDATA[P]]></fr:tex> denotes a set that is indexed in sorts and contexts (where the 2-monad <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> takes a category of sorts to the corresponding category of contexts). When <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex> is a set and <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is either finite limit or finite product completion, we recover the standard notions of many-sorted abstract syntax; in general, we get a variety of forms of <html:em>dependently sorted</html:em> or <html:em>generalised</html:em> abstract syntax.</html:p>
            <html:p>We will assume here that <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is the free finite limit completion 2-monad; our goal is to study <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">Fiore</fr:link>’s general <html:em>substitution monoidal structure</html:em> from the point of view of classifying topoi, building on <fr:link href="/peterjohnstone/" title="Peter T. Johnstone" uri="https://www.jonmsterling.com/peterjohnstone/" display-uri="peterjohnstone" type="local">Johnstone</fr:link>’s analogous observations (<fr:link href="/johnstone-2002/" title="Sketches of an elephant: a topos theory compendium" uri="https://www.jonmsterling.com/johnstone-2002/" display-uri="johnstone-2002" type="local">Elephant, D3.2</fr:link>) on the non-symmetric monoidal structure of the <html:em>object classifier</html:em>. The topos theoretic viewpoint that we will explore is nothing more than a rephrasing of <fr:link href="/fiore-2007-ct/" title="Towards a mathematical theory of substitution" uri="https://www.jonmsterling.com/fiore-2007-ct/" display-uri="fiore-2007-ct" type="local">Fiore</fr:link>’s account in terms of the Kleisli composition in a 2-monad; nonetheless the perspective of classifying topoi is enlightening, as it provides an explanation for <html:em>precisely</html:em> what internal geometrical structure one expects in a given topos for abstract syntax, potentially leading to improved internal languages.</html:p>
            <html:p>For any small category <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>, the category of presheaves <fr:tex display="inline"><![CDATA[\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}\mathscr {C}\right )\mathclose {}}]]></fr:tex> corresponds to the <html:em>classifying topos</html:em> of diagrams of shape <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>. Following <fr:link href="/anel-joyal-2021/" title="Topo-logie" uri="https://www.jonmsterling.com/anel-joyal-2021/" display-uri="anel-joyal-2021" type="local">Anel and Joyal</fr:link>, we shall write <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> for this “affine” classifying topos; under the conventions of <html:em>op. cit.</html:em>, we may then identify the category of sheaves <fr:tex display="inline"><![CDATA[\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> with the presheaf category <fr:tex display="inline"><![CDATA[\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}{\mathscr {C}}\right )\mathclose {}}]]></fr:tex>.</html:p>
            <html:p>The universal property of <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> as the classifying topos of <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-diagrams means that for any topos <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>, a diagram <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P}}{\operatorname {Sh}{\mathcal {X}}}]]></fr:tex> corresponds essentially uniquely (by left Kan extension) to a morphism of topoi <fr:tex display="inline"><![CDATA[{\mathcal {X}}\xrightarrow {{\bar {P}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>. We have a <html:em>generic <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-shaped diagram</html:em> <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{\mathrm {G}_{\mathscr {C}}}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex> corresponding under this identification to the identity map on <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex>. More explicitly, the diagram <fr:tex display="inline"><![CDATA[\mathrm {G}_{\mathscr {C}}]]></fr:tex> is the following composite:</html:p>
            <fr:tex display="block"><![CDATA[
  \mathrm {G}_{\mathscr {C}} :\equiv  \mathscr {C}\xrightarrow {\eta _\mathscr {C}} \operatorname {\mathbb {L}}\mathscr {C}\xrightarrow {よ_{\mathscr {C}}} \operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}\mathscr {C}\right )\mathclose {}} = \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
]]></fr:tex>
            <html:p>Given a morphism of topoi <fr:tex display="inline"><![CDATA[{\mathcal {X}}\xrightarrow {{f}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>, we may recover the diagram <fr:tex display="inline"><![CDATA[\mathscr {C}\to {\operatorname {Sh}{\mathcal {X}}}]]></fr:tex> that it classifies as the composite <fr:tex display="inline"><![CDATA[\mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}\xrightarrow {f^{*}}\operatorname {Sh}{\mathcal {X}}]]></fr:tex>.</html:p>
            <html:p>In case <fr:tex display="inline"><![CDATA[\mathcal {X}\equiv \mathbb {A}^{\mathscr {C}}]]></fr:tex>, then, we have a correspondence between <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-shaped diagrams of sheaves on <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> and endomorphisms of <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex>; <html:mark>we are interested in representing the compositions of such endomorphisms as a <html:em>tensor product</html:em> on the functor category <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [\mathscr {C},\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}\right  ]\mathclose {}}]]></fr:tex></html:mark>.</html:p>
            <html:p>In particular, let <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P,Q}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex> be two diagrams; taking characteristic maps, we have endomorphisms of affine topoi <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{\bar {P},\bar {Q}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>, which we may compose to obtain <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{\bar {Q}\circ \bar {P}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>; then, we will define the tensor <fr:tex display="inline"><![CDATA[P\bullet  Q]]></fr:tex> to be the diagram whose characteristic morphism of affine topoi is <fr:tex display="inline"><![CDATA[\bar {P}\circ \bar {Q}]]></fr:tex>. In other words:</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    P\bullet  Q
    &:\equiv 
    \mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {{\mathopen {}\left (\bar {P}\circ \bar {Q}\right )\mathclose {}}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \\
    &=
    \mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {\bar {P}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {\bar {Q}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
  \end {aligned}
]]></fr:tex>
            <html:p>To give an explicit computation of the tensor product, we first compute the inverse image of any <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{f}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> on representables <fr:tex display="inline"><![CDATA[よ_{\mathscr {C}}\Gamma ]]></fr:tex> for <fr:tex display="inline"><![CDATA[\Gamma \in \operatorname {\mathbb {L}}\mathscr {C}]]></fr:tex>. As any left exact functor <fr:tex display="inline"><![CDATA[{\operatorname {\mathbb {L}}\mathscr {C}}\xrightarrow {{H}}{\mathscr {E}}]]></fr:tex> is the right Kan extension of <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{H\circ \eta _\mathscr {C}}}{\mathscr {E}}]]></fr:tex> along <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{\eta _\mathscr {C}}}{\operatorname {\mathbb {L}}\mathscr {C}}]]></fr:tex>, we can conclude that <fr:tex display="inline"><![CDATA[H\Gamma  \cong  \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}H{\mathopen {}\left (\eta _\mathscr {C}{d}\right )\mathclose {}}]]></fr:tex>. We will use this in our calculation below, setting <fr:tex display="inline"><![CDATA[H:\equiv  f^{*}\circ よ_{\mathscr {C}}]]></fr:tex>.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    f^{*}{よ_{\mathscr {C}}\Gamma }
    &\cong 
    \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}
    f^{*}{
      よ_{\mathscr {C}}{\eta _\mathscr {C}{d}}
    }
    \\
    &\cong 
    \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}
    f^{*}{\mathrm {G}_{\mathscr {C}}{d}}
  \end {aligned}
]]></fr:tex>
            <html:p>We are now prepared to compute the tensor product of any <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P,Q}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex>.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}c
    &=
    \bar {Q}^{*}
    \bar {P}^{*}
    \mathrm {G}_{\mathscr {C}}{c}
    \\
    &\cong 
    \bar {Q}^{*}
    {\mathopen {}\left (Pc\right )\mathclose {}}
    \\
    &\cong 
    \bar {Q}^{*}
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    よ_{\mathscr {C}}\Delta 
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \bar {Q}^{*}よ_{\mathscr {C}}\Delta 
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    \bar {Q}^{*}\mathrm {G}_{\mathscr {C}}d
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    Qd
  \end {aligned}
]]></fr:tex>
            <html:p>Finally, we can relate the computation above to that of <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">Fiore</fr:link> in terms of coends.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}\,c
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    {\mathopen {}\left  [よ_{\mathscr {C}}\Delta ,Pc\right  ]\mathclose {}}
    \cdot 
    \operatorname {lim}_{\Delta \to \eta _\mathscr {C}{d}} Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \cdot 
    \operatorname {lim}_{\Delta \to \eta _\mathscr {C}{d}} Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \cdot 
    \int _{c\in \mathscr {C}}
    {\mathopen {}\left  [\Delta ,\eta _\mathscr {C}{d}\right  ]\mathclose {}}\pitchfork  Qd
  \end {aligned}
]]></fr:tex>
            <html:p>Above, we have written <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\cdot \right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\pitchfork \right )\mathclose {}}]]></fr:tex> for the tensoring and cotensoring of <fr:tex display="inline"><![CDATA[\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> respectively. Thus, the fully pointwise computation is as follows:</html:p>
            <fr:tex display="block"><![CDATA[
  {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}\,c\,\Gamma  \cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \times 
    \int _{c\in \mathscr {C}}
    {\mathopen {}\left  [\Delta ,\eta _\mathscr {C}{d}\right  ]\mathclose {}}\Rightarrow  Q\,d\,\Gamma 
]]></fr:tex>
            <html:p>
              <html:em>Thanks to <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link> and <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> for helpful discussions.</html:em>
            </html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00K0/</fr:uri>
            <fr:display-uri>jms-00K0</fr:display-uri>
            <fr:route>/jms-00K0/</fr:route>
            <fr:title text="Lectures on discrete mathematics › Authorship statement"><fr:link href="/jms-00JB/" title="Lectures on discrete mathematics" uri="https://www.jonmsterling.com/jms-00JB/" display-uri="jms-00JB" type="local">Lectures on discrete mathematics</fr:link> › Authorship statement</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> using <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>’s lectures as source material. Any mistakes were introduced by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>11</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00DV/</fr:uri>
            <fr:display-uri>jms-00DV</fr:display-uri>
            <fr:route>/jms-00DV/</fr:route>
            <fr:title text="Students › Masters-level students"><fr:link href="/jms-0063/" title="Students" uri="https://www.jonmsterling.com/jms-0063/" display-uri="jms-0063" type="local">Students</fr:link> › Masters-level students</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:ul><html:li><fr:link href="/zhiyiliu/" title="Zhiyi Liu" uri="https://www.jonmsterling.com/zhiyiliu/" display-uri="zhiyiliu" type="local">Zhiyi Liu</fr:link>: 2024–2025. <html:em>A Type Theory with Abstract Variables for Syntax with Variable Binding.</html:em> Jointly supervised with <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>.</html:li>
 <html:li><fr:link href="/runzexue/" title="Runze Xue" uri="https://www.jonmsterling.com/runzexue/" display-uri="runzexue" type="local">Runze Xue</fr:link>: 2024–2025. <html:em>Mechanising Synthetic Domain Theory.</html:em></html:li>
 <html:li><fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>: 2023–2024. <html:em>Investigating Higher Domain Theory.</html:em></html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/camcl/</fr:uri>
            <fr:display-uri>camcl</fr:display-uri>
            <fr:route>/camcl/</fr:route>
            <fr:title text="Cambridge Computer Laboratory">Cambridge Computer Laboratory</fr:title>
            <fr:taxon>Department</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/ucam/" title="University of Cambridge" uri="https://www.jonmsterling.com/ucam/" display-uri="ucam" type="local">University of Cambridge</fr:link>
            </fr:meta>
            <fr:meta name="external">https://www.cst.cam.ac.uk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jms-00GF/</fr:uri>
            <fr:display-uri>jms-00GF</fr:display-uri>
            <fr:route>/jms-00GF/</fr:route>
            <fr:title text="Christ’s College">Christ’s College</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="external">https://www.christs.cam.ac.uk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/gordonplotkin/" title="Gordon D. Plotkin" uri="https://www.jonmsterling.com/gordonplotkin/" display-uri="gordonplotkin" type="local">Gordon D. Plotkin</fr:link>
              </fr:author>
              <fr:author>John Power</fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-plotkin-power-1997/</fr:uri>
            <fr:display-uri>fiore-plotkin-power-1997</fr:display-uri>
            <fr:route>/fiore-plotkin-power-1997/</fr:route>
            <fr:title text="Complete cuboidal sets in axiomatic domain theory">Complete cuboidal sets in axiomatic domain theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1109/LICS.1997.614954</fr:meta>
            <fr:meta name="venue">LICS 1997</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{fiore-plotkin-power-1997,
  author = {Fiore, Marcelo P. and Plotkin, Gordon D. and Power, John},
  address = {Los Alamitos, CA, USA},
  publisher = {IEEE Computer Society},
  booktitle = {Symposium on Logic in Computer Science},
  year = {1997},
  month = jul,
  doi = {10.1109/LICS.1997.614954},
  issn = {1043-6871},
  pages = {268},
  title = {Complete Cuboidal Sets in Axiomatic Domain Theory},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/vikramanchoudhury/" title="Vikraman Choudhury" uri="https://www.jonmsterling.com/vikramanchoudhury/" display-uri="vikramanchoudhury" type="local">Vikraman Choudhury</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>10</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/choudury-fiore-2021/</fr:uri>
            <fr:display-uri>choudury-fiore-2021</fr:display-uri>
            <fr:route>/choudury-fiore-2021/</fr:route>
            <fr:title text="Free commutative monoids in homotopy type theory">Free commutative monoids in homotopy type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{choudhury-fiore-2021,
  author = {Choudhury, Vikraman and Fiore, Marcelo},
  url = {https://entics.episciences.org/10492},
  year = {2023},
  month = feb,
  doi = {10.46298/entics.10492},
  journal = {{Electronic Notes in Theoretical Informatics and Computer Science}},
  title = {{Free Commutative Monoids in Homotopy Type Theory}},
  volume = {{Volume 1 - Proceedings of MFPS XXXVIII}},
}]]></fr:meta>
            <fr:meta name="venue">Proceedings of MFPS XXXVIII</fr:meta>
            <fr:meta name="doi">10.46298/entics.10492</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/nicolagambino/" title="Nicola Gambino" uri="https://www.jonmsterling.com/nicolagambino/" display-uri="nicolagambino" type="local">Nicola Gambino</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/martinhyland/" title="Martin Hyland" uri="https://www.jonmsterling.com/martinhyland/" display-uri="martinhyland" type="local">Martin Hyland</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/glynnwinskel/" title="Glynn Winskel" uri="https://www.jonmsterling.com/glynnwinskel/" display-uri="glynnwinskel" type="local">Glynn Winskel</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2018</fr:year>
              <fr:month>7</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-gambino-hyland-winskel-2018/</fr:uri>
            <fr:display-uri>fiore-gambino-hyland-winskel-2018</fr:display-uri>
            <fr:route>/fiore-gambino-hyland-winskel-2018/</fr:route>
            <fr:title text="Relative pseudomonads, Kleisli bicategories, and substitution monoidal structures">Relative pseudomonads, Kleisli bicategories, and substitution monoidal structures</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/s00029-017-0361-3</fr:meta>
            <fr:meta name="venue">Selecta Mathematica</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{fiore-gambino-hyland-winskel-2018,
  author = {Fiore, M. and Gambino, N. and Hyland, M. and Winskel, G.},
  doi = {10.1007/s00029-017-0361-3},
  isbn = {1420-9020},
  journal = {Selecta Mathematica},
  number = {3},
  pages = {2791--2830},
  title = {Relative pseudomonads, Kleisli bicategories, and substitution monoidal structures},
  volume = {24},
  year = {2018},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We introduce the notion of a relative pseudomonad, which generalizes the notion of a pseudomonad, and define the Kleisli bicategory associated to a relative pseudomonad. We then present an efficient method to define pseudomonads on the Kleisli bicategory of a relative pseudomonad. The results are applied to define several pseudomonads on the bicategory of profunctors in an homogeneous way and provide a uniform approach to the definition of bicategories that are of interest in operad theory, mathematical logic, and theoretical computer science.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/pierrelouiscurien/" title="Pierre-Louis Curien" uri="https://www.jonmsterling.com/pierrelouiscurien/" display-uri="pierrelouiscurien" type="local">Pierre-Louis Curien</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/guillaumemunch/" title="Guillaume Munch-Maccagnoni" uri="https://www.jonmsterling.com/guillaumemunch/" display-uri="guillaumemunch" type="local">Guillaume Munch-Maccagnoni</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2016</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/curien-fiore-munch-2016/</fr:uri>
            <fr:display-uri>curien-fiore-munch-2016</fr:display-uri>
            <fr:route>/curien-fiore-munch-2016/</fr:route>
            <fr:title text="A theory of effects and resources: adjunction models and polarised calculi">A theory of effects and resources: adjunction models and polarised calculi</fr:title>
            <fr:taxon>Reference</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We consider the Curry-Howard-Lambek correspondence for effectful computation and resource management, specifically proposing polarised calculi together with presheaf-enriched adjunction models as the starting point for a comprehensive semantic theory relating logical systems, typed calculi, and categorical models in this context. Our thesis is that the combination of effects and resources should be considered orthogonally. Model theoretically, this leads to an understanding of our categorical models from two complementary perspectives: (i) as a linearisation of CBPV (Call-by-Push-Value) adjunction models, and (ii) as an extension of linear/non-linear adjunction models with an adjoint resolution of computational effects. When the linear structure is cartesian and the resource structure is trivial we recover Levy's notion of CBPV adjunction model, while when the effect structure is trivial we have Benton's linear/non-linear adjunction models. Further instances of our model theory include the dialogue categories with a resource modality of Melliès and Tabareau, and the [E]EC ([Enriched] Effect Calculus) models of Egger, Møgelberg and Simpson. Our development substantiates the approach by providing a lifting theorem of linear models into cartesian ones. To each of our categorical models we systematically associate a typed term calculus, each of which corresponds to a variant of the sequent calculi LJ (Intuitionistic Logic) or ILL (Intuitionistic Linear Logic). The adjoint resolution of effects corresponds to po-larisation whereby, syntactically, types locally determine a strict or lazy evaluation order and, semantically, the associativity of cuts is relaxed. In particular, our results show that polarisation provides a computational interpretation of CBPV in direct style. Further, we characterise depolarised models: those where the cut is associative, and where the evaluation order is unimportant. We explain possible advantages of this style of calculi for the operational semantics of effects.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2008</fr:year>
              <fr:month>7</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-2008/</fr:uri>
            <fr:display-uri>fiore-2008</fr:display-uri>
            <fr:route>/fiore-2008/</fr:route>
            <fr:title text="Second-order and dependently-sorted abstract syntax">Second-order and dependently-sorted abstract syntax</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1109/LICS.2008.38</fr:meta>
            <fr:meta name="venue">23rd Annual IEEE Symposium on Logic in Computer Science</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{fiore-2008,
  author={Fiore, Marcelo},
  booktitle={2008 23rd Annual IEEE Symposium on Logic in Computer Science},
  title={Second-Order and Dependently-Sorted Abstract Syntax},
  year={2008},
  pages={57-68},
  doi={10.1109/LICS.2008.38}
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The paper develops a mathematical theory in the spirit of categorical algebra that provides a model theory for second-order and dependently-sorted syntax. The theory embodies notions such as alpha-equivalence, variable binding, capture-avoiding simultaneous substitution, term metavariable, meta-substitution, mono and multi sorting, and sort dependency. As a matter of illustration, a model is used to extract a second-order syntactic theory, which is thus guaranteed to be correct by construction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/gianlucacattani/" title="Gian Luca Cattani" uri="https://www.jonmsterling.com/gianlucacattani/" display-uri="gianlucacattani" type="local">Gian Luca Cattani</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2007</fr:year>
              <fr:month>4</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/cattani-fiore-2007/</fr:uri>
            <fr:display-uri>cattani-fiore-2007</fr:display-uri>
            <fr:route>/cattani-fiore-2007/</fr:route>
            <fr:title text="The bicategory-theoretic solution of recursive domain equations">The bicategory-theoretic solution of recursive domain equations</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1016/j.entcs.2007.02.008</fr:meta>
            <fr:meta name="venue">Electronic Notes in Theoretical Computer Science</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{cattani-fiore-2007,
  author = {Cattani, Gian Luca and Fiore, Marcelo P.},
  date = {2007},
  doi = {10.1016/j.entcs.2007.02.008},
  issn = {1571-0661},
  journaltitle = entcs,
  note = {Computation, Meaning, and Logic: Articles dedicated to Gordon Plotkin},
  pages = {203--222},
  title = {The Bicategory-Theoretic Solution of Recursive Domain Equations},
  volume = {172},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2002</fr:year>
              <fr:month>10</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-2002/</fr:uri>
            <fr:display-uri>fiore-2002</fr:display-uri>
            <fr:route>/fiore-2002/</fr:route>
            <fr:title text="Semantic analysis of normalisation by evaluation for typed lambda calculus">Semantic analysis of normalisation by evaluation for typed lambda calculus</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1145/571157.571161</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This paper studies normalisation by evaluation for typed lambda calculus from a categorical and algebraic viewpoint. The first part of the paper analyses the lambda definability result of Jung and Tiuryn via Kripke logical relations and shows how it can be adapted to unify definability and normalisation, yielding an extensional normalisation result. In the second part of the paper the analysis is refined further by considering intensional Kripke relations (in the form of glueing) and shown to provide a function for normalising terms, casting normalisation by evaluation in the context of categorical glueing. The technical development includes an algebraic treatment of the syntax and semantics of the typed lambda calculus that allows the definition of the normalisation function to be given within a simply typed meta-theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/alexsimpson/" title="Alex Simpson" uri="https://www.jonmsterling.com/alexsimpson/" display-uri="alexsimpson" type="local">Alex Simpson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1999</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-simpson-1999/</fr:uri>
            <fr:display-uri>fiore-simpson-1999</fr:display-uri>
            <fr:route>/fiore-simpson-1999/</fr:route>
            <fr:title text="Lambda definability with sums via Grothendieck logical relations">Lambda definability with sums via Grothendieck logical relations</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/3-540-48959-2_12</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We introduce a notion of <html:em>Grothendieck logical relation</html:em> and use it to characterise the definability of morphisms in stable bicartesian closed categories by terms of the simply-typed lambda calculus with finite products and finite sums. Our techniques are based on concepts from topos theory, however our exposition is elementary.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/pinorosolini/" title="Guiseppe Rosolini" uri="https://www.jonmsterling.com/pinorosolini/" display-uri="pinorosolini" type="local">Guiseppe Rosolini</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1997</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-rosolini-1997-mfps/</fr:uri>
            <fr:display-uri>fiore-rosolini-1997-mfps</fr:display-uri>
            <fr:route>/fiore-rosolini-1997-mfps/</fr:route>
            <fr:title text="The category of cpos from a synthetic viewpoint">The category of cpos from a synthetic viewpoint</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><html:em>MFPS ’97</html:em>: Thirteenth Annual Conference on Mathematical Foundations of Progamming Semantics</fr:meta>
            <fr:meta name="doi">10.1016/S1571-0661(05)80165-3</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{fiore-rosolini-1997-mfps,
  author = {Fiore, Marcelo P. and Rosolini, Giuseppe},
  editor = {Brookes, Stephen D. and Mislove, Michael W.},
  publisher = {Elsevier},
  booktitle = {Thirteenth Annual Conference on Mathematical Foundations of Progamming Semantics, {MFPS} 1997, Carnegie Mellon University, Pittsburgh, PA, USA, March 23-26, 1997},
  year = {1997},
  doi = {10.1016/S1571-0661(05)80165-3},
  pages = {133--150},
  series = {Electronic Notes on Theoretical Computer Sciecnce},
  title = {The category of cpos from a synthetic viewpoint},
  volume = {6},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/gordonplotkin/" title="Gordon D. Plotkin" uri="https://www.jonmsterling.com/gordonplotkin/" display-uri="gordonplotkin" type="local">Gordon D. Plotkin</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1996</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-plotkin-1997/</fr:uri>
            <fr:display-uri>fiore-plotkin-1997</fr:display-uri>
            <fr:route>/fiore-plotkin-1997/</fr:route>
            <fr:title text="An extension of models of Axiomatic Domain Theory to models of Synthetic Domain Theory">An extension of models of Axiomatic Domain Theory to models of Synthetic Domain Theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/3-540-63172-0_36</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We relate certain models of Axiomatic Domain Theory (ADT) and Synthetic Domain Theory (SDT). On the one hand, we introduce a class of non-elementary models of SDT and show that the domains in them yield models of ADT. On the other hand, for each model of ADT in a wide class we construct a model of SDT such that the domains in it provide a model of ADT which conservatively extends the original model.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1995</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-1995/</fr:uri>
            <fr:display-uri>fiore-1995</fr:display-uri>
            <fr:route>/fiore-1995/</fr:route>
            <fr:title text="Lifting as a KZ-doctrine">Lifting as a KZ-doctrine</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/3-540-60164-3_24</fr:meta>
            <fr:meta name="external">https://link.springer.com/content/pdf/10.1007/3-540-60164-3_24.pdf</fr:meta>
            <fr:meta name="venue"><html:em>CTCS ’95</html:em>: Category Theory and Computer Science</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{fiore-1995,
  author = {Fiore, Marcelo P.},
  editor = {Pitt, David and Rydeheard, David E. and Johnstone, Peter},
  address = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  booktitle = {Category Theory and Computer Science},
  year = {1995},
  isbn = {978-3-540-44661-3},
  pages = {146--158},
  title = {Lifting as a {KZ}-doctrine},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1994</fr:year>
              <fr:month>11</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/fiore-1994/</fr:uri>
            <fr:display-uri>fiore-1994</fr:display-uri>
            <fr:route>/fiore-1994/</fr:route>
            <fr:title text="Axiomatic domain theory in categories of partial maps">Axiomatic domain theory in categories of partial maps</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">University of Edinburgh</fr:meta>
            <fr:meta name="external">https://era.ed.ac.uk/handle/1842/406</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@phdthesis{fiore-1994,
  author = {Fiore, Marcelo P.},
  school = {University of Edinburgh},
  url = {https://era.ed.ac.uk/handle/1842/406},
  year = {1994},
  month = nov,
  title = {Axiomatic Domain Theory in Categories of Partial Maps},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This thesis is an investigation into axiomatic categorical domain theory as needed for the denotational semantics of deterministic programming languages. To provide a direct semantic treatment of non-terminating computations, we make partiality the core of our theory. Thus, we focus on categories of partial maps. We study representability of partial maps and show its equivalence with classifiability. We observe that, once partiality is taken as primitive, a notion of approximation may be derived. In fact, two notions of approximation, contextual approximation and specialisation, based on testing and observing partial maps are considered and shown to coincide. Further we characterise when the approximation relation between partial maps is domain-theoretic in the (technical) sense that the category of partial maps Cpo-enriches with respect to it. Concerning the semantics of type constructors in categories of partial maps, we present a characterisation of colimits of diagrams of total maps; study order-enriched partial cartesian closure; and provide conditions to guarantee the existence of the limits needed to solve recursive type equations. Concerning the semantics of recursive types, we motivate the study of enriched algebraic compactness and make it the central concept when interpreting recursive types. We establish the fundamental property of algebraically compact categories, namely that recursive types on them admit canonical interpretations, and show that in algebraically compact categories recursive types reduce to inductive types. Special attention is paid to Cpo-algebraic compactness, leading to the identification of a 2-category of kinds with very strong closure properties. As an application of the theory developed, enriched categorical models of the metalanguage FPC (a type theory with sums, products, exponentials and recursive types) are defined and two abstract examples of models, including domain-theoretic models, are axiomatised. Further, FPC is considered as a programming language with a call-by-value operational semantics and a denotational semantics defined on top of a categorical model. Operational and denotational semantics are related via a computational soundness result. The interpretation of FPC expressions in domain-theoretic Poset-models is observed to be representation-independent. And, to culminate, a computational adequacy result for an axiomatisation of absolute non-trivial domain-theoretic models is proved.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/fiore-2012-icalp/</fr:uri>
            <fr:display-uri>fiore-2012-icalp</fr:display-uri>
            <fr:route>/fiore-2012-icalp/</fr:route>
            <fr:title text="Discrete generalised polynomial functors">Discrete generalised polynomial functors</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">https://www.cl.cam.ac.uk/~mpf23/talks/ICALP2012.pdf</fr:meta>
            <fr:meta name="venue">ICALP 2012</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@misc{fiore-2012-icalp,
  author = {Fiore, Marcelo P.},
  url = {https://www.cl.cam.ac.uk/~mpf23/talks/ICALP2012.pdf},
  year = {2012},
  note = {Slides from talk given at ICALP 2012},
  title = {Discrete generalised polynomial functors},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
              <fr:author>Dmitrij Szamozvancev</fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/fiore-szamozvancev-2022/</fr:uri>
            <fr:display-uri>fiore-szamozvancev-2022</fr:display-uri>
            <fr:route>/fiore-szamozvancev-2022/</fr:route>
            <fr:title text="Formal metatheory of second-order abstract syntax">Formal metatheory of second-order abstract syntax</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">POPL 2022</fr:meta>
            <fr:meta name="doi">10.1145/3498715</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{fiore-szamozvancev-2022,
  author = {Fiore, Marcelo and Szamozvancev, Dmitrij},
  title = {Formal Metatheory of Second-Order Abstract Syntax},
  year = {2022},
  issue_date = {January 2022},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {6},
  number = {POPL},
  doi = {10.1145/3498715},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {53},
  numpages = {29},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Despite extensive research both on the theoretical and practical fronts, formalising, reasoning about, and implementing languages with variable binding is still a daunting endeavour - repetitive boilerplate and the overly complicated metatheory of capture-avoiding substitution often get in the way of progressing on to the actually interesting properties of a language. Existing developments offer some relief, however at the expense of inconvenient and error-prone term encodings and lack of formal foundations.</html:p>
            <html:p>We present a mathematically-inspired language-formalisation framework implemented in Agda. The system translates the description of a syntax signature with variable-binding operators into an intrinsically-encoded, inductive data type equipped with syntactic operations such as weakening and substitution, along with their correctness properties. The generated metatheory further incorporates metavariables and their associated operation of metasubstitution, which enables second-order equational/rewriting reasoning. The underlying mathematical foundation of the framework - initial algebra semantics - derives compositional interpretations of languages into their models satisfying the semantic substitution lemma by construction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/fiore-2007-ct/</fr:uri>
            <fr:display-uri>fiore-2007-ct</fr:display-uri>
            <fr:route>/fiore-2007-ct/</fr:route>
            <fr:title text="Towards a mathematical theory of substitution">Towards a mathematical theory of substitution</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Category Theory 2007</fr:meta>
            <fr:meta name="external">https://www.cl.cam.ac.uk/~mpf23/talks/CT2007.pdf</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@misc{fiore-2007-ct,
  title = {Towards a Mathematical Theory of Substitution},
  author = {Marcelo, Fiore P.},
  year = {2007},
  note = {Invited talk for the Annual International Conference on Category Theory, Carvoeiro, Algarve (Portugal)},
  url = {https://www.cl.cam.ac.uk/~mpf23/talks/CT2007.pdf}
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>
