<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>10</fr:month>
      <fr:day>12</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-00AH/</fr:uri>
    <fr:display-uri>jms-00AH</fr:display-uri>
    <fr:route>/jms-00AH/</fr:route>
    <fr:title text="TypeSynth project bibliography"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project bibliography</fr:title>
    <fr:taxon>Bibliography</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
  
  

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Accepted papers">Accepted papers</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Refereed papers">Refereed papers</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>13</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri><fr:display-uri>sterling-2025-grothendieck</fr:display-uri><fr:route>/sterling-2025-grothendieck/</fr:route><fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta><fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta><fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p><html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>7</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route><fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta><fr:meta name="venue"><fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link></fr:meta><fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link></fr:author><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri><fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri><fr:route>/grodin-niu-sterling-harper-2024/</fr:route><fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632852</fr:meta><fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta><fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p><html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri><fr:display-uri>jms-012Q</fr:display-uri><fr:route>/jms-012Q/</fr:route><fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/filipsieczkowski/" title="Filip Sieczkowski" uri="https://www.jonmsterling.com/filipsieczkowski/" display-uri="filipsieczkowski" type="local">Filip Sieczkowski</fr:link></fr:author><fr:author><fr:link href="/sergeistepanenko/" title="Sergei Stepanenko" uri="https://www.jonmsterling.com/sergeistepanenko/" display-uri="sergeistepanenko" type="local">Sergei Stepanenko</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:uri><fr:display-uri>sieczkowski-stepanenko-sterling-birkedal-2024</fr:display-uri><fr:route>/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:route><fr:title text="The essence of generalized algebraic data types">The essence of generalized algebraic data types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632866</fr:meta><fr:meta name="bibtex"><![CDATA[@article{sieczkowski-stepanenko-sterling-birkedal-2024,
  author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
  title = {The Essence of Generalized Algebraic Data Types},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632866},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {24},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>This paper considers direct encodings of generalized algebraic data types (GADTs) in a minimal suitable lambda-calculus. To this end, we develop an extension of System F<html:sub>ω</html:sub> with recursive types and internalized type equalities with injective constant type constructors. We show how GADTs and associated pattern-matching constructs can be directly expressed in the calculus, thus showing that it may be treated as a highly idealized modern functional programming language. We prove that the internalized type equalities in conjunction with injectivity rules increase the expressive power of the calculus by establishing a non-macro-expressibility result in F<html:sub>ω</html:sub>, and prove the system type-sound via a syntactic argument. Finally, we build two relational models of our calculus: a simple, unary model that illustrates a novel, two-stage interpretation technique, necessary to account for the equational constraints; and a more sophisticated, binary model that relaxes the construction to allow, for the first time, formal reasoning about data-abstraction in a calculus equipped with GADTs.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri><fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri><fr:route>/aagaard-sterling-birkedal-2023/</fr:route><fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.46298/entics.12232</fr:meta><fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-generic/</fr:uri><fr:display-uri>sterling-2023-generic</fr:display-uri><fr:route>/sterling-2023-generic/</fr:route><fr:title text="What should a generic object be?">What should a generic object be?</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2023-generic,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2023},
  doi = {10.1017/S0960129523000117},
  journaltitle = {Mathematical Structures in Computer Science},
  pages = {1--22},
  title = {What should a generic object be?},
}]]></fr:meta><fr:meta name="doi">10.1017/S0960129523000117</fr:meta><fr:meta name="venue"><fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> has proposed definitions for (weak, strong, split) generic objects for a fibered category; building on his definition of (split) generic objects, <fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> develops a menagerie of important fibrational structures with applications to categorical logic and computer science, including higher order fibrations, polymorphic fibrations, 𝜆2-fibrations, triposes, and others. We observe that a split generic object need not in particular be a generic object under the given definitions, and that the definitions of polymorphic fibrations, triposes, etc. are strict enough to rule out some fundamental examples: for instance, the fibered preorder induced by a partial combinatory algebra in realizability is not a tripos in this sense. We propose a new alignment of terminology that emphasizes the forms of generic object appearing most commonly in nature, i.e. in the study of internal categories, triposes, and the denotational semantics of polymorphism. In addition, we propose a new class of acyclic generic objects inspired by recent developments in higher category theory and the semantics of homotopy type theory, generalizing the realignment property of universes to the setting of an arbitrary fibration.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Manuscripts">Manuscripts</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author><fr:author><fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri><fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri><fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2022/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-existentials/</fr:uri><fr:display-uri>sterling-2022-existentials</fr:display-uri><fr:route>/sterling-2022-existentials/</fr:route><fr:title text="Reflections on existential types">Reflections on existential types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2022-existentials,
  doi = {10.48550/ARXIV.2210.00758},
  author = {Sterling, Jonathan},
  title = {Reflections on existential types},
  publisher = {arXiv},
  year = {2022},
  note = {Unpublished manuscript},
}]]></fr:meta><fr:meta name="doi">10.48550/arXiv.2210.00758</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Existential types are reconstructed in terms of <html:em>small reflective subuniverses</html:em> and dependent sums. The folklore decomposition detailed here gives rise to a particularly simple account of first class modules as a mode of use of traditional second class modules in connection with the modal operator induced by a reflective subuniverse, leading to a semantic justification for the rules of first-class modules in languages like OCaml and MoscowML.   Additionally, we expose several constructions that give rise to semantic models of ML-style programming languages with both first-class modules and realistic computational effects, culminating in a model that accommodates higher-order first class recursive modules <html:em>and</html:em> higher-order store.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri><fr:display-uri>sterling-2022-naive</fr:display-uri><fr:route>/sterling-2022-naive/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta><fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Dissertations">Dissertations</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Technical reports">Technical reports</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Workshop talks">Workshop talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-catmi/</fr:uri><fr:display-uri>sterling-2023-catmi</fr:display-uri><fr:route>/sterling-2023-catmi/</fr:route><fr:title text="Naïve denotational semantics: synthetic domains in the 21st century">Naïve denotational semantics: synthetic domains in the 21st century</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="external">http://www.catmi.no/</fr:meta><fr:meta name="slides">/bafkrmielsxg42lagb5fu2zymlfcvlvyqpvclrzc3kre6dszhwpgvdxuum4.pdf</fr:meta><fr:meta name="venue"><fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It is easy to teach a student how to give a naïve denotational semantics to a language like System T, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p><html:p>The dream of the 1990s was to find a category that behaves like <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this <html:strong>synthetic domain theory</html:strong> is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including simple denotational semantics for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p><html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta><fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-pujet-workshop/</fr:uri><fr:display-uri>sterling-2022-pujet-workshop</fr:display-uri><fr:route>/sterling-2022-pujet-workshop/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiajrzaq3g6iptivu37xqg6kfcxs32gvwnwqzrrzpp5g5cnvyhsfgy.pdf</fr:meta><fr:meta name="venue">Workshop on Dependent Type Theory (to celebrate the Defense of <fr:link href="/lo%C3%AFcpujet/" title="Loïc Pujet" uri="https://www.jonmsterling.com/loïcpujet/" display-uri="loïcpujet" type="local">Loïc Pujet</fr:link>)</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for <fr:link href="/gratzer-sterling-angiuli-coquand-birkedal-2022/" title="Controlling unfolding in type theory" uri="https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/" display-uri="gratzer-sterling-angiuli-coquand-birkedal-2022" type="local">controlling the unfolding of definitions in dependent type theory</fr:link>. Traditionally, proof assistants let users specify whether each definition can or cannot be unfolded in the remainder of a development; unfolding definitions is often necessary in order to reason about them, but an excess of unfolding can result in brittle proofs and intractably large proof goals. In our system, definitions are by default not unfolded, but users can selectively unfold them in a local manner. We justify our mechanism by means of elaboration to a core type theory with <html:em>extension types</html:em>, a connective first introduced in the context of homotopy type theory.  We prove a normalization theorem for our core calculus and have implemented our system in the cooltt proof assistant, providing both theoretical and practical evidence for it.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Seminar talks">Seminar talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-logsem/</fr:uri><fr:display-uri>sterling-2023-logsem</fr:display-uri><fr:route>/sterling-2023-logsem/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiczxyoaqvsobp544cpqfjrr5tisnm36cmkyb2pykcw5owku7hzoai.pdf</fr:meta><fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines guarded recursion (the "later" modality) with impredicative polymorphism (universal and existential types). It turns out that these two features are sufficient to define a very simple denotational semantics for System F with recursive types and higher-order store. We believe that the expressivity of iGDTT brings us one step closer to a general metalanguage for realistic denotational semantics, and provides a compelling strategy to elude the burden of operational semantics. As a further benefit, we are now able to justify the extension of full dependent type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-cambridge/</fr:uri><fr:display-uri>sterling-2023-cambridge</fr:display-uri><fr:route>/sterling-2023-cambridge/</fr:route><fr:title text="Crossing boundaries in program semantics">Crossing boundaries in program semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiaqido7bsry3bs2tnh5rtwa3ozf4wpm3zui46pneusslkxoh46nza.pdf</fr:meta><fr:meta name="venue"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>The great semanticist John Reynolds famously wrote in 1983 that “type structure is a syntactic
discipline for enforcing levels of abstraction”. If the last twenty years of programming language
semantics and verification have taught us anything, it is that we also need a syntactic discipline
for breaking abstraction — in other words, a way to glue together programs and verifications that
cut across abstraction barriers.</html:p><html:p>In programming language semantics and verification, the problem of combining multiple levels of
abstraction arises when choosing a “level of detail” at which to view program execution:
for instance, one could look at program execution as a detailed operational process of
discrete steps evincing the cost or complexity of an algorithm, or one could think of
it more abstractly as a black box that only sends inputs to outputs. The difficulty is
that in practice, verifications tend to cut across this barrier between complexity
and functional correctness: for instance, complexity bounds often depend on the
functional correctness of subroutines, and the existence of such a bound implies
termination (a correctness property).</html:p><html:p>For this reason, it is crucial to develop integrated logical foundations for <html:strong>soundly</html:strong> reasoning
using multiple models of execution at the same time, even when they expose different facets of
a program's meaning. For the past three years, my research program has been to uncover and
exploit the basic “laws of motion” governing all such abstraction barriers, which has led
to the solution of a few significant open problems in homotopy type theory and modal type
theory, as well as some preliminary applications to security and cost analysis.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-birmingham/</fr:uri><fr:display-uri>sterling-2023-birmingham</fr:display-uri><fr:route>/sterling-2023-birmingham/</fr:route><fr:title text="New spaces for denotational semantics">New spaces for denotational semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmihzmtwc65afir3o7ttpmckh5xakkorwpwjj6x5eg4hascotp456ke.pdf</fr:meta><fr:meta name="venue">University of Birmingham</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>11</fr:month><fr:day>8</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-itu/</fr:uri><fr:display-uri>sterling-2022-itu</fr:display-uri><fr:route>/sterling-2022-itu/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmigiix5np3fp4npmgxvmx7kl7nb52ieyiazbwdxh6amdbfxdhnp2fy.pdf</fr:meta><fr:meta name="venue">Programming, Logic and Semantics, ITU Copenhagen</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines
<html:em>guarded recursion</html:em> (the "later" modality) with <html:em>impredicative polymorphism</html:em> (universal and existential types).
It turns out that these two features are sufficient to define a very simple denotational semantics for
System F with recursive types and higher-order store. We believe that the expressivity of iGDTT
brings us one step closer to a general metalanguage for realistic denotational semantics,
and provides a compelling strategy to elude the burden of operational semantics.
As a further benefit, we are now able to justify the extension of full dependent
type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Roladex">Roladex</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri><fr:display-uri>jonmsterling</fr:display-uri><fr:route>/jonmsterling/</fr:route><fr:title text="Jon Sterling">Jon Sterling</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta><fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta><fr:meta name="orcid">0000-0002-0585-5564</fr:meta><fr:meta name="position">Associate Professor</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="postdoc-advisor">larsbirkedal</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p><html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
            <fr:display-uri>jms-0061</fr:display-uri>
            <fr:route>/jms-0061/</fr:route>
            <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
            <fr:taxon>Fellowship</fr:taxon>
            <fr:meta name="doi">10.3030/101065303</fr:meta>
            <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
            <fr:display-uri>jms-0061</fr:display-uri>
            <fr:route>/jms-0061/</fr:route>
            <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
            <fr:taxon>Fellowship</fr:taxon>
            <fr:meta name="doi">10.3030/101065303</fr:meta>
            <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
