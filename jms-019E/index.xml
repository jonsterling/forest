<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>2</fr:month>
      <fr:day>28</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-019E/</fr:uri>
    <fr:display-uri>jms-019E</fr:display-uri>
    <fr:route>/jms-019E/</fr:route>
    <fr:title text="Project Pterosaur">Project Pterosaur</fr:title>
    <fr:meta name="external">https://github.com/jonsterling/project-pterosaur</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>An experimental proof assistant based on locales.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-01A1/</fr:uri>
            <fr:display-uri>jms-01A1</fr:display-uri>
            <fr:route>/jms-01A1/</fr:route>
            <fr:title text="Weeknotes 2025-W15 › Project Pterosaur: yes, I’m building a new proof assistant"><fr:link href="/2025-W15/" title="Weeknotes 2025-W15" uri="https://www.jonmsterling.com/2025-W15/" display-uri="2025-W15" type="local">Weeknotes 2025-W15</fr:link> › <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>: yes, I’m building a new proof assistant</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>I swore after building <fr:link href="https://github.com/RedPRL/cooltt" type="external">cooltt</fr:link>, <fr:link href="https://github.com/RedPRL/redtt" type="external">redtt</fr:link>, and <fr:link href="https://github.com/RedPRL/sml-redprl" type="external">RedPRL</fr:link> that I would never build another proof assistant, as the experience burned around four years of my PhD and resulted (at least directly) in very little publishable work—but, to be fair, I probably would not have made the <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">key mathematical discovery</fr:link> of my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">PhD thesis</fr:link> if it were not for these engineering experiments. But I’m back on my bullshit, as the young people say, and hard at work building a new interactive proof assistant that I have code-named <fr:link href="/jms-019E/" title="Project Pterosaur" uri="https://www.jonmsterling.com/jms-019E/" display-uri="jms-019E" type="local">Project Pterosaur</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A2/</fr:uri>
                <fr:display-uri>jms-01A2</fr:display-uri>
                <fr:route>/jms-01A2/</fr:route>
                <fr:title text="Locales in dependent type theory?">Locales in dependent type theory?</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The goal of Pterosaur is to explore the adaptation of <html:em>locales</html:em> from Isabelle to dependent type theory, as a lightweight but extremely expressive alternative to type classes. My colleague <fr:link href="/lawrencepaulson/" title="Lawrence Paulson" uri="https://www.jonmsterling.com/lawrencepaulson/" display-uri="lawrencepaulson" type="local">Larry Paulson</fr:link> has written <fr:link href="https://lawrencecpaulson.github.io/tag/locales" type="external">some great blog posts about locales in Isabelle</fr:link>, and I strongly recommend reading Ballarin’s <fr:link href="https://www21.in.tum.de/~ballarin/publications/jar2019.pdf" type="external">Exploring the Structure of an Algebra Text with Locales</fr:link> to get a feel for what is possible. Here is what locales do:</html:p>
                <html:ol><html:li>Locales appear to completely solve the pain involved when building up hierarchies of mathematical structures and notations, allowing you to effortlessly combine theories along a common core (e.g. defining rings in terms of a multiplicative monoid and an Abelian group sharing the same carrier).</html:li>
      <html:li>Locales allow you to <html:em>add new methods</html:em> to a theory after the fact, and they will magically be available on anything that extended that theory. You can also add new links in the theory graph, and both cycles and diamonds are allowed so long as they are coherent; this is useful if you want to silently regard (e.g.) the space of endomaps on a set as a monoid, etc.</html:li></html:ol>
                <html:p>In comparison to modules and type classes, the strength of locales is that you don’t have to decide ahead of time whether you want to “bundle” fields with their carriers, etc. In contrast, a great deal of the difficult work of mathematical library design and maintainance in tools like Rocq, Agda, and <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link> is figuring out just what things to bundle, and fixing things when your choices inevitably lead to breakage, etc. Locales avoid these problems entirely.</html:p>
                <html:p>Finally, a reasonably usable locale implementation can be obtained <html:em>without any higher-order unification whatsoever</html:em>. I have a feeling that will be extremely important, given how unreliable (and <fr:link href="https://github.com/agda/agda/issues/5837" type="external">incorrect</fr:link>!) most implementations of higher-order unification are; the situation is so bad that it is actually an open problem to define a correct higher-order unification algorithm in the presence of singleton types (such as the unit type). I do think that this can be solved (and may have already been solved by Andras Kovacs), but my point is that the prognosis for unification in dependent type theory is bad.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A3/</fr:uri>
                <fr:display-uri>jms-01A3</fr:display-uri>
                <fr:route>/jms-01A3/</fr:route>
                <fr:title text="Experimental implementation in Lean">Experimental implementation in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The other interesting thing about Pterosaur is that I am implementing it in <fr:link href="/jms-019G/" title="Lean" uri="https://www.jonmsterling.com/jms-019G/" display-uri="jms-019G" type="local">Lean</fr:link>; I am not verifying anything, and am making free use of Lean’s <html:code>partial</html:code> keyword (which hides potentially divergent code from definitional equality). Instead, I am thinking of Lean as a “better OCaml”: I can’t speak to the quality of the compiler and code generator, but I can absolutely say that from the perspective of day-to-day programming, Lean has a lot of affordances that make it extremely nice to use. On the other hand, Lean’s story for modularity is not so good; but I hope they don’t “fix” it any time soon, because I think that something like locales could be a good option for Lean itself in the future if I am able to demonstrate their potential in the context of Pterosaur’s clean-room implementation.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-01A4/</fr:uri>
                <fr:display-uri>jms-01A4</fr:display-uri>
                <fr:route>/jms-01A4/</fr:route>
                <fr:title text="A taste of code">A taste of code</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I will have more to say about Pterosaur in the future, but let me leave you with a bit of demo code.</html:p>
                <html:pre><![CDATA[locale Magma { A =>
  car : Type,
  car.isSet : isSet A·car,
  cmp : (x y : A·car) → A·car
}

locale Magma.Hom { f =>
  dom : Magma,
  cod : Magma,
  car : (x : f·dom·car) → f·cod·car,
  cmp : (x y : f·dom·car) → Id f·cod·car (f·car (f·dom·cmp x y)) (f·cod·cmp (f·car x) (f·car y))
}

locale Semigroup { A =>
  splice magma : Magma,
  cmp.assoc : (x y z : A·car) → Id A·car (A·cmp (A·cmp x y) z) (A·cmp x (A·cmp y z))
}

locale Semigroup.Hom {f =>
  dom : Semigroup,
  cod : Semigroup,
  splice magma.hom : Magma.Hom / {dom := f·dom·magma, cod := f·cod·magma}
}

locale Monoid { A =>
  splice semigroup : Semigroup,
  unit : A·car,
  cmp.leftUnit : (x : A·car) → Id A·car (A·cmp A·unit x) x,
  cmp.rightUnit : (x : A·car) → Id A·car (A·cmp x A·unit) x
}

locale Monoid.Hom {f =>
  dom : Monoid,
  cod : Monoid,
  splice semigroup.hom : Semigroup.Hom / {dom := f·dom·semigroup, cod := f·cod·semigroup},
  unit : Id f·cod·car (f·car f·dom·unit) f·cod·unit
}

locale Group { G =>
  splice monoid : Monoid,
  inv : (x : G·car) → G·car,
  inv.inv : (x : G·car) → Id G·car (G·inv (G·inv x)) x
}

locale AbelianGroup { A =>
  splice group : Group,
  splice commutativeOperation : CommutativeOperation / {car := A·car, cmp := A·cmp}
}]]></html:pre>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
