<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://www.jonmsterling.com/danielgratzer/</fr:uri>
    <fr:display-uri>danielgratzer</fr:display-uri>
    <fr:route>/danielgratzer/</fr:route>
    <fr:title text="Daniel Gratzer">Daniel Gratzer</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:meta name="external">http://www.danielgratzer.com/</fr:meta>
    <fr:meta name="institution">
      <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>
    </fr:meta>
    <fr:meta name="position">PhD Student</fr:meta>
    <fr:meta name="phd-advisor">larsbirkedal</fr:meta>
    <fr:meta name="orcid">0000-0003-1944-0789</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:blockquote>I study programming languages, type theories, and logics. I am particularly interested in applying semantic methods to prove syntactic properties of modal type theories and programming languages. I am also involved in the development of program logics for concurrent programming languages through the <fr:link href="https://iris-project.org/" type="external">Iris project</fr:link>.</html:blockquote>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>9</fr:month>
              <fr:day>4</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2024-cmu-hott/</fr:uri>
            <fr:display-uri>sterling-2024-cmu-hott</fr:display-uri>
            <fr:route>/sterling-2024-cmu-hott/</fr:route>
            <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit technique to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> presented an elegant functorial analysis of this construction in terms of the <html:em>‘categorical nerve’</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, applying the categorical nerve to the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting.</html:p>
            <html:p>Although <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> has investigated Hofmann–Streicher lifting in terms of a 1-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐏𝐫</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math>, his analysis can be extended to a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that is observed by <fr:link href="/weber-2007/" title="Yoneda structures from 2-toposes" uri="https://www.jonmsterling.com/weber-2007/" display-uri="weber-2007" type="local">Weber</fr:link> to be right 2-adjoint to the 2-functor that takes a fibred category to its total category (i.e. the oplax colimit of the corresponding diagram of categories under straightening). A generalised form of Hofmann–Streicher lifting that can be applied to categories other than universes is then obtained by conjugating this right 2-adjoint with duality involutions.</html:p>
            <html:p>In joint work with <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> and <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>, we have constructed a <html:em>relative</html:em> version of the 2-functorial Hofmann–Streicher lifting: given a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>, we have a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Δ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> which is <html:em>not</html:em> base change but rather (we conjecture) right <html:em>pseudo</html:em>-adjoint to the 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Σ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that sends a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi></mml:mrow></mml:math> to the composite fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">∘</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi></mml:mrow><mml:mo lspace=".2em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>. A relative version of Hofmann–Streicher lifting could give a more regular theory to the practice of computing <html:em>internal</html:em> liftings of lifted universes.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:contributor>
                <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
              </fr:contributor>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00RN/</fr:uri>
            <fr:display-uri>jms-00RN</fr:display-uri>
            <fr:route>/jms-00RN/</fr:route>
            <fr:title text="Baby steps in higher domain theory">Baby steps in higher domain theory</fr:title>
            <fr:taxon>Presentation</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/hottccq-2024/" title="Homotopy Type Theory and Computing – Classical and Quantum" uri="https://www.jonmsterling.com/hottccq-2024/" display-uri="hottccq-2024" type="local">Homotopy Type Theory and Computing – Classical and Quantum</fr:link>
            </fr:meta>
            <fr:meta name="beamer-preamble"><![CDATA[ \setbeamertemplate{bibliography item}{\insertbiblabel}
 \setbeamertemplate{bibliography item}{}
 \setbeamertemplate{footline}[frame number]
 \setbeamertemplate{navigation symbols}{}
 \author{Jon Sterling\thanks{Sponsored by AFOSR under award FA9550-23-1-0728 (\emph{New Spaces for Denotational Semantics}; Dr Tristan Nguyen, PM).}\\ j.w.w. Leoni Pugh}
 \date{20 April 2024\\ \textcolor{black!50}{running HoTT @ NYU Abu Dhabi}}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>I present some preliminary results obtained with <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link> concerning partial map classifiers in <html:em>higher domain theory</html:em>, realised in a version of <fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl and Shulman</fr:link>’s simplicial type theory assuming <fr:link href="/phoa-1991/" title="Domain theory in realizability toposes" uri="https://www.jonmsterling.com/phoa-1991/" display-uri="phoa-1991" type="local">Phoa’s principle</fr:link> for the simplicial interval.</html:p>
 
 

 <fr:tree show-heading="false" show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>This is joint work with my masters/Part III student <html:strong><fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link></html:strong>.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="What is domain theory?">What is domain theory?</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Domain theory is “topology with an attitude”...</html:p><html:p>Not, to be clear, topology <html:em>qua</html:em> the study of topological spaces, but rather: <html:strong>topology <html:em>qua</html:em> the search for adequate notions of space</html:strong>.</html:p><html:p>Adequate for what? There are <fr:link href="/fiore-1994/" title="Axiomatic domain theory in categories of partial maps" uri="https://www.jonmsterling.com/fiore-1994/" display-uri="fiore-1994" type="local">many</fr:link> <fr:link href="/ghklms-2003/" title="Continuous lattices and domains" uri="https://www.jonmsterling.com/ghklms-2003/" display-uri="ghklms-2003" type="local">viewpoints</fr:link>, and all of them are correct. But today, I speak about computer science.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Domains for computer science">Domains for computer science</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A domain is a space in which computation happens.</html:p><html:p>The (generalised) points of a domain correspond to specific programs.</html:p><html:p>Points of a domain <fr:tex display="inline"><![CDATA[X]]></fr:tex> are equipped with an information order <fr:tex display="inline"><![CDATA[u\sqsubseteq _X v]]></fr:tex> that can be thought of in two ways:</html:p><html:ol><html:li><html:strong>Logic:</html:strong> “Any observably true property of <fr:tex display="inline"><![CDATA[u]]></fr:tex> is also true of <fr:tex display="inline"><![CDATA[v]]></fr:tex>.”</html:li>
  <html:li><html:strong>Geometry:</html:strong> “We have a continuous transformation <fr:tex display="inline"><![CDATA[\alpha \colon \mathbb {I}\to  X]]></fr:tex> with <fr:tex display="inline"><![CDATA[\alpha {\mathopen {}\left (0\right )\mathclose {}} = u]]></fr:tex> and <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\alpha {\mathopen {}\left (1\right )\mathclose {}} = v]]></fr:tex>.”</html:span></html:li></html:ol><html:p>A reasonable “logic of observable properties” can always be obtained by saying that <fr:tex display="inline"><![CDATA[P\subseteq  X]]></fr:tex> is observable iff it is classified by <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{1\right \}\mathclose {}}\subseteq \mathbb {I}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Recursion as passage to the (co)limit">Recursion as passage to the (co)limit</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>With the information order, domains are naturally arranged into a (locally posetal) bicategory. Recursion is interpreted as <html:em>sequential colimit</html:em>, both at the “type level” and the “program level”.</html:p><html:ol><html:li>A recursively defined domain is obtained as the pseudo-colimit of an <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-chain of internal adjunctions (<fr:link href="/cattani-fiore-2007/" title="The bicategory-theoretic solution of recursive domain equations" uri="https://www.jonmsterling.com/cattani-fiore-2007/" display-uri="cattani-fiore-2007" type="local">Cattani and Fiore</fr:link>).</html:li>
  <html:li>A recursively defined program is obtained as a (local) colimit of an <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-chain of generalised points.</html:li></html:ol></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Denotational semantics in domains">Denotational semantics in domains</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Domains have served as the computational substrate for the <html:em>denotational semantics of programming languages</html:em> to enable computational reasoning about recursive processes.</html:p><html:p>The simplest kinds of domains, <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-cpos and dcpos, have had the widest applicability for “working computer scientists”.</html:p><html:p>Some computational effects (<html:em>e.g.</html:em> exceptions, first-order store, non-determinism, <html:em>etc.</html:em>) dealt with elegantly in terms of these simple domains. <html:em>Concurrency is another story.</html:em></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="2-dimensional domain theory for concurrency (I)">2-dimensional domain theory for concurrency (I)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In classical domain theory, observations are “propositional”: there is at most one way for an observation to happen (<html:em>e.g.</html:em> termination). Early attempts at concurrency semantics used domains of <html:em>sets of traces</html:em>.</html:p><html:p><html:strong>Inadequate for concurrency:</html:strong> many different ways for a process to take a certain path. <html:em>Two processes that realise the same set of traces may not be bisimilar,</html:em> as bisimulation theory must “remember” the way that processes are glued together.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="2-dimensional domain theory for concurrency (II)">2-dimensional domain theory for concurrency (II)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> be an “action”, and consider the two processes <fr:tex display="inline"><![CDATA[\alpha \star ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\alpha .\varnothing  + \alpha \star ]]></fr:tex>.</html:p><html:p>We have <fr:tex display="inline"><![CDATA[\mathbf {Traces}{\mathopen {}\left (\alpha \star \right )\mathclose {}} = {\mathopen {}\left \{\varepsilon , \alpha , \alpha .\alpha ,\ldots \right \}\mathclose {}}=\mathbf {Traces}{\mathopen {}\left (\alpha .\varnothing  + \alpha \star \right )\mathclose {}}]]></fr:tex>.</html:p><html:p>But the process <fr:tex display="inline"><![CDATA[\alpha \star ]]></fr:tex> can never get stuck, whereas <fr:tex display="inline"><![CDATA[\alpha .\varnothing  + \alpha \star ]]></fr:tex> gets stuck if it proceeds along the left branch.</html:p><html:p>Thus trace equivalence is highly un-physical. To deal with this, we generalise the information <html:em>order</html:em> to a category in which bisimulation can be expressed. <html:strong>Idea: non-determinism must be modelled by a <html:em>van Kampen</html:em> colimit (e.g. disjoint coproduct).</html:strong></html:p><html:p>See <fr:link href="/joyal-nielsen-winskel-1996/" title="Bisimulation from open maps" uri="https://www.jonmsterling.com/joyal-nielsen-winskel-1996/" display-uri="joyal-nielsen-winskel-1996" type="local">Joyal, Nielsen and Winskel (1996)</fr:link> and <fr:link href="/cattani-winskel-2005/" title="Profunctors, open maps and bisimulation" uri="https://www.jonmsterling.com/cattani-winskel-2005/" display-uri="cattani-winskel-2005" type="local">Cattani and Winskel (2005)</fr:link>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Towards \infty -bicategories of domains">Towards <fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-bicategories of domains</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Bicategories of concurrent domains abound (most examples arising from distributors, spans, or the like).</html:p><html:p>We are interested in <fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-bicategories, <html:em>i.e.</html:em> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\infty ,2\right )\mathclose {}}]]></fr:tex>-categories, of domains. Potential advantage: a domain of all domains (<fr:link href="/paultaylor/" title="Paul Taylor" uri="https://www.jonmsterling.com/paultaylor/" display-uri="paultaylor" type="local">Paul Taylor</fr:link>).</html:p><html:p>To that end, we start by studying domain-theoretic concepts in the <fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl–Shulman</fr:link> framework for synthetic <fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-categories.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Simplicial homotopy type theory">Simplicial homotopy type theory</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl and Shulman</fr:link> introduced <html:em>simplicial HoTT</html:em>, a new type theory with judgemental structure that represents the <fr:tex display="inline"><![CDATA[n]]></fr:tex>-simplex <fr:tex display="inline"><![CDATA[\mathbb {I}_n\subseteq \mathbb {I}^n]]></fr:tex> and related figures (like the horn <fr:tex display="inline"><![CDATA[\mathbb {H}^2_1\subseteq \mathbb {I}_2]]></fr:tex>) in the <fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>-topos of simplicial spaces.</html:p><html:ol><html:li><html:strong>Segal types</html:strong> are internally orthogonal to <fr:tex display="inline"><![CDATA[\mathbb {H}^2_1\hookrightarrow \mathbb {I}_2]]></fr:tex>.</html:li>
  <html:li><html:strong>Rezk types</html:strong> are internally orthogonal to <fr:tex display="inline"><![CDATA[\mathbb {H}^2_1\hookrightarrow \mathbb {I}_2]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {E}\to \mathbf {1}]]></fr:tex> where <fr:tex display="inline"><![CDATA[\mathbb {E}]]></fr:tex> is the walking isomorphism.</html:li></html:ol><html:p>Segal <fr:tex display="inline"><![CDATA[\sim ]]></fr:tex> precategory, Rezk <fr:tex display="inline"><![CDATA[\sim ]]></fr:tex> category.</html:p><html:p>The judgmental structure of simplicial HoTT can be distracting. <html:strong>Simpler(*):</html:strong> just axiomatise the theory of a strict interval in HoTT.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Lifting and partial map classifiers">Lifting and partial map classifiers</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Domains are usually defined as the <html:em>algebras</html:em> for a partial map classifier (pseudo-)monad, where <fr:tex display="inline"><![CDATA[\mathcal {O}]]></fr:tex> is a <fr:link href="/rosolini-1986/" title="Continuity and effectiveness in topoi" uri="https://www.jonmsterling.com/rosolini-1986/" display-uri="rosolini-1986" type="local">dominance</fr:link> containing <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex>.</html:p><fr:tex display="block"><![CDATA[
  L{\mathopen {}\left (A\right )\mathclose {}} :\equiv 
  \mathchoice {\textstyle \sum _{{\mathopen {}\left (p:\mathcal {O}\right )\mathclose {}}}}{\textstyle \sum _{{\mathopen {}\left (p:\mathcal {O}\right )\mathclose {}}}}{\scriptstyle \sum _{{\mathopen {}\left (p:\mathcal {O}\right )\mathclose {}}}}{\scriptscriptstyle \sum _{{\mathopen {}\left (p:\mathcal {O}\right )\mathclose {}}}}A^p
 ]]></fr:tex><html:p>The dominance <fr:tex display="inline"><![CDATA[\mathcal {O}]]></fr:tex> is some kind of interval, as <fr:tex display="inline"><![CDATA[\bot \leq  \top ]]></fr:tex>. <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link> and I are studying the partial map classifier for the simplicial interval <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex> in simplicial homotopy type theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Right-handed universal property of partial map classifiers">Right-handed universal property of partial map classifiers</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Maps <fr:tex display="inline"><![CDATA[X\to  L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> uniquely determine spans <fr:tex display="inline"><![CDATA[X\hookleftarrow  U\to  A]]></fr:tex> whose left components are <html:em><html:strong>open</html:strong></html:em>, i.e. classified by <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{1\right \}\mathclose {}}\subseteq \mathbb {I}]]></fr:tex>, as follows:</html:p>
 
  
  <html:figure><fr:resource hash="bb60851fec05acf002dcfe7f6b601115"><fr:resource-content><html:img src="/bb60851fec05acf002dcfe7f6b601115.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
   \SpliceDiagramSquare <l/>{
    nw = U,
    sw = X,
    ne = A,
    se = L{\mathopen {}\left (A\right )\mathclose {}},
    nw/style = pullback,
    north/style = {exists,->},
    west/style = {exists,open immersion},
    east/style = open immersion,
    ne/style = pullback,
   }
   \SpliceDiagramSquare <r/>{
    glue target = l/, glue = west,
    east/style = open immersion,
    ne = {\mathopen {}\left \{1\right \}\mathclose {}},
    se = \mathbb {I},
   }
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Phoa’s principle in higher domain theory"><fr:link href="/phoa-1991/" title="Domain theory in realizability toposes" uri="https://www.jonmsterling.com/phoa-1991/" display-uri="phoa-1991" type="local">Phoa’s principle</fr:link> in higher domain theory</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Not much can be done until we assume Phoa’s principle, which is either of the following equivalent properties:</html:p><html:ol><html:li>The boundary map <fr:tex display="inline"><![CDATA[\mathbb {I}^\mathbb {I}\to  \mathbb {I}^2]]></fr:tex> factors through an isomorphism <fr:tex display="inline"><![CDATA[\mathbb {I}^\mathbb {I}\cong  \mathbb {I}_2\subseteq  \mathbb {I}^2]]></fr:tex>.</html:li>
  <html:li>For any function <fr:tex display="inline"><![CDATA[\phi \colon  \mathbb {I}\to \mathbb {I}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[\phi {\mathopen {}\left (x\right )\mathclose {}} = \phi {\mathopen {}\left (0\right )\mathclose {}}\lor {\mathopen {}\left (x \land  \phi {\mathopen {}\left (1\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex>.</html:li></html:ol><html:p>Probably cannot be deduced from the axiomatics of <fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl and Shulman</fr:link>, but true in the model.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="The higher Phoa principle (Leoni Pugh)">The higher Phoa principle (<fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We might name by the “higher Phoa principle” either of the following equivalent properties:</html:p><html:ol><html:li>Each boundary map <fr:tex display="inline"><![CDATA[\mathbb {I}^{\mathbb {I}_n}\to  \mathbb {I}^{n+1}]]></fr:tex> factors through an isomorphism <fr:tex display="inline"><![CDATA[\mathbb {I}^{\mathbb {I}_n}\cong  \mathbb {I}_{n+1}\subseteq \mathbb {I}^{n+1}]]></fr:tex>.</html:li>
  <html:li>For any function <fr:tex display="inline"><![CDATA[\phi \colon  \mathbb {I}_n\to  \mathbb {I}]]></fr:tex>, we have: <fr:tex display="block"><![CDATA[\phi {\mathopen {}\left (x_0,\ldots  x_{n-1}\right )\mathclose {}}=\phi {\mathopen {}\left (0\ldots \right )\mathclose {}}\lor  \bigvee _{1\leq  i \leq  n}{\mathopen {}\left (x_{n-i}\land  \phi {\mathopen {}\left (0^{n-i}\ldots  1^i\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex></html:li></html:ol><html:p>Equivalence due to <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>. In fact, Pugh shows that the ordinary Phoa principle implies the higher Phoa principle.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="The Phoa principle vs. synthetic quasicoherence">The Phoa principle <html:em>vs.</html:em> synthetic quasicoherence</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The higher Phoa principle is a Kock–Lawvere / <html:em><fr:link href="/blechschmidt-2023-qcoh/" title="A general Nullstellensatz for generalized spaces" uri="https://www.jonmsterling.com/blechschmidt-2023-qcoh/" display-uri="blechschmidt-2023-qcoh" type="local">“synthetic quasi-coherence”</fr:link></html:em> axiom that comes directly from the geometric theory of a strict interval, as a quotient of the theory of bounded distributive lattices (<fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Gratzer</fr:link>).</html:p><html:p><html:strong>Question.</html:strong> What are the other domain theoretic consequences of synthetic quasicoherence?</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="The partial map classifier of a synthetic {\mathopen {}\left (\infty ,1\right )\mathclose {}}-category">The partial map classifier of a synthetic <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\infty ,1\right )\mathclose {}}]]></fr:tex>-category</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Assuming the higher Phoa principle, <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni</fr:link> has deduced that if <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a Segal type, then so is <fr:tex display="inline"><![CDATA[L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex>.</html:p><html:p>It is not difficult, using results of <fr:link href="/ulrikbuchholtz/" title="Ulrik Buchholtz" uri="https://www.jonmsterling.com/ulrikbuchholtz/" display-uri="ulrikbuchholtz" type="local">Buchholtz</fr:link> and <fr:link href="/jonathanweinberger/" title="Jonathan Weinberger" uri="https://www.jonmsterling.com/jonathanweinberger/" display-uri="jonathanweinberger" type="local">Weinberger</fr:link>, to show that if <fr:tex display="inline"><![CDATA[A]]></fr:tex> is Rezk, then so is <fr:tex display="inline"><![CDATA[L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex>.</html:p><html:p>Thus, synthetic <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\infty ,1\right )\mathclose {}}]]></fr:tex>-categories are closed under partial map classifiers: a necessary first step to a theory of higher domains.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Is the partial map classifier a Sierpiński cone? (I)">Is the partial map classifier a Sierpiński cone? (I)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In traditional domain theory, the partial map classifier has an additional <html:em>left</html:em>-handed universal property: the Sierpiński cone.</html:p>
 
  
  <html:figure><fr:resource hash="5c1aa5d9b676f88ed5e3ee78bce301bd"><fr:resource-content><html:img src="/5c1aa5d9b676f88ed5e3ee78bce301bd.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
   \SpliceDiagramSquare {
    nw = A,
    ne = A,
    sw = {\mathopen {}\left \{\bot \right \}\mathclose {}},
    se = \bot {\mathopen {}\left (A\right )\mathclose {}},
    east = \eta ,
    south = \bot ,
    west = !_A,
    north = 1_{A},
   }
   \node [between = sw and ne, rotate=-45] {$\Uparrow $};
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource></html:figure>
 
(In categories, this means: free cocompletion by an initial object.)</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Is the partial map classifier a Sierpiński cone? (II)">Is the partial map classifier a Sierpiński cone? (II)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The scone’s universal property allows “case analysis” on whether a partial element is defined, <html:em>even</html:em> in constructive domain theory. When <fr:tex display="inline"><![CDATA[c_\bot  \sqsubseteq _C c_\eta  x]]></fr:tex>, we may define:</html:p>
 
  
  <html:figure><fr:resource hash="3c3d8a5f661f54fe25a92b1c552700b2"><fr:resource-content><html:img src="/3c3d8a5f661f54fe25a92b1c552700b2.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
   \begin {scope}[every node/.style={gray}, every path/.style={gray}]
    \SpliceDiagramSquare {
     nw = A,
     ne = A,
     sw = {\mathopen {}\left \{\bot \right \}\mathclose {}},
     se = \bot {\mathopen {}\left (A\right )\mathclose {}},
     east = \eta ,
     south = \bot ,
     west = !_A,
     north = 1_{A},
    }
    \node [between = sw and ne, rotate=-45] {$\Uparrow $};
   \end {scope}
   \node [below right = of se] (C) {$C$};
   \draw [->, bend right=30] (sw) to node[sloped,below] {$c_\bot $} (C);
   \draw [->, bend left=30] (ne) to node[right] {$c_\eta $} (C);
   \draw [->, exists] (se) to node[desc] {$\exists !$} (C);
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Is the partial map classifier a Sierpiński cone? (III)">Is the partial map classifier a Sierpiński cone? (III)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We can actually compute the scone <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> in simplicial type theory.</html:p><html:ol><html:li>First take a pushout with the appropriate weight:
    
 
  
  <html:figure><fr:resource hash="b37df35976a9879d4eb0e563696c1f82"><fr:resource-content><html:img src="/b37df35976a9879d4eb0e563696c1f82.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
     \begin {tikzpicture}[diagram]
      \SpliceDiagramSquare {
       nw = A,
       ne = \mathbb {I} \times  A,
       sw = {\mathopen {}\left \{\bot \right \}\mathclose {}},
       se = {\mathopen {}\left \{\bot \right \}\mathclose {}} \amalg _A {\mathbb {I}\times  A},
       east = \eta ,
       south = \bot ,
       west = !_A,
       north = {\mathopen {}\left \langle 0,1_{A}\right \rangle \mathclose {}},
       se/style = pushout,
       width = 2.5cm,
      }
     \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li>
   
   <html:li>Then compute the universal Rezk type <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> equipped with a map <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{\bot \right \}\mathclose {}} \amalg _A {\mathbb {I}\times  A} \to  \bot {\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex>.</html:span></html:li></html:ol>(Recall that Rezk types are defined by localising at just two maps.)</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Is the partial map classifier a Sierpiński cone? (IV)">Is the partial map classifier a Sierpiński cone? (IV)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>When <fr:tex display="inline"><![CDATA[A]]></fr:tex> is Rezk, we have a comparison map <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}} \to  L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex>. <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Pugh</fr:link>’s result lets us use the universal property of the scone:</html:p>
 
  
  <html:figure><fr:resource hash="44c3ef5d45fe054346003d0304df2318"><fr:resource-content><html:img src="/44c3ef5d45fe054346003d0304df2318.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
   \begin {scope}
    \SpliceDiagramSquare {
     nw = A,
     ne = A,
     sw = {\mathopen {}\left \{\bot \right \}\mathclose {}},
     se = \bot {\mathopen {}\left (A\right )\mathclose {}},
     east = \eta ,
     south = \bot ,
     west = !_A,
     north = 1_{A},
    }
   \end {scope}
   \begin {scope}[every node/.style={magenta},every path/.style={magenta}]
    \node [between = sw and ne, rotate=-45] {$\Uparrow $};
    \node [below right = of se] (C) {$L{\mathopen {}\left (A\right )\mathclose {}}$};
    \draw [->, bend right=30] (sw) to node[sloped,below] {${\mathopen {}\left \langle 0,\lambda {\mathopen {}\left (\right )\mathclose {}}\right \rangle \mathclose {}}$} (C);
    \draw [->, bend left=30] (ne) to node[right] {$\lambda {x}\mathpunct {.}{\mathopen {}\left \langle 1,\lambda {p}\mathpunct {.}x\right \rangle \mathclose {}}$} (C);
    \draw [->, exists] (se) to (C);
   \end {scope}
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Unfortunately, the present axiomatics do <html:em>not</html:em> seem to imply that <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}}\to  L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> is an equivalence.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-012P/</fr:uri><fr:display-uri>jms-012P</fr:display-uri><fr:route>/jms-012P/</fr:route><fr:title text="Is the partial map classifier a Sierpiński cone? (V)">Is the partial map classifier a Sierpiński cone? (V)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the case of dcpos, unique extensions of <fr:tex display="inline"><![CDATA[f\colon  \bot {\mathopen {}\left (A\right )\mathclose {}}\to  C]]></fr:tex> along the comparison map <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}}\to  L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> are obtained by taking the <html:em>colimits</html:em> of diagrams <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (i=1\right )\mathclose {}}\to  C]]></fr:tex>:</html:p><fr:tex display="block"><![CDATA[
  \begin {aligned}
   L{\mathopen {}\left (A\right )\mathclose {}} &\to  C \\
   {\mathopen {}\left \langle i,a\right \rangle \mathclose {}} &\mapsto 
   \operatorname {colim}_{\bot {\mathopen {}\left (i=1\right )\mathclose {}}}
   {\mathopen {}\left  [f{\mathopen {}\left (\bot \right )\mathclose {}} \mid  p:i=1\hookrightarrow  f{\mathopen {}\left (\eta {\mathopen {}\left (a{\mathopen {}\left (p\right )\mathclose {}}\right )\mathclose {}}\right )\mathclose {}}\right  ]\mathclose {}}
  \end {aligned}
 ]]></fr:tex><html:p>Perhaps we can use the same idea.</html:p><html:p><html:strong>Conjecture.</html:strong> The comparison map <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (A\right )\mathclose {}}\to  L{\mathopen {}\left (A\right )\mathclose {}}]]></fr:tex> is left orthogonal to any Rezk type closed under colimits of shape <fr:tex display="inline"><![CDATA[\bot {\mathopen {}\left (i=1\right )\mathclose {}}]]></fr:tex> in the sense of <fr:link href="/bardomiano-mart%C3%ADnez-2023/" title="Limits and exponentiable functors in simplicial homotopy type theory" uri="https://www.jonmsterling.com/bardomiano-martínez-2023/" display-uri="bardomiano-martínez-2023" type="local">Bardomiano Martínez</fr:link>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Analytic vs. synthetic domain theory (I)">Analytic <html:em>vs.</html:em> synthetic domain theory (I)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Complete Segal spaces would provide a model of <html:em>higher analytic domain theory</html:em>, where cocontinuity conditions are explicit:</html:p><html:ol><html:li>Recursion is implemented by sequential colimits.</html:li>
  <html:li>Thus domains must be suitably cocomplete objects.</html:li>
  <html:li>And morphisms between domains must be suitably cocontinuous.</html:li></html:ol><html:p>This is natural, but very painful. <html:strong>We would like a “DSL” for domain theory, where maps are automatically cocontinuous.</html:strong> (<fr:link href="/danascott/" title="Dana Scott" uri="https://www.jonmsterling.com/danascott/" display-uri="danascott" type="local">Dana Scott</fr:link>’s suggestion, 1980: <html:em>synthetic</html:em> domain theory.)</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Analytic vs. synthetic domain theory (II)">Analytic <html:em>vs.</html:em> synthetic domain theory (II)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In <html:em>synthetic</html:em> domain theory, we expect a topos equipped with a <html:em><html:strong>full reflective subfibration</html:strong></html:em> of suitable “cocomplete” objects. This is, by definition, an orthogonality condition! “Cocontinuity” is thus automatic.</html:p><html:p>Let <fr:tex display="inline"><![CDATA[L{\mathopen {}\left (\omega \right )\mathclose {}} \to  \omega ]]></fr:tex> be an initial algebra, and let <fr:tex display="inline"><![CDATA[\bar {\omega }\to  L{\mathopen {}\left (\bar {\omega }\right )\mathclose {}}]]></fr:tex> be a terminal coalgebra with its infinite point <fr:tex display="inline"><![CDATA[\infty  \in  \bar \omega ]]></fr:tex>. We have a canonical comparison map  <fr:tex display="inline"><![CDATA[\omega \hookrightarrow \bar \omega ]]></fr:tex>.</html:p><html:p>Then a <html:em>(pre)domain</html:em> is a type that is internally orthogonal to every pullback of the comparison map <fr:tex display="inline"><![CDATA[\omega \hookrightarrow \bar \omega ]]></fr:tex> along an open subspace of <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Extending along <fr:tex display="inline"><![CDATA[\omega \hookrightarrow \bar \omega ]]></fr:tex> means: equip an “<fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-chain” with a “colimit”, given by evaluation of the extension at <fr:tex display="inline"><![CDATA[\infty ]]></fr:tex>.</html:p>
 
  
  <html:figure><fr:resource hash="1064532553b30e1f24220526cc86e8d8"><fr:resource-content><html:img src="/1064532553b30e1f24220526cc86e8d8.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
   \node (nw) {$\omega $};
   \node [below = of nw] (sw) {$\bar \omega $};
   \node [right = of nw] (ne) {$X$};
   \draw [embedding] (nw) to (sw);
   \draw [->] (nw) to node[above] {$x_\bullet $} (ne);
   \draw [exists,->] (sw) to node[sloped,below] {$\hat {x}_\bullet $} (ne);
   \node [left = of sw] (pt) {$\mathbf {1}$};
   \draw [->] (pt) to node[below] {$\infty $} (sw);
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Stability of the left class under open immersions <fr:tex display="inline"><![CDATA[U\hookrightarrow  \bar \omega ]]></fr:tex> implies that if <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a predomain, so is <fr:tex display="inline"><![CDATA[L{\mathopen {}\left (X\right )\mathclose {}}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:title text="Analytic vs. synthetic domain theory (III)">Analytic <html:em>vs.</html:em> synthetic domain theory (III)</fr:title><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the 1990s, <fr:link href="/fiore-rosolini-1997-mfps/" title="The category of cpos from a synthetic viewpoint" uri="https://www.jonmsterling.com/fiore-rosolini-1997-mfps/" display-uri="fiore-rosolini-1997-mfps" type="local">Fiore and Rosolini</fr:link> and <fr:link href="/fiore-plotkin-1997/" title="An extension of models of Axiomatic Domain Theory to models of Synthetic Domain Theory" uri="https://www.jonmsterling.com/fiore-plotkin-1997/" display-uri="fiore-plotkin-1997" type="local">Fiore and Plotkin</fr:link> studied the representation of analytic categories of domains in toposes of synthetic domains by taking sheaves, building on prior work of Scott.</html:p><html:p><html:strong>We hope</html:strong> that we can also take <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\infty ,1\right )\mathclose {}}]]></fr:tex>-sheaves on a dense generator of the category of <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex>-cpos to obtain a model of <html:strong>higher synthetic domain theory</html:strong>. Our existing work on lifting should apply.</html:p><html:p><html:strong>Open question.</html:strong> We must get a better understanding of models of SDT as classifying toposes in order to continue to synthetic quasicoherence.</html:p><html:p>Related to our current efforts, we hope also to investigate whether the <html:em>formally (co)complete cuboidal sets</html:em> of <fr:link href="/fiore-plotkin-power-1997/" title="Complete cuboidal sets in axiomatic domain theory" uri="https://www.jonmsterling.com/fiore-plotkin-power-1997/" display-uri="fiore-plotkin-power-1997" type="local">Fiore, Plotkin, and Power (1997)</fr:link> have a synthetic counterpart.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>4</fr:month><fr:day>5</fr:day></fr:date><fr:taxon>Slide</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>thanks!</html:p></fr:mainmatter></fr:tree></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-008J/</fr:uri>
            <fr:display-uri>jms-008J</fr:display-uri>
            <fr:route>/jms-008J/</fr:route>
            <fr:title text="Classifying topoi and generalised abstract syntax">Classifying topoi and generalised abstract syntax</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>For any small category <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>, <fr:link href="/fiore-2007-ct/" title="Towards a mathematical theory of substitution" uri="https://www.jonmsterling.com/fiore-2007-ct/" display-uri="fiore-2007-ct" type="local">Fiore</fr:link> <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">treats</fr:link> <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-sorted abstract syntax in the functor category <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [\mathscr {C},\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}{\mathscr {C}}\right )\mathclose {}}\right  ]\mathclose {}}]]></fr:tex> where <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is some 2-monad on <fr:tex display="inline"><![CDATA[\mathbf {Cat}]]></fr:tex>; any such functor <fr:tex display="inline"><![CDATA[P]]></fr:tex> denotes a set that is indexed in sorts and contexts (where the 2-monad <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> takes a category of sorts to the corresponding category of contexts). When <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex> is a set and <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is either finite limit or finite product completion, we recover the standard notions of many-sorted abstract syntax; in general, we get a variety of forms of <html:em>dependently sorted</html:em> or <html:em>generalised</html:em> abstract syntax.</html:p>
            <html:p>We will assume here that <fr:tex display="inline"><![CDATA[\operatorname {\mathbb {L}}]]></fr:tex> is the free finite limit completion 2-monad; our goal is to study <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">Fiore</fr:link>’s general <html:em>substitution monoidal structure</html:em> from the point of view of classifying topoi, building on <fr:link href="/peterjohnstone/" title="Peter T. Johnstone" uri="https://www.jonmsterling.com/peterjohnstone/" display-uri="peterjohnstone" type="local">Johnstone</fr:link>’s analogous observations (<fr:link href="/johnstone-2002/" title="Sketches of an elephant: a topos theory compendium" uri="https://www.jonmsterling.com/johnstone-2002/" display-uri="johnstone-2002" type="local">Elephant, D3.2</fr:link>) on the non-symmetric monoidal structure of the <html:em>object classifier</html:em>. The topos theoretic viewpoint that we will explore is nothing more than a rephrasing of <fr:link href="/fiore-2007-ct/" title="Towards a mathematical theory of substitution" uri="https://www.jonmsterling.com/fiore-2007-ct/" display-uri="fiore-2007-ct" type="local">Fiore</fr:link>’s account in terms of the Kleisli composition in a 2-monad; nonetheless the perspective of classifying topoi is enlightening, as it provides an explanation for <html:em>precisely</html:em> what internal geometrical structure one expects in a given topos for abstract syntax, potentially leading to improved internal languages.</html:p>
            <html:p>For any small category <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>, the category of presheaves <fr:tex display="inline"><![CDATA[\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}\mathscr {C}\right )\mathclose {}}]]></fr:tex> corresponds to the <html:em>classifying topos</html:em> of diagrams of shape <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>. Following <fr:link href="/anel-joyal-2021/" title="Topo-logie" uri="https://www.jonmsterling.com/anel-joyal-2021/" display-uri="anel-joyal-2021" type="local">Anel and Joyal</fr:link>, we shall write <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> for this “affine” classifying topos; under the conventions of <html:em>op. cit.</html:em>, we may then identify the category of sheaves <fr:tex display="inline"><![CDATA[\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> with the presheaf category <fr:tex display="inline"><![CDATA[\operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}{\mathscr {C}}\right )\mathclose {}}]]></fr:tex>.</html:p>
            <html:p>The universal property of <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> as the classifying topos of <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-diagrams means that for any topos <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>, a diagram <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P}}{\operatorname {Sh}{\mathcal {X}}}]]></fr:tex> corresponds essentially uniquely (by left Kan extension) to a morphism of topoi <fr:tex display="inline"><![CDATA[{\mathcal {X}}\xrightarrow {{\bar {P}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>. We have a <html:em>generic <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-shaped diagram</html:em> <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{\mathrm {G}_{\mathscr {C}}}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex> corresponding under this identification to the identity map on <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex>. More explicitly, the diagram <fr:tex display="inline"><![CDATA[\mathrm {G}_{\mathscr {C}}]]></fr:tex> is the following composite:</html:p>
            <fr:tex display="block"><![CDATA[
  \mathrm {G}_{\mathscr {C}} :\equiv  \mathscr {C}\xrightarrow {\eta _\mathscr {C}} \operatorname {\mathbb {L}}\mathscr {C}\xrightarrow {よ_{\mathscr {C}}} \operatorname {Pr}{\mathopen {}\left (\operatorname {\mathbb {L}}\mathscr {C}\right )\mathclose {}} = \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
]]></fr:tex>
            <html:p>Given a morphism of topoi <fr:tex display="inline"><![CDATA[{\mathcal {X}}\xrightarrow {{f}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>, we may recover the diagram <fr:tex display="inline"><![CDATA[\mathscr {C}\to {\operatorname {Sh}{\mathcal {X}}}]]></fr:tex> that it classifies as the composite <fr:tex display="inline"><![CDATA[\mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}\xrightarrow {f^{*}}\operatorname {Sh}{\mathcal {X}}]]></fr:tex>.</html:p>
            <html:p>In case <fr:tex display="inline"><![CDATA[\mathcal {X}\equiv \mathbb {A}^{\mathscr {C}}]]></fr:tex>, then, we have a correspondence between <fr:tex display="inline"><![CDATA[\mathscr {C}]]></fr:tex>-shaped diagrams of sheaves on <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex> and endomorphisms of <fr:tex display="inline"><![CDATA[\mathbb {A}^{\mathscr {C}}]]></fr:tex>; <html:mark>we are interested in representing the compositions of such endomorphisms as a <html:em>tensor product</html:em> on the functor category <fr:tex display="inline"><![CDATA[{\mathopen {}\left  [\mathscr {C},\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}\right  ]\mathclose {}}]]></fr:tex></html:mark>.</html:p>
            <html:p>In particular, let <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P,Q}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex> be two diagrams; taking characteristic maps, we have endomorphisms of affine topoi <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{\bar {P},\bar {Q}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>, which we may compose to obtain <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{\bar {Q}\circ \bar {P}}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex>; then, we will define the tensor <fr:tex display="inline"><![CDATA[P\bullet  Q]]></fr:tex> to be the diagram whose characteristic morphism of affine topoi is <fr:tex display="inline"><![CDATA[\bar {P}\circ \bar {Q}]]></fr:tex>. In other words:</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    P\bullet  Q
    &:\equiv 
    \mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {{\mathopen {}\left (\bar {P}\circ \bar {Q}\right )\mathclose {}}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \\
    &=
    \mathscr {C}\xrightarrow {\mathrm {G}_{\mathscr {C}}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {\bar {P}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
    \xrightarrow {\bar {Q}^{*}}
    \operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}
  \end {aligned}
]]></fr:tex>
            <html:p>To give an explicit computation of the tensor product, we first compute the inverse image of any <fr:tex display="inline"><![CDATA[{\mathbb {A}^{\mathscr {C}}}\xrightarrow {{f}}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> on representables <fr:tex display="inline"><![CDATA[よ_{\mathscr {C}}\Gamma ]]></fr:tex> for <fr:tex display="inline"><![CDATA[\Gamma \in \operatorname {\mathbb {L}}\mathscr {C}]]></fr:tex>. As any left exact functor <fr:tex display="inline"><![CDATA[{\operatorname {\mathbb {L}}\mathscr {C}}\xrightarrow {{H}}{\mathscr {E}}]]></fr:tex> is the right Kan extension of <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{H\circ \eta _\mathscr {C}}}{\mathscr {E}}]]></fr:tex> along <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{\eta _\mathscr {C}}}{\operatorname {\mathbb {L}}\mathscr {C}}]]></fr:tex>, we can conclude that <fr:tex display="inline"><![CDATA[H\Gamma  \cong  \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}H{\mathopen {}\left (\eta _\mathscr {C}{d}\right )\mathclose {}}]]></fr:tex>. We will use this in our calculation below, setting <fr:tex display="inline"><![CDATA[H:\equiv  f^{*}\circ よ_{\mathscr {C}}]]></fr:tex>.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    f^{*}{よ_{\mathscr {C}}\Gamma }
    &\cong 
    \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}
    f^{*}{
      よ_{\mathscr {C}}{\eta _\mathscr {C}{d}}
    }
    \\
    &\cong 
    \operatorname {lim}_{\Gamma \to \eta _\mathscr {C}{d}}
    f^{*}{\mathrm {G}_{\mathscr {C}}{d}}
  \end {aligned}
]]></fr:tex>
            <html:p>We are now prepared to compute the tensor product of any <fr:tex display="inline"><![CDATA[{\mathscr {C}}\xrightarrow {{P,Q}}{\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}}]]></fr:tex>.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}c
    &=
    \bar {Q}^{*}
    \bar {P}^{*}
    \mathrm {G}_{\mathscr {C}}{c}
    \\
    &\cong 
    \bar {Q}^{*}
    {\mathopen {}\left (Pc\right )\mathclose {}}
    \\
    &\cong 
    \bar {Q}^{*}
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    よ_{\mathscr {C}}\Delta 
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \bar {Q}^{*}よ_{\mathscr {C}}\Delta 
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    \bar {Q}^{*}\mathrm {G}_{\mathscr {C}}d
    \\
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    Qd
  \end {aligned}
]]></fr:tex>
            <html:p>Finally, we can relate the computation above to that of <fr:link href="/fiore-2008/" title="Second-order and dependently-sorted abstract syntax" uri="https://www.jonmsterling.com/fiore-2008/" display-uri="fiore-2008" type="local">Fiore</fr:link> in terms of coends.</html:p>
            <fr:tex display="block"><![CDATA[
  \begin {aligned}
    {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}\,c
    &\cong 
    \operatorname {colim}_{よ_{\mathscr {C}}\Delta \to  Pc}
    \operatorname {lim}_{\Delta \to  \eta _\mathscr {C}{d}}
    Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    {\mathopen {}\left  [よ_{\mathscr {C}}\Delta ,Pc\right  ]\mathclose {}}
    \cdot 
    \operatorname {lim}_{\Delta \to \eta _\mathscr {C}{d}} Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \cdot 
    \operatorname {lim}_{\Delta \to \eta _\mathscr {C}{d}} Qd
    \\
    &\cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \cdot 
    \int _{c\in \mathscr {C}}
    {\mathopen {}\left  [\Delta ,\eta _\mathscr {C}{d}\right  ]\mathclose {}}\pitchfork  Qd
  \end {aligned}
]]></fr:tex>
            <html:p>Above, we have written <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\cdot \right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\pitchfork \right )\mathclose {}}]]></fr:tex> for the tensoring and cotensoring of <fr:tex display="inline"><![CDATA[\operatorname {Sh}{\mathbb {A}^{\mathscr {C}}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> respectively. Thus, the fully pointwise computation is as follows:</html:p>
            <fr:tex display="block"><![CDATA[
  {\mathopen {}\left (P\bullet  Q\right )\mathclose {}}\,c\,\Gamma  \cong 
    \int ^{\Delta \in \operatorname {\mathbb {L}}\mathscr {C}}
    P\,c\,\Delta 
    \times 
    \int _{c\in \mathscr {C}}
    {\mathopen {}\left  [\Delta ,\eta _\mathscr {C}{d}\right  ]\mathclose {}}\Rightarrow  Q\,d\,\Gamma 
]]></fr:tex>
            <html:p>
              <html:em>Thanks to <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link> and <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> for helpful discussions.</html:em>
            </html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jms-00GC/</fr:uri>
            <fr:display-uri>jms-00GC</fr:display-uri>
            <fr:route>/jms-00GC/</fr:route>
            <fr:title text="Aarhus University">Aarhus University</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="external">https://www.au.dk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonathanweinberger/" title="Jonathan Weinberger" uri="https://www.jonmsterling.com/jonathanweinberger/" display-uri="jonathanweinberger" type="local">Jonathan Weinberger</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/ulrikbuchholtz/" title="Ulrik Buchholtz" uri="https://www.jonmsterling.com/ulrikbuchholtz/" display-uri="ulrikbuchholtz" type="local">Ulrik Buchholtz</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-weinberger-buchholtz-2025/</fr:uri>
            <fr:display-uri>gratzer-weinberger-buchholtz-2025</fr:display-uri>
            <fr:route>/gratzer-weinberger-buchholtz-2025/</fr:route>
            <fr:title text="The Yoneda embedding in simplicial type theory">The Yoneda embedding in simplicial type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">To appear, <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link></fr:meta>
            <fr:meta name="external">https://www.danielgratzer.com/papers/the-yoneda-embedding-in-simplicial-type-theory.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>9</fr:month>
              <fr:day>4</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2024-cmu-hott/</fr:uri>
            <fr:display-uri>sterling-2024-cmu-hott</fr:display-uri>
            <fr:route>/sterling-2024-cmu-hott/</fr:route>
            <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit technique to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> presented an elegant functorial analysis of this construction in terms of the <html:em>‘categorical nerve’</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, applying the categorical nerve to the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting.</html:p>
            <html:p>Although <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> has investigated Hofmann–Streicher lifting in terms of a 1-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐏𝐫</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math>, his analysis can be extended to a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that is observed by <fr:link href="/weber-2007/" title="Yoneda structures from 2-toposes" uri="https://www.jonmsterling.com/weber-2007/" display-uri="weber-2007" type="local">Weber</fr:link> to be right 2-adjoint to the 2-functor that takes a fibred category to its total category (i.e. the oplax colimit of the corresponding diagram of categories under straightening). A generalised form of Hofmann–Streicher lifting that can be applied to categories other than universes is then obtained by conjugating this right 2-adjoint with duality involutions.</html:p>
            <html:p>In joint work with <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> and <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>, we have constructed a <html:em>relative</html:em> version of the 2-functorial Hofmann–Streicher lifting: given a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>, we have a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Δ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> which is <html:em>not</html:em> base change but rather (we conjecture) right <html:em>pseudo</html:em>-adjoint to the 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Σ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that sends a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi></mml:mrow></mml:math> to the composite fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">∘</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi></mml:mrow><mml:mo lspace=".2em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>. A relative version of Hofmann–Streicher lifting could give a more regular theory to the practice of computing <html:em>internal</html:em> liftings of lifted universes.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>24</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>5</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2024-universes/</fr:uri>
            <fr:display-uri>gratzer-shulman-sterling-2024-universes</fr:display-uri>
            <fr:route>/gratzer-shulman-sterling-2024-universes/</fr:route>
            <fr:title text="Strict universes for Grothendieck topoi">Strict universes for Grothendieck topoi</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2024-universes,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2024},
  month = may,
  doi = {10.48550/arXiv.2202.12012},
  eprint = {2202.12012},
  eprintclass = {math.CT},
  eprinttype = {arXiv},
  note = {Unpublished manuscript},
  title = {Strict universes for Grothendieck topoi},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.12012</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> famously showed how to lift Grothendieck universes into presheaf topoi, and <fr:link href="/streicher-2005/" title="Universes in toposes" uri="https://www.jonmsterling.com/streicher-2005/" display-uri="streicher-2005" type="local">Streicher</fr:link> has extended their result to the case of sheaf topoi by
sheafification. In parallel, <fr:link href="/van-den-berg-moerdijk-2012/" title="Aspects of predicative algebraic set theory III: sheaves" uri="https://www.jonmsterling.com/van-den-berg-moerdijk-2012/" display-uri="van-den-berg-moerdijk-2012" type="local">van den Berg and Moerdijk</fr:link> have shown in the context of algebraic set theory that similar constructions continue to apply even in weaker metatheories. Unfortunately, sheafification seems not to preserve an important <html:em>realignment</html:em> property enjoyed by presheaf universes that plays a critical role in models of univalent type theory as well as <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link>. When <html:em>multiple</html:em> universes are present, realignment also implies a coherent interpretation of connectives across all universes that justifies the cumulativity laws present in popular formulations of Martin-Löf type theory.</html:p>
            <html:p>We observe that a slight adjustment to an argument of <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link> constructs a cumulative universe hierarchy satisfying the realignment property at every level in any Grothendieck topos. Hence one has direct-style interpretations of Martin-Löf type theory with cumulative universes into all Grothendieck topoi. A further implication is to extend the reach of recent synthetic methods in the semantics of cubical type theory and the syntactic metatheory of type theory and programming languages to all Grothendieck topoi.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>2</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route>
            <fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link>
            </fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>29</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-2023-thesis/</fr:uri>
            <fr:display-uri>gratzer-2023-thesis</fr:display-uri>
            <fr:route>/gratzer-2023-thesis/</fr:route>
            <fr:title text="Syntax and semantics of modal type theory">Syntax and semantics of modal type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">PhD Dissertation, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
            <fr:meta name="external">https://iris-project.org/pdfs/2023-phd-gratzer.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>One idiosyncratic framing of type theory is as the study of operations invariant under substitution. Modal type theory, by contrast, concerns the controlled integration of operations—modalities—into type theory which violate this discipline, so-called <html:em>non-fibered connectives</html:em>. Modal type theory is therefore built around a fundamental tension: the desire to include modalities and powerful principles for reasoning with them on one hand, and the need to maintain the conveniences and character of Martin-Löf type theory which stem from substitution invariance.</html:p>
            <html:p>In this thesis, we thoroughly explore and discuss this contradiction. We discuss several different formulations of modal type theory, explore their various syntactic properties, and relate them through their categorical semantics. In particular, we show that most modal type theories that have arisen in the last two decades can be understood through the abstraction of <html:em>weak dependent right adjoints</html:em>. We also put forward a new <html:em>general</html:em> modal type theory, MTT, based on this abstraction.</html:p>
            <html:p>The generality of MTT means that, without any additional work, it can be specialized to an arbitrary collection of type theories related by modalities and natural transformations between them. It is therefore easy to obtain a type theory for a comonad, an adjunction, a local topos, or any other number of complex and realistic scenarios. In addition to showing that many modal type theories are closely related to specific instantiations of MTT, we thoroughly explore the syntax and semantics of MTT itself. We prove that MTT enjoys an unconditional normalization result and decidable type-checking under mild assumptions. We show how MTT may be interpreted into a wide variety of structured categories and use this to study the expressive power of the type theory and various extensions thereof.</html:p>
            <html:p>Finally, we explore several concrete applications of MTT in the context of guarded type theory and guarded denotational semantics. We propose a highly usable language for guarded recursion and explore its particular models and metatheorems. We show a relatively sharp result bounding the extent to which classical guarded recursion can be added to any type theory with decidable type-checking and propose a system to mitigate this issue. Finally, we conduct an in-depth case study using guarded MTT to obtain a fully synthetic account of the Iris program logic, proving adequacy in a fully internal manner.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route>
            <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta>
            <fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri>
            <fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri>
            <fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route>
            <fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2022/</fr:route>
            <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link>
              </fr:author>
              <fr:author>Magnus Baunsgaard Kristensen</fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>6</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/akgb-2022/</fr:uri>
            <fr:display-uri>akgb-2022</fr:display-uri>
            <fr:route>/akgb-2022/</fr:route>
            <fr:title text="Unifying cubical and multimodal type theory">Unifying cubical and multimodal type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{akgb-2022,
  author = {Aagaard, Frederik Lerbjerg and Kristensen, Magnus Baunsgaard and Gratzer, Daniel and Birkedal, Lars},
  publisher = {arXiv},
  year = {2022},
  doi = {10.48550/ARXIV.2203.13000},
  note = {Unpublished manuscript},
  title = {Unifying cubical and multimodal type theory},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/ARXIV.2203.13000</fr:meta>
            <fr:meta name="venue">28th International Conference on Types for Proofs and Programs</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-birkedal-2022/</fr:uri>
            <fr:display-uri>gratzer-birkedal-2022</fr:display-uri>
            <fr:route>/gratzer-birkedal-2022/</fr:route>
            <fr:title text="A stratified approach to Löb induction">A stratified approach to Löb induction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{gratzer-birkedal-2022,
  author = {Gratzer, Daniel and Birkedal, Lars},
  editor = {Felty, Amy},
  address = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  url = {https://jozefg.github.io/papers/a-stratified-approach-to-lob-induction.pdf},
  booktitle = {7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)},
  year = {2022},
  month = aug,
  doi = {10.4230/LIPIcs.FSCD.2022.23},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {A Stratified Approach to {L\"{o}b} Induction},
  volume = {228},
}]]></fr:meta>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.23</fr:meta>
            <fr:meta name="venue">International Conference on Formal Structures for Computation and Deduction (FSCD)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-2022/</fr:uri>
            <fr:display-uri>gratzer-2022</fr:display-uri>
            <fr:route>/gratzer-2022/</fr:route>
            <fr:title text="Normalization for multimodal type theory">Normalization for multimodal type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{gratzer-2022,
  title = {Normalization for Multimodal Type Theory},
  author = {Gratzer, Daniel},
  address = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  booktitle = {Proceedings of the 37th Annual ACM/IEEE Symposium on Logic in Computer Science},
  year = {2022},
  doi = {10.1145/3531130.3532398},
  url = {https://jozefg.github.io/papers/2022-normalization-for-multimodal-type-theory-short.pdf},
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3531130.3532398</fr:meta>
            <fr:meta name="venue">Symposium on Logic and Computer Science (LICS)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2022-plump/</fr:uri>
            <fr:display-uri>gratzer-shulman-sterling-2022-plump</fr:display-uri>
            <fr:route>/gratzer-shulman-sterling-2022-plump/</fr:route>
            <fr:title text="The directed plump ordering">The directed plump ordering</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2022-plump,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2022},
  doi = {10.48550/arXiv.2202.07329},
  eprint = {2202.07329},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {The directed plump ordering},
}]]></fr:meta>
            <fr:meta name="artifact">https://www.jonmsterling.com/agda-directed-plump-ordering/</fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.07329</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Based on Taylor's hereditarily directed plump ordinals, we define the <html:em>directed plump ordering</html:em> on W-types in Martin-Löf type theory. This ordering is similar to the plump ordering but comes equipped with non-empty finite joins in additional to the usual properties of the plump ordering.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2022/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2022</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2022/</fr:route>
            <fr:title text="A cubical language for Bishop sets">A cubical language for Bishop sets</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{sterling-angiuli-gratzer-2022,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  year = {2022},
  month = mar,
  doi = {10.46298/lmcs-18(1:43)2022},
  eprint = {2003.01491},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  issue = {1},
  journal = {Logical Methods in Computer Science},
  title = {{A Cubical Language for Bishop Sets}},
  volume = {18},
}]]></fr:meta>
            <fr:meta name="doi">10.46298/lmcs-18(1:43)2022</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/lmcs/" title="Logical Methods in Computer Science" uri="https://www.jonmsterling.com/lmcs/" display-uri="lmcs" type="local">Logical Methods in Computer Science</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present XTT, a version of Cartesian cubical type theory specialized for Bishop sets à la <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link>, in which every type enjoys a definitional version of the uniqueness of identity proofs. Using cubical notions, XTT reconstructs many of the ideas underlying Observational Type Theory, a version of intensional type theory that supports function extensionality. We prove the canonicity property of XTT (that every closed boolean is definitionally equal to a constant) by Artin gluing.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-2021-crisp-induction/</fr:uri>
            <fr:display-uri>gratzer-2021-crisp-induction</fr:display-uri>
            <fr:route>/gratzer-2021-crisp-induction/</fr:route>
            <fr:title text="Crisp induction for intensional identity types">Crisp induction for intensional identity types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">https://jozefg.github.io/papers/crisp-induction-for-intensional-identity-types.pdf</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-2021-crisp-induction,
  author = {Gratzer, Daniel},
  url = {https://jozefg.github.io/papers/crisp-induction-for-intensional-identity-types.pdf},
  year = {2021},
  note = {Unpublished manuscript},
  title = {Crisp induction for intensional identity types},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>12</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-2020/</fr:uri>
            <fr:display-uri>gratzer-sterling-2020</fr:display-uri>
            <fr:route>/gratzer-sterling-2020/</fr:route>
            <fr:title text="Syntactic categories for dependent type theory: sketching and adequacy">Syntactic categories for dependent type theory: sketching and adequacy</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-2020,
  author = {Gratzer, Daniel and Sterling, Jonathan},
  year = {2020},
  eprint = {2012.10783},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {Syntactic categories for dependent type theory: sketching and adequacy},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We argue that locally Cartesian closed categories form a suitable doctrine for defining dependent type theories, including non-extensional ones. Using the theory of sketches, one may define syntactic categories for type theories in a style that resembles the use of Martin-Löf's Logical Framework, following the "judgments as types" principle. The concentration of type theories into their locally Cartesian closed categories of judgments is particularly convenient for proving syntactic metatheorems by semantic means (canonicity, normalization, etc.). Perhaps surprisingly, the notion of a context plays no role in the definitions of type theories in this sense, but the structure of a class of display maps can be imposed on a theory post facto wherever needed, as advocated by the Edinburgh school and realized by the <html:code>worlds</html:code> declarations of the Twelf proof assistant.</html:p>
            <html:p>Uemura has proposed representable map categories together with a stratified logical framework for similar purposes. The stratification in Uemura's framework restricts the use of dependent products to be strictly positive, in contrast to the tradition of Martin-Löf's logical framework and Schroeder-Heister's analysis of higher-level deductions. We prove a semantic adequacy result for locally Cartesian closed categories relative to Uemura's representable map categories: if a theory is definable in the framework of Uemura, the locally Cartesian closed category that it generates is a conservative (fully faithful) extension of its syntactic representable map category. On this basis, we argue for the use of locally Cartesian closed categories as a simpler alternative to Uemura's representable map categories.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-hott/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019-hott</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019-hott/</fr:route>
            <fr:title text="Cubical exact equality and categorical gluing">Cubical exact equality and categorical gluing</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmih2orgei2hellqbaqzwubjlulc2osk46d4s7dpkazlxzgt3oe77n4.pdf</fr:meta>
            <fr:meta name="venue">International Conference on Homotopy Type Theory, 2019</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory which extends intensional type theory with a dependent equality type that enjoys function extensionality and judgmental unicity of identity proofs. XTT employs a variant of the Cartesian cubical Kan operations satisfying regularity (i.e., transport in constant type families is judgmentally constant), allowing its equality type to model Martin-Lof’s identity type judgmentally. We prove canonicity for the initial model of XTT (i.e., any closed term of boolean type is equal to either true or false) using a novel cubical extension (independently proposed by <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Awodey</fr:link>) of the categorical gluing technique inspired by <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link> and <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Shulman</fr:link>, in which we glue the fundamental fibration of a category of augmented Cartesian cubical sets along a cubical nerve. We conjecture that our methods will extend to open terms, allowing us to establish normalization and decidability of the typing relation.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019/</fr:route>
            <fr:title text="Cubical syntax for reflection-free extensional equality">Cubical syntax for reflection-free extensional equality</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-angiuli-gratzer-2019,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  editor = {Geuvers, Herman},
  location = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/10538},
  booktitle = {Proceedings of the 4th International Conference on Formal Structures for Computation and Deduction (FSCD 2019)},
  date = {2019},
  doi = {10.4230/LIPIcs.FSCD.2019.31},
  eprint = {1904.08562},
  eprinttype = {arXiv},
  isbn = {978-3-95977-107-8},
  issn = {1868-8969},
  pages = {31:1--31:25},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {Cubical Syntax for Reflection-Free Extensional Equality},
  volume = {131},
}]]></fr:meta>
            <fr:meta name="slides">/bafkrmicj5w5dosexdar6vzylw5hykvpeqrydvy4cp6llywqf7auioli4fu.pdf</fr:meta>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2019.31</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/fscd-2019/" title="FSCD ’19: International Conference on Formal Structures for Computation and Deduction" uri="https://www.jonmsterling.com/fscd-2019/" display-uri="fscd-2019" type="local"><html:em>FSCD ’19</html:em>: International Conference on Formal Structures for Computation and Deduction</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory [Altenkirch et al., 2007] which extends Martin-Löf's intensional type theory with a dependent equality type that enjoys function extensionality and a judgmental version of the unicity of identity proofs principle (UIP): any two elements of the same equality type are judgmentally equal. Moreover, we conjecture that the typing relation can be decided in a practical way. In this paper, we establish an algebraic canonicity theorem using a novel extension of the logical families or categorical gluing argument inspired by <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> and <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link>: every closed element of boolean type is derivably equal to either true or false.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-birkedal-2019/</fr:uri>
            <fr:display-uri>gratzer-sterling-birkedal-2019</fr:display-uri>
            <fr:route>/gratzer-sterling-birkedal-2019/</fr:route>
            <fr:title text="Implementing a modal dependent type theory">Implementing a modal dependent type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{gratzer-sterling-birkedal-2019,
  author = {Gratzer, Daniel and Sterling, Jonathan and Birkedal, Lars},
  location = {New York, NY, USA},
  publisher = {ACM},
  date = {2019-07},
  doi = {10.1145/3341711},
  issn = {2475-1421},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  keywords = {Modal types,dependent types,normalization by evaluation,type-checking},
  number = {ICFP},
  pages = {107:1--107:29},
  title = {Implementing a Modal Dependent Type Theory},
  volume = {3},
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3341711</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/icfp-2019/" title="ICFP ’19: The 24th ACM SIGPLAN International Conference on Functional Programming" uri="https://www.jonmsterling.com/icfp-2019/" display-uri="icfp-2019" type="local"><html:em>ICFP ’19</html:em>: The 24th ACM SIGPLAN International Conference on Functional Programming</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Modalities are everywhere in programming and mathematics! Despite this, however, there are still significant technical challenges in formulating a core dependent type theory with modalities. We present a dependent type theory MLTT🔒 supporting the connectives of standard Martin-Löf Type Theory as well as an S4-style necessity operator. MLTT🔒 supports a smooth interaction between modal and dependent types and provides a common basis for the use of modalities in programming and in synthetic mathematics. We design and prove the soundness and completeness of a type checking algorithm for MLTT🔒, using a novel extension of normalization by evaluation. We have also implemented our algorithm in a prototype proof assistant for MLTT🔒, demonstrating the ease of applying our techniques.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-types/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019-types</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019-types/</fr:route>
            <fr:title text="XTT: cubical syntax for extensional equality (without equality reflection)">XTT: cubical syntax for extensional equality (without equality reflection)</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmifuhsbmtkvovprpvqpzzeg63w6bp46g73yb6nz53l2wnslrumnkaa.pdf</fr:meta>
            <fr:meta name="venue">TYPES 2019</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>
