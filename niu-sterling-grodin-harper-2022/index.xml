<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2022</fr:year>
      <fr:month>1</fr:month>
      <fr:day>1</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/</fr:uri>
    <fr:display-uri>niu-sterling-grodin-harper-2022</fr:display-uri>
    <fr:route>/niu-sterling-grodin-harper-2022/</fr:route>
    <fr:title text="A cost-aware logical framework">A cost-aware logical framework</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 6, Issue POPL</fr:meta>
    <fr:meta name="doi">10.1145/3498670</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants.</html:p>
    <html:p>We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist’s method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid’s algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri>
            <fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri>
            <fr:route>/grodin-niu-sterling-harper-2024/</fr:route>
            <fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link>
            </fr:meta>
            <fr:meta name="doi">10.1145/3632852</fr:meta>
            <fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p>
            <html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri>
                <fr:display-uri>jms-012Q</fr:display-uri>
                <fr:route>/jms-012Q/</fr:route>
                <fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>6</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/harper-2023-calco-mfps/</fr:uri>
            <fr:display-uri>harper-2023-calco-mfps</fr:display-uri>
            <fr:route>/harper-2023-calco-mfps/</fr:route>
            <fr:title text="Integrating cost and behavior in type theory">Integrating cost and behavior in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">http://www.cs.cmu.edu/~rwh/talks/calco-mfps-2023.pdf</fr:meta>
            <fr:meta name="venue"> Plenary invited lecture for CALCO/MFPS 2023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Joint work with <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link> (Carnegie Mellon), <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> (Carnegie Mellon), and <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> (Cambridge).</html:p>
            <html:p>The computational view of intuitionistic dependent type theory is as an intrinsic logic of (functional) programs in which types are viewed as specifications of their behavior. Equational reasoning is particularly relevant in the functional case, where correctness can be formulated as equality between two implementations of the same behavior. Besides behavior, it is also important to specify and verify the cost of programs, measured in terms of their resource usage, with respect to both sequential and parallel evaluation. Although program cost can—and has been—verified in type theory using an extrinsic formulation of programs as data objects, what we seek here is, instead, an intrinsic account within type theory itself.</html:p>
            <html:p>In this talk we discuss Calf, the <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Cost-Aware Logical Framework</fr:link>, which is an extension of dependent call-by-push-value type theory that provides an intrinsic account of both parallel and sequential resource usage for a variety of problem-specific measures of cost. Thus, for example, it is possible to prove that insertion sort and merge sort are equal as regards behavior, but differ in terms of the number of comparisons required to achieve the same results. But how can equal functions have different cost? To provide an intrinsic account of both intensional and extensional properties of programs, we make use of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">Sterling's notion of Synthetic Tait Computability</fr:link>, a generalization of Tait's method originally developed for the study of higher type theory. In STC the concept of a “phase” plays a central role: originally as the distinction between the syntactic and semantic aspects of a computability structure, but more recently applied to the formulation of type theories for program modules and for information flow properties of programs. In Calf we distinguish two phases, the intensional and extensional, which differ as regards the significance of cost accounting—extensionally it is neglected, intensionally it is of paramount importance. Thus, in the extensional phase insertion sort and merge sort are equal, but in the intensional phase they are distinct, and indeed one is proved to have optimal behavior as regards comparisons, and the other not. Importantly, both phases are needed in a cost verification—the proof of the complexity of an algorithm usually relies on aspects of its correctness.</html:p>
            <html:p>We will provide an overview of Calf itself, and of its application in the verification of the cost and behavior of a variety of programs. So far we have been able to verify cost bounds on Euclid's Algorithm, amortized bounds on batched queues, parallel cost bounds on a joinable form of red-black trees, and the equivalence and cost of the aforementioned sorting methods. In a <fr:link href="/grodin-harper-2023-calco/" title="Amortized analysis via coinduction" uri="https://www.jonmsterling.com/grodin-harper-2023-calco/" display-uri="grodin-harper-2023-calco" type="local">companion paper</fr:link> at this meeting <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Grodin</fr:link> and I develop an account of amortization that relates the standard inductive view of instruction sequences with the coinductive view of data structures characterized by the same operations. In ongoing work we are extending the base of verified deterministic algorithms to those taught in the undergraduate parallel algorithms course at Carnegie Mellon, and are extending Calf itself to account for probabilistic methods, which are also used in that course.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>6</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/grodin-harper-2023-calco/</fr:uri>
            <fr:display-uri>grodin-harper-2023-calco</fr:display-uri>
            <fr:route>/grodin-harper-2023-calco/</fr:route>
            <fr:title text="Amortized analysis via coinduction">Amortized analysis via coinduction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">https://coalg.org/calco-mfps-2023/slides/grodin-slides-calco23.pdf</fr:meta>
            <fr:meta name="venue">CALCO 2023</fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2303.16048</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Amortized analysis is a program cost analysis technique for data structures in which the cost of operations is specified in aggregate, under the assumption of continued sequential use. Typically, amortized analyses are done inductively, in terms of finite sequences of operations; we demonstrate that coinduction provides a more natural description. We describe a classic amortized data structure, the batched queue, and describe its amortized analysis in <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">calf</fr:link>, a type theory for amortized analysis.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-001B/</fr:uri>
            <fr:display-uri>jms-001B</fr:display-uri>
            <fr:route>/jms-001B/</fr:route>
            <fr:title text="§ 8.2: type refinements and program extraction">§ 8.2: type refinements and program extraction</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The modal language of synthetic Tait computability promises a new and more abstract account of <html:em>refinement types</html:em> and <html:em>program extraction</html:em> via a phase distinction between <html:em>computation</html:em> and <html:em>specification</html:em>. Refinement types are often thought of as a kind of subtype, but there is a fundamental difference: when <fr:tex display="inline"><![CDATA[{\phi }\sqsubset {A}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\psi }\sqsubset {B}]]></fr:tex> are refinements of types <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> respectively, then <fr:tex display="inline"><![CDATA[\phi \to \psi ]]></fr:tex> refines <fr:tex display="inline"><![CDATA[A\to  B]]></fr:tex>. In contrast, subtyping laws for function spaces are contravariant in the domain. The refinements available in synthetic Tait computability are moreover proof-relevant in the sense that specification-level code can contain data in addition to properties. The application to proof-relevant refinement types is employed by <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu, Sterling, Grodin, and Harper</fr:link> to develop a logical framework for simultaneously verifying behavior and complexity of functional programs.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2022/</fr:uri>
            <fr:display-uri>sterling-harper-2022</fr:display-uri>
            <fr:route>/sterling-harper-2022/</fr:route>
            <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.5</fr:meta>
            <fr:meta name="venue">7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We propose a new sheaf semantics for secure information flow over a space of abstract behaviors, based on synthetic domain theory: security classes are open/closed partitions, types are sheaves, and redaction of sensitive information corresponds to restricting a sheaf to a closed subspace. Our security-aware computational model satisfies termination-insensitive noninterference automatically, and therefore constitutes an intrinsic alternative to state of the art extrinsic/relational models of noninterference. Our semantics is the latest application of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s recent re-interpretation of phase distinctions and noninterference in programming languages in terms of Artin gluing and topos-theoretic open/closed modalities. Prior applications include <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">parametricity for ML modules</fr:link>, the proof of normalization for cubical type theory by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link>, and the cost-aware logical framework of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu et al</fr:link>. In this paper we employ the phase distinction perspective twice: first to reconstruct the syntax and semantics of secure information flow as a lattice of phase distinctions between “higher” and “lower” security, and second to verify the computational adequacy of our sheaf semantics with respect to a version of Abadi et al.’s dependency core calculus to which we have added a construct for declassifying termination channels.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Y/</fr:uri>
                <fr:display-uri>jms-005Y</fr:display-uri>
                <fr:route>/jms-005Y/</fr:route>
                <fr:title text="Minor mistakes in sheaf semantics of noninterference">Minor mistakes in <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In the published version of this paper, there were a few mistakes that have been corrected in the local copy hosted here.</html:p>
                <html:ol><html:li>In the <html:em>Critique of relational semantics for information flow</html:em>, our discussion of the <html:em>Failure of monotonicity</html:em> stated incorrectly that algebras for the sealing monad at a higher security level could not be transformed into algebras for the sealing monad at a lower security level in the semantics of Abadi et al. This is not true, as pointed out to us privately by Carlos Tomé Cortiñas. What we meant to say was that it is not the case that a type whose component at a high security level is trivial shall always remain trivial at a lower security level.</html:li>
  <html:li>The original version of the extended edition of this paper, we claimed that the constructive existence of tensor products on pointed dcpos was obvious; in fact, tensor products do exist, but their construction involves a reflexive coequalizer of pointed dcpos.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                <fr:display-uri>jms-005Z</fr:display-uri>
                <fr:route>/jms-005Z/</fr:route>
                <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/pacmpl/</fr:uri>
            <fr:display-uri>pacmpl</fr:display-uri>
            <fr:route>/pacmpl/</fr:route>
            <fr:title text="Proceedings of the ACM on Programming Languages">Proceedings of the ACM on Programming Languages</fr:title>
            <fr:taxon>Journal</fr:taxon>
            <fr:meta name="external">https://dl.acm.org/journal/pacmpl</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><html:em>Proceedings of the ACM on Programming Languages</html:em> (PACMPL) is a Gold Open Access journal publishing research on all aspects of programming languages, from design to implementation and from mathematical formalisms to empirical studies. Each issue of the journal is devoted to a particular subject area within programming languages and will be announced through publicized Calls for Papers. All accepted papers receive two rounds of reviewing and authors can expect initial decisions regarding submissions in under 3 months. The journal operates in close collaboration with the Special Interest Group on Programming Languages (SIGPLAN) and is committed to making high-quality peer-reviewed scientific research in programming languages free of restrictions on both access and use.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
