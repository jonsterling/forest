<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>11</fr:month>
      <fr:day>23</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri>
    <fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri>
    <fr:route>/aagaard-sterling-birkedal-2023/</fr:route>
    <fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="doi">10.46298/entics.12232</fr:meta>
    <fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2022/</fr:route>
            <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0079/</fr:uri>
            <fr:display-uri>jms-0079</fr:display-uri>
            <fr:route>/jms-0079/</fr:route>
            <fr:title text="Equational higher-order separation logic for higher-order store">Equational higher-order separation logic for higher-order store</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In collaboration with my colleagues <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Ljerbjerg Aagaard</fr:link> and <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>, I have developed a <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">guarded higher-order separation logic called TULIP</fr:link> over the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational model of higher-order store</fr:link>. This logic represents a significant step forward in the march toward simple, abstract, and compositional reasoning about higher-order stateful programs. Prior program logics (such as Iris and the Verified Software Toolchain) interact with computer programs only indirectly, by verifying properties of a specific “transition function” that simulates the steps that a (highly idealized) computer would take when executing a program; this style is called “operational”. Unfortunately, the important structural properties of programs are highly unnatural to express at the level of transition steps, and as such, existing operationally-based program logics impose a great deal of bureaucracy by forcing those verifying programs to manually mediate the mismatch between the viewpoint of the machine (which cannot see program structure), and the viewpoint of the programmer (which is entirely based on program structure). An equational, or "denotationally-based", program logic like <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> instead treats programs directly without needing to pass through an encoding in terms of machine transitions. An immediate benefit of the equational approach is that program equivalences can be glued together directly in any context, a kind of practical compositionality that is unique to equational and denotationally-based program logics. Our development of the <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> logic is a strong first step in this direction.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
