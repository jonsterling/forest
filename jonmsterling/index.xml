<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri>
    <fr:display-uri>jonmsterling</fr:display-uri>
    <fr:route>/jonmsterling/</fr:route>
    <fr:title text="Jon Sterling">Jon Sterling</fr:title>
    <fr:taxon>Person</fr:taxon>
    <fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta>
    <fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta>
    <fr:meta name="orcid">0000-0002-0585-5564</fr:meta>
    <fr:meta name="position">Associate Professor</fr:meta>
    <fr:meta name="phd-advisor">robertharper</fr:meta>
    <fr:meta name="postdoc-advisor">larsbirkedal</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
    <html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/ianleslie/" title="Ian Leslie" uri="https://www.jonmsterling.com/ianleslie/" display-uri="ianleslie" type="local">Ian Leslie</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-018I/</fr:uri>
            <fr:display-uri>jms-018I</fr:display-uri>
            <fr:route>/jms-018I/</fr:route>
            <fr:title text="Lecture 24: the pumping lemma">Lecture 24: the pumping lemma</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> by adapting prior notes created by <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link> that I inherited from <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>.</html:p>
            <html:p>In <fr:link href="/jms-0174/" title="Lecture 21: regular expressions and pattern matching" uri="https://www.jonmsterling.com/jms-0174/" display-uri="jms-0174" type="local">Lecture 21</fr:link>, we <fr:link href="/jms-017F/" title="Questions about regular expression matching" uri="https://www.jonmsterling.com/jms-017F/" display-uri="jms-017F" type="local">asked ourselves several questions</fr:link> concerning <fr:link href="/jms-017C/" title="Regular expression matching" uri="https://www.jonmsterling.com/jms-017C/" display-uri="jms-017C" type="local">regular expression matching</fr:link>. We have answered three of those questions in <fr:link href="/jms-017X/" title="Lecture 23: regular languages and Kleene’s theorem" uri="https://www.jonmsterling.com/jms-017X/" display-uri="jms-017X" type="local">Lecture 23</fr:link> by means of <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>, which proves <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expressions</fr:link> and <fr:link href="/jms-017J/" title="Kinds of finite automata" uri="https://www.jonmsterling.com/jms-017J/" display-uri="jms-017J" type="local">finite automata</fr:link> generate the same class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link>. Today’s lecture will provide evidence for our response to the final question, that not every <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is going to be <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. The theorem that we will use to verify <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">non-regularity</fr:link> for our counterexamples is (annoyingly) called <html:em><html:strong>the pumping lemma</html:strong></html:em>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018J/</fr:uri>
                <fr:display-uri>jms-018J</fr:display-uri>
                <fr:route>/jms-018J/</fr:route>
                <fr:title text="Some non-regular languages">Some non-<fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link></fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The following <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link> will turn out to non-<fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>:</html:p>
                <html:ol><html:li>The set of strings over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{(,),a,b,\ldots ,z\right \}\mathclose {}}]]></fr:tex> in which parentheses are well-nested.</html:li>
 <html:li>The set of strings over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a,b,\ldots ,z\right \}\mathclose {}}]]></fr:tex> that are <html:em>palindromes</html:em>, i.e. that read the same backwards as forwards.</html:li>
 <html:li>The set of strings over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> consisting of some number of <fr:tex display="inline"><![CDATA[a]]></fr:tex>s followed by the <html:em>same</html:em> number of <fr:tex display="inline"><![CDATA[b]]></fr:tex>s.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018K/</fr:uri>
                <fr:display-uri>jms-018K</fr:display-uri>
                <fr:route>/jms-018K/</fr:route>
                <fr:title text="Pumping bracket">Pumping bracket</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[L]]></fr:tex> be a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. A <html:em><html:strong>pumping bracket</html:strong></html:em> in <fr:tex display="inline"><![CDATA[L]]></fr:tex> is defined to be a tuple of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (u_1,v,u_2\right )\mathclose {}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> with <fr:tex display="inline"><![CDATA[v\not = \epsilon ]]></fr:tex> such that for any <fr:tex display="inline"><![CDATA[n\geq  0]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[u_1 v^n u_2\in  L]]></fr:tex>.</html:p>
                <html:p>We will refer to the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u_1vu_2\in  L]]></fr:tex> as the <html:em><html:strong>concatenation</html:strong></html:em> of a pumping bracket <fr:tex display="inline"><![CDATA[{\mathopen {}\left (u_1,v,u_2\right )\mathclose {}}]]></fr:tex>. We will refer to <fr:tex display="inline"><![CDATA[u_1v\in  \Sigma ^\star ]]></fr:tex> as the <html:em><html:strong>left-hand component</html:strong></html:em> of the pumping bracket.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018L/</fr:uri>
                <fr:display-uri>jms-018L</fr:display-uri>
                <fr:route>/jms-018L/</fr:route>
                <fr:title text="The pumping property">The pumping property</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[L]]></fr:tex> be a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. A number <fr:tex display="inline"><![CDATA[\ell >1]]></fr:tex> is said to have the <html:em><html:strong>pumping property</html:strong></html:em> with respect to <fr:tex display="inline"><![CDATA[L]]></fr:tex> when any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[w\in  L]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert w\right \rvert \mathclose {}}\geq  \ell ]]></fr:tex> is the <fr:link href="/jms-018K/" title="Pumping bracket" uri="https://www.jonmsterling.com/jms-018K/" display-uri="jms-018K" type="local">concatenation</fr:link> of some <fr:link href="/jms-018K/" title="Pumping bracket" uri="https://www.jonmsterling.com/jms-018K/" display-uri="jms-018K" type="local">pumping bracket</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (u_1,v,u_2\right )\mathclose {}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[L]]></fr:tex> whose left-hand component <fr:tex display="inline"><![CDATA[u_1v]]></fr:tex> has length less than or equal to <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex>.</html:p>
                <html:p>In other words, <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> has the pumping property when for all <fr:tex display="inline"><![CDATA[w\in  L]]></fr:tex> we have <fr:tex display="inline"><![CDATA[w=u_1vu_2]]></fr:tex> for some <fr:link href="/jms-018K/" title="Pumping bracket" uri="https://www.jonmsterling.com/jms-018K/" display-uri="jms-018K" type="local">pumping bracket</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (u_1,v,u_2\right )\mathclose {}}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1v\right \rvert \mathclose {}}\leq  \ell ]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018M/</fr:uri>
                <fr:display-uri>jms-018M</fr:display-uri>
                <fr:route>/jms-018M/</fr:route>
                <fr:title text="The pumping lemma for DFAs">The pumping lemma for <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s</fr:title>
                <fr:taxon>Lemma</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">deterministic finite automaton</fr:link>. Then the cardinality <fr:tex display="inline"><![CDATA[\mathord {\#}{Q_{M}}]]></fr:tex> of the set of states of <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfies the <fr:link href="/jms-018L/" title="The pumping property" uri="https://www.jonmsterling.com/jms-018L/" display-uri="jms-018L" type="local">pumping property</fr:link> with respect to <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[\ell =\mathord {\#}{Q_{M}}]]></fr:tex> for short. To show that <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> satisfies the <fr:link href="/jms-018L/" title="The pumping property" uri="https://www.jonmsterling.com/jms-018L/" display-uri="jms-018L" type="local">pumping property</fr:link> with respect to <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>, we fix a <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[w\in \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> with <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert w\right \rvert \mathclose {}}\geq  \ell ]]></fr:tex> which we must deconcatenate into some <fr:link href="/jms-018K/" title="Pumping bracket" uri="https://www.jonmsterling.com/jms-018K/" display-uri="jms-018K" type="local">pumping bracket</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (u_1,v,u_2\right )\mathclose {}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1v\right \rvert \mathclose {}}\leq \ell ]]></fr:tex>.</html:p>

 <html:p>Letting <fr:tex display="inline"><![CDATA[n={\mathopen {}\left \lvert w\right \rvert \mathclose {}}]]></fr:tex>, we know that <fr:tex display="inline"><![CDATA[w=a_1\ldots  a_n]]></fr:tex> and that we have a transition path of the following form in <fr:tex display="inline"><![CDATA[M]]></fr:tex>:</html:p>
 <fr:tex display="block"><![CDATA[
  s_{M}=q_0\mathrel {\xrightarrow {a_1}} q_1\mathrel {\xrightarrow {a_2}} q_2\cdots \mathrel {\xrightarrow {a_n}}q_n\in F_{M}
 ]]></fr:tex>

 <html:p>We focus on just the first <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> transitions in the path above, which pass through <fr:tex display="inline"><![CDATA[\ell +1]]></fr:tex> states:</html:p>
 <fr:tex display="block"><![CDATA[
  s_{M}=
  \overbrace {
   \underbrace {
    q_0\mathrel {\xrightarrow {a_1}} q_1\mathrel {\xrightarrow {a_2}} q_2\cdots \mathrel {\xrightarrow {a_\ell }}q_\ell 
    }_{\text {$\scriptstyle  \ell $ transitions through $\scriptstyle  \ell +1$ states}}
   \cdots \mathrel {\xrightarrow {a_n}}q_n
  }^{\text {$\scriptstyle  n$ transitions through $\scriptstyle  n+1$ states}}
  \in F_{M}
 ]]></fr:tex>

 <html:p>Because there are no more than <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> states total in <fr:tex display="inline"><![CDATA[M]]></fr:tex>, we know for sure that in the depicted prefix, there must be at least one state visited twice—or, in other words, we must have some <fr:tex display="inline"><![CDATA[0\leq  i<j\leq  \ell ]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q_i=q_j]]></fr:tex>. We can therefore decompose the entire transition sequence as <fr:tex display="inline"><![CDATA[w=u_1 v u_2]]></fr:tex> where <fr:tex display="inline"><![CDATA[u_1 = a_1\ldots  a_i]]></fr:tex>, <fr:tex display="inline"><![CDATA[v=a_{i+1}\ldots  a_j]]></fr:tex>, and <fr:tex display="inline"><![CDATA[u_1 = a_{j+1}\ldots  a_n]]></fr:tex> as depicted below:</html:p>

 <fr:tex display="block"><![CDATA[
  s_{M}=q_0\mathrel {\vphantom {\xrightarrow {u_1}}\smash {\xrightarrow {u_1}}^*}
 q_i \mathrel {\vphantom {\xrightarrow {v}}\smash {\xrightarrow {v}}^*}
 q_j\mathrel {\vphantom {\xrightarrow {u_2}}\smash {\xrightarrow {u_2}}^*}
 q_n \in  F_{M}
 ]]></fr:tex>

 <html:p>We know that <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1 v\right \rvert \mathclose {}}\leq  \ell ]]></fr:tex> because <fr:tex display="inline"><![CDATA[i<j\leq  \ell ]]></fr:tex>. It remains to check that we can repeat the central component <fr:tex display="inline"><![CDATA[v]]></fr:tex> any number of times (including zero), i.e. that for all <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> we have <fr:tex display="inline"><![CDATA[u_1vu_2\in \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>. But this is immediate because <fr:tex display="inline"><![CDATA[q_i=q_j]]></fr:tex>, and so the transition path <fr:tex display="inline"><![CDATA[q_j\mathrel {\vphantom {\xrightarrow {u_2}}\smash {\xrightarrow {u_2}}^*}
 q_n]]></fr:tex> can occur after any number of round-trips consuming <fr:tex display="inline"><![CDATA[v]]></fr:tex> each time.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018N/</fr:uri>
                <fr:display-uri>jms-018N</fr:display-uri>
                <fr:route>/jms-018N/</fr:route>
                <fr:title text="The pumping lemma for regular languages">The pumping lemma for <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link></fr:title>
                <fr:taxon>Corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>For any <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link> <fr:tex display="inline"><![CDATA[L]]></fr:tex> there exists a number <fr:tex display="inline"><![CDATA[\ell >1]]></fr:tex> satisfying the <fr:link href="/jms-018L/" title="The pumping property" uri="https://www.jonmsterling.com/jms-018L/" display-uri="jms-018L" type="local">pumping property</fr:link> with respect to <fr:tex display="inline"><![CDATA[L]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>By <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>, there exists some <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=L]]></fr:tex>; the rest follows from <fr:link href="/jms-018M/" title="The pumping lemma for DFAs" uri="https://www.jonmsterling.com/jms-018M/" display-uri="jms-018M" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-018M/" display-uri="jms-018M" /></fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018P/</fr:uri>
                <fr:display-uri>jms-018P</fr:display-uri>
                <fr:route>/jms-018P/</fr:route>
                <fr:title text="Applications of the pumping lemma">Applications of the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We can use the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link> to show that the examples described in <fr:link href="/jms-018J/" title="Some non-regular languages" uri="https://www.jonmsterling.com/jms-018J/" display-uri="jms-018J" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-018J/" display-uri="jms-018J" /></fr:link> are not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. First, it is helpful to transform the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link> into a more convenient contrapositive form.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018O/</fr:uri>
                    <fr:display-uri>jms-018O</fr:display-uri>
                    <fr:route>/jms-018O/</fr:route>
                    <fr:title text="Contrapositive of the pumping lemma">Contrapositive of the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link></fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[L]]></fr:tex> be a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> such that for each <fr:tex display="inline"><![CDATA[\ell \geq  1]]></fr:tex>, there exists some <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[w\in  L]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert w\right \rvert \mathclose {}}\geq  l]]></fr:tex> such that for any decomposition <fr:tex display="inline"><![CDATA[w=u_1 v u_2]]></fr:tex> with <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1v\right \rvert \mathclose {}}\leq  \ell ]]></fr:tex> and <fr:tex display="inline"><![CDATA[v]]></fr:tex> non-empty, there exists some <fr:tex display="inline"><![CDATA[n]]></fr:tex> such that <fr:tex display="inline"><![CDATA[u_1 v^n u_2]]></fr:tex> lies outside <fr:tex display="inline"><![CDATA[L]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[L]]></fr:tex> is not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>This is precisely the contrapositive of <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" /></fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <html:p>Now we are ready to proceed.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018Q/</fr:uri>
                    <fr:display-uri>jms-018Q</fr:display-uri>
                    <fr:route>/jms-018Q/</fr:route>
                    <fr:title text="Well-bracketing is not regular">Well-bracketing is not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link></fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The set of strings over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{(,),a,b,\ldots ,z\right \}\mathclose {}}]]></fr:tex> in which parentheses are well-nested is not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Write <fr:tex display="inline"><![CDATA[L]]></fr:tex> for the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> in question. Applying <fr:link href="/jms-018O/" title="Contrapositive of the pumping lemma" uri="https://www.jonmsterling.com/jms-018O/" display-uri="jms-018O" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018O/" display-uri="jms-018O" /></fr:link>, we fix <fr:tex display="inline"><![CDATA[\ell \geq  1]]></fr:tex> and consider the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[w=\lparen ^\ell  \rparen ^\ell ]]></fr:tex> consisting of <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex> left parentheses followed by the same number of right parentheses; we evidently have <fr:tex display="inline"><![CDATA[w\in  L]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert w\right \rvert \mathclose {}}\geq  \ell ]]></fr:tex>. But any deconcatenation <fr:tex display="inline"><![CDATA[w=u_1 v u_2]]></fr:tex> with <fr:tex display="inline"><![CDATA[v]]></fr:tex> non-empty and <fr:tex display="inline"><![CDATA[\vert {u_1v}\leq  \ell ]]></fr:tex> must have either <fr:tex display="inline"><![CDATA[v=\lparen ^k]]></fr:tex> for some non-zero <fr:tex display="inline"><![CDATA[k]]></fr:tex>; there is no other possibility, because we have assumed <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1v\right \rvert \mathclose {}}\leq  \ell ]]></fr:tex>. Therefore, even though <fr:tex display="inline"><![CDATA[w=u_1 v u_2]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[L]]></fr:tex>, we would not have <fr:tex display="inline"><![CDATA[u_1 v^n u_2\in  L]]></fr:tex> unless <fr:tex display="inline"><![CDATA[n=1]]></fr:tex>: increasing or decreasing <fr:tex display="inline"><![CDATA[n]]></fr:tex> will result in unbalanced parentheses.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <html:p>The same argument shows that set of strings over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> consisting of some number of <fr:tex display="inline"><![CDATA[a]]></fr:tex>s followed by the <html:em>same</html:em> number of <fr:tex display="inline"><![CDATA[b]]></fr:tex>s is not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018R/</fr:uri>
                    <fr:display-uri>jms-018R</fr:display-uri>
                    <fr:route>/jms-018R/</fr:route>
                    <fr:title text="Palindromes are not regular">Palindromes are not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link></fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The set of palindromes over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> is not regular.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Write <fr:tex display="inline"><![CDATA[L_p]]></fr:tex> for the set of palindromes over <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex>. Applying <fr:link href="/jms-018O/" title="Contrapositive of the pumping lemma" uri="https://www.jonmsterling.com/jms-018O/" display-uri="jms-018O" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018O/" display-uri="jms-018O" /></fr:link>, we fix <fr:tex display="inline"><![CDATA[\ell \geq  1]]></fr:tex> and consider the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[a^\ell  b a^\ell ]]></fr:tex>, which lies in <fr:tex display="inline"><![CDATA[L_p]]></fr:tex> and has length greater than <fr:tex display="inline"><![CDATA[\ell ]]></fr:tex>. Given a decomposition <fr:tex display="inline"><![CDATA[w= u_1 v u_2]]></fr:tex> with <fr:tex display="inline"><![CDATA[v]]></fr:tex> non-empty and <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u_1v\right \rvert \mathclose {}}\leq  \ell ]]></fr:tex>, the only possibility is that <fr:tex display="inline"><![CDATA[u_1 = a\ldots ]]></fr:tex> and <fr:tex display="inline"><![CDATA[v=a]]></fr:tex>, and <fr:tex display="inline"><![CDATA[u_2]]></fr:tex> is some number of <fr:tex display="inline"><![CDATA[a]]></fr:tex>s followed by a <fr:tex display="inline"><![CDATA[b]]></fr:tex> followed by some number of <fr:tex display="inline"><![CDATA[a]]></fr:tex>s. If we remove <fr:tex display="inline"><![CDATA[v]]></fr:tex> we immediately go outside <fr:tex display="inline"><![CDATA[L]]></fr:tex> by introducing an asymmetry between the number of <fr:tex display="inline"><![CDATA[a]]></fr:tex>s on the left and on the right.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018S/</fr:uri>
                <fr:display-uri>jms-018S</fr:display-uri>
                <fr:route>/jms-018S/</fr:route>
                <fr:title text="Limitations of the pumping lemma">Limitations of the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link></fr:title>
                <fr:taxon>Warning</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Although the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link> can be used to prove that many specific <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link> are not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> there nonetheless exist non-<fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link> <fr:tex display="inline"><![CDATA[L]]></fr:tex> for which there exists <fr:tex display="inline"><![CDATA[\ell \geq 1]]></fr:tex> satisfying the <fr:link href="/jms-018L/" title="The pumping property" uri="https://www.jonmsterling.com/jms-018L/" display-uri="jms-018L" type="local">pumping property</fr:link> with respect to <fr:tex display="inline"><![CDATA[L]]></fr:tex>. This means that the <fr:link href="/jms-018N/" title="The pumping lemma for regular languages" uri="https://www.jonmsterling.com/jms-018N/" display-uri="jms-018N" type="local">pumping lemma</fr:link> cannot be used to prove that such <fr:tex display="inline"><![CDATA[L]]></fr:tex> are not <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. For example, the number <fr:tex display="inline"><![CDATA[1]]></fr:tex> satisfies the <fr:link href="/jms-018L/" title="The pumping property" uri="https://www.jonmsterling.com/jms-018L/" display-uri="jms-018L" type="local">pumping property</fr:link> for the following non-<fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>:</html:p><fr:tex display="block"><![CDATA[
 L =
 {\mathopen {}\left \{c^m a^n b^n\,\middle \vert \,m\geq  1 \land  n\geq  0\right \}\mathclose {}}
 \cup 
 {\mathopen {}\left \{a^m b^n\,\middle \vert \,m,n\geq  0\right \}\mathclose {}}
]]></fr:tex>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>For non-empty <fr:tex display="inline"><![CDATA[w=xw'\in  L]]></fr:tex> for <fr:tex display="inline"><![CDATA[x\in  {\mathopen {}\left \{a,b,c\right \}\mathclose {}}]]></fr:tex>, we can use the <fr:link href="/jms-018K/" title="Pumping bracket" uri="https://www.jonmsterling.com/jms-018K/" display-uri="jms-018K" type="local">pumping bracket</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\epsilon ,x,w'\right )\mathclose {}}]]></fr:tex>. Indeed, <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert \epsilon  x\right \rvert \mathclose {}}={\mathopen {}\left \lvert x\right \rvert \mathclose {}}=1\geq  1]]></fr:tex>, and so we need only check that <fr:tex display="inline"><![CDATA[x^nw'\in  L]]></fr:tex> for all <fr:tex display="inline"><![CDATA[n]]></fr:tex>. We consider all the possibilities for <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[w']]></fr:tex> that follow from our assumption that <fr:tex display="inline"><![CDATA[xw'\in  L]]></fr:tex> and we see that we can repeat <fr:tex display="inline"><![CDATA[x]]></fr:tex> any number of times without departing <fr:tex display="inline"><![CDATA[L]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <html:p>That’s the end! But you will learn more of the amazing mysteries of languages and models of computation in IB Computation Theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/ianleslie/" title="Ian Leslie" uri="https://www.jonmsterling.com/ianleslie/" display-uri="ianleslie" type="local">Ian Leslie</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>14</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-017X/</fr:uri>
            <fr:display-uri>jms-017X</fr:display-uri>
            <fr:route>/jms-017X/</fr:route>
            <fr:title text="Lecture 23: regular languages and Kleene’s theorem">Lecture 23: regular languages and Kleene’s theorem</fr:title>
            <fr:meta name="venue">
              <fr:link href="/jms-00XY/" title="IA Discrete Mathematics" uri="https://www.jonmsterling.com/jms-00XY/" display-uri="jms-00XY" type="local">IA Discrete Mathematics</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> by adapting prior notes created by <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link> that I inherited from <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018C/</fr:uri>
                <fr:display-uri>jms-018C</fr:display-uri>
                <fr:route>/jms-018C/</fr:route>
                <fr:title text="Regular vs. automatical languages">Regular <html:em>vs.</html:em> automatical languages</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In previous lectures, we have seen two apparently different ways to generate a class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link>: by means of <fr:link href="/jms-0174/" title="Lecture 21: regular expressions and pattern matching" uri="https://www.jonmsterling.com/jms-0174/" display-uri="jms-0174" type="local">regular expressions</fr:link> and by means of <fr:link href="/jms-00OC/" title="Lecture 22: finite automata" uri="https://www.jonmsterling.com/jms-00OC/" display-uri="jms-00OC" type="local">finite automata</fr:link>. The goal of this lecture is to see that <html:em>all</html:em> these classes of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> coincide, which is a theorem due to Stephen Kleene; to start with, we define <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local"><html:em>regular languages</html:em></fr:link> below.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017Y/</fr:uri>
                    <fr:display-uri>jms-017Y</fr:display-uri>
                    <fr:route>/jms-017Y/</fr:route>
                    <fr:title text="Regular language">Regular <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is called <html:em><html:strong>regular</html:strong></html:em> if it is equal to <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> for some <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expression</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>Using a bit of non-standard terminology, we give a name to the class of languages that can be recognised by <fr:link href="/jms-00OC/" title="Lecture 22: finite automata" uri="https://www.jonmsterling.com/jms-00OC/" display-uri="jms-00OC" type="local">finite automata</fr:link>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0185/</fr:uri>
                    <fr:display-uri>jms-0185</fr:display-uri>
                    <fr:route>/jms-0185/</fr:route>
                    <fr:title text="Automatical language">Automatical <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is called <html:em><html:strong>automatical</html:strong></html:em> if it is equal to <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> for some <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">finite automaton</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>By virtue of <fr:link href="/jms-017U/" title="Equivalence between NFA\varepsilon s, NFAs, and DFAs" uri="https://www.jonmsterling.com/jms-017U/" display-uri="jms-017U" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-017U/" display-uri="jms-017U" /></fr:link>, it does not matter at all whether <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" /></fr:link> is understood to be referring to <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s, <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>, or <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s: the conditions are all equivalent.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <html:p>When we wanted to show that <fr:link href="/jms-017J/" title="Kinds of finite automata" uri="https://www.jonmsterling.com/jms-017J/" display-uri="jms-017J" type="local">different kinds of automata</fr:link> generated the same class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link>, we first described a method to convert between them: in particular, the <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link> converts an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> to a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> that accepts the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>, as we proved in <fr:link href="/jms-017U/" title="Equivalence between NFA\varepsilon s, NFAs, and DFAs" uri="https://www.jonmsterling.com/jms-017U/" display-uri="jms-017U" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-017U/" display-uri="jms-017U" /></fr:link>. Today, we will use a similar strategy: we will show in <fr:link href="/jms-0184/" title="Compiling a regular expression to an NFA" uri="https://www.jonmsterling.com/jms-0184/" display-uri="jms-0184" type="local">§ <fr:contextual-number uri="https://www.jonmsterling.com/jms-0184/" display-uri="jms-0184" /></fr:link> how to compile a <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link> to an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> accepting the same language, and vice versa in [jms-017Z]; from this we will conclude <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>, which states that a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> if and only if it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>14</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0184/</fr:uri>
                <fr:display-uri>jms-0184</fr:display-uri>
                <fr:route>/jms-0184/</fr:route>
                <fr:title text="Compiling a regular expression to an NFA">Compiling a <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link> to an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We aim to show that every <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>. The <fr:link href="/jms-0171/" title="Rule induction" uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" type="local">rule induction</fr:link> principle for <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expressions</fr:link> implies that the <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are the <html:em>smallest</html:em> class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> closed under unions, concatenation, repetition, single symbols, the empty string, and the empty language. Therefore, to prove our desired theorem it will suffice to show that the <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical languages</fr:link> are closed under the same constructions.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0186/</fr:uri>
                    <fr:display-uri>jms-0186</fr:display-uri>
                    <fr:route>/jms-0186/</fr:route>
                    <fr:title text="automaticality of basic regular languages"><fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automaticality</fr:link> of basic <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link></fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> be an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link>. Then the basic <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a\right \}\mathclose {}} = \mathcal {L}{\mathopen {}\left (a\right )\mathclose {}}]]></fr:tex> for <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{\epsilon \right \}\mathclose {}} = \mathcal {L}{\mathopen {}\left (\underline {\epsilon }\right )\mathclose {}}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\varnothing  = \mathcal {L}{\mathopen {}\left (\varnothing \right )\mathclose {}}]]></fr:tex> are all <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>For the symbol <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex>, we choose the following very simple <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>:</html:p>

 <html:figure><fr:resource hash="d8eb1c3357a353eca57b1131193119cf"><fr:resource-content><html:img src="/d8eb1c3357a353eca57b1131193119cf.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state,initial] (q0) {$q_0$};
     \node [state,accepting,right=of q0] (q1) {$q_1$};
     \path [->]
       (q0) edge node[above] {$a$} (q1)
     ;
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>

 <html:p>For the empty string, we have a simple <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> with no transitions at all (this would be an example of where the corresponding <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> would be somewhat unnatural):</html:p>

 <html:figure><fr:resource hash="ed39df7af19d39287111ed43744ae7c6"><fr:resource-content><html:img src="/ed39df7af19d39287111ed43744ae7c6.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state,initial,accepting] (q0) {$q_0$};
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>

 <html:p>For the empty <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>, we have the following <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> with no accepting states:</html:p>

 <html:figure><fr:resource hash="e163ca77ce3de79ca83e8048c294575c"><fr:resource-content><html:img src="/e163ca77ce3de79ca83e8048c294575c.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state,initial] (q0) {$q_0$};
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0187/</fr:uri>
                    <fr:display-uri>jms-0187</fr:display-uri>
                    <fr:route>/jms-0187/</fr:route>
                    <fr:title text="Closure of automaticality under union">Closure of <fr:link href="/jms-0186/" title="automaticality of basic regular languages" uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" type="local">automaticality</fr:link> under union</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[L_2]]></fr:tex> are <fr:link href="/jms-0186/" title="automaticality of basic regular languages" uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" type="local">automatical</fr:link> languages over a common <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, then so is their union <fr:tex display="inline"><![CDATA[L_1\cup  L_2]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[M_2]]></fr:tex> be <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">finite automata</fr:link> with <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M_i\right )\mathclose {}}=L_i]]></fr:tex>; without loss of generality, we assume these have disjoint sets of states. We shall describe an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> with <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M_1\right )\mathclose {}}\cup \mathcal {L}{\mathopen {}\left (M_2\right )\mathclose {}}]]></fr:tex>.</html:p>

 <html:figure><fr:resource hash="578f55a65e35411bd95e852437953d35"><fr:resource-content><html:img src="/578f55a65e35411bd95e852437953d35.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state,initial] (q0) {$q_0$};
     \node [state,above right=of q0] (s1) {$s_{M_1}$};
     \node [state,below right=of q0] (s2) {$s_{M_2}$};
     \node [right=1.5cm of s1] (M1) {$M_1$};
     \node [right=1.5cm of s2] (M2) {$M_2$};

     \path [->]
       (q0) edge node[sloped,above] {$\varepsilon $} (s1)
       (q0) edge node[sloped,below] {$\varepsilon $} (s2)
     ;

     \path [dotted]
       (s1) edge (M1)
       (s2) edge (M2)
     ;

     \begin {scope}[on background layer]
       \node [blue halo, fit=(s1)(M1)]{};
       \node [blue halo, fit=(s2)(M2)]{};
     \end {scope}
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>

 <html:p>We define an accepting state of <fr:tex display="inline"><![CDATA[M]]></fr:tex> above to be either an accepting state of <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> or of <fr:tex display="inline"><![CDATA[M_2]]></fr:tex>. <fr:tex display="block"><![CDATA[F_{M} = F_{M_1}\cup F_{M_2}]]></fr:tex></html:p>

 <html:p>That <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M_1\right )\mathclose {}}\cup \mathcal {L}{\mathopen {}\left (M_2\right )\mathclose {}}]]></fr:tex> holds follows by a quick inspection: indeed, if <fr:tex display="inline"><![CDATA[u\in \mathcal {L}{\mathopen {}\left (M_i\right )\mathclose {}}]]></fr:tex> then we have a path in <fr:tex display="inline"><![CDATA[M_i]]></fr:tex> from <fr:tex display="inline"><![CDATA[\star {M_i}]]></fr:tex> to an accepting state in <fr:tex display="inline"><![CDATA[M_i]]></fr:tex>, which we can extend by means of either <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition to a path in <fr:tex display="inline"><![CDATA[M]]></fr:tex>. Conversely, any from <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> to an accepting state of <fr:tex display="inline"><![CDATA[M]]></fr:tex> must either be a path to an accepting state of some <fr:tex display="inline"><![CDATA[M_i]]></fr:tex> and must therefore pass through one of the two <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions. Chop off that transition to get a valid path in either <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> or <fr:tex display="inline"><![CDATA[M_2]]></fr:tex>.</html:p>

 <html:p>That <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M_1\right )\mathclose {}}\mathcal {L}{\mathopen {}\left (M_2\right )\mathclose {}}]]></fr:tex> holds by inspection.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0188/</fr:uri>
                    <fr:display-uri>jms-0188</fr:display-uri>
                    <fr:route>/jms-0188/</fr:route>
                    <fr:title text="Closure of automaticality under concatenation">Closure of <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automaticality</fr:link> under concatenation</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[L_2]]></fr:tex> are <fr:link href="/jms-0186/" title="automaticality of basic regular languages" uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" type="local">automatical languages</fr:link> over a common <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, then so is their <html:em>concatenation</html:em> <fr:tex display="inline"><![CDATA[L_1L_2]]></fr:tex>, which we defined below:</html:p><fr:tex display="block"><![CDATA[
 L_1L_2 = {\mathopen {}\left \{uv\in \Sigma ^\star \,\middle \vert \,u\in  L_1, v\in  L_2\right \}\mathclose {}}
]]></fr:tex>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[M_2]]></fr:tex> be <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">finite automata</fr:link> with <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M_i\right )\mathclose {}}=L_i]]></fr:tex>; without loss of generality, we assume that these have disjoint sets of states. We shall describe an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> with <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M_1\right )\mathclose {}}\mathcal {L}{\mathopen {}\left (M_2\right )\mathclose {}}]]></fr:tex>; in particular, we lay out <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[M_2]]></fr:tex> side by side and draw an <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition from every accepting node of <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> to the staring node of <fr:tex display="inline"><![CDATA[M_2]]></fr:tex>.</html:p>

 <html:figure><fr:resource hash="5033f2c5eddc9069b038184c20be3088"><fr:resource-content><html:img src="/5033f2c5eddc9069b038184c20be3088.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state, initial] (s1) {$s_{M_1}$};
     \node [right=1.5cm of s1] (M1) {$M_1$};
     \node [state,accepting,right=1.5cm of M1] (q1) {$\cdots $};
     \node [state,right=of q1] (s2) {$s_{M_2}$};
     \node [right=1.5cm of s2] (M2) {$M_2$};
     \path [->] (q1) edge node[above] {$\varepsilon $} (s2);

     \path [dotted]
       (s1) edge (M1)
       (M1) edge (q1)
       (s2) edge (M2)
     ;

     \begin {scope}[on background layer]
       \node [blue halo, fit=(s1)(M1)(q1)]{};
       \node [blue halo, fit=(s2)(M2)]{};
     \end {scope}
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>

 <html:p>The starting node of <fr:tex display="inline"><![CDATA[M]]></fr:tex> is that of <fr:tex display="inline"><![CDATA[M_1]]></fr:tex> and the accepting nodes of <fr:tex display="inline"><![CDATA[M]]></fr:tex> are those of <fr:tex display="inline"><![CDATA[M_2]]></fr:tex>.</html:p>

 <html:p>That <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M_1\right )\mathclose {}}\mathcal {L}{\mathopen {}\left (M_2\right )\mathclose {}}]]></fr:tex> holds by inspection.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0189/</fr:uri>
                    <fr:display-uri>jms-0189</fr:display-uri>
                    <fr:route>/jms-0189/</fr:route>
                    <fr:title text="Closure of automaticality under repetition">Closure of <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automaticality</fr:link> under repetition</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[L]]></fr:tex> is an <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical language</fr:link> over a given <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, then so is the <html:em>repetition</html:em> <fr:tex display="inline"><![CDATA[L^\star ]]></fr:tex> of <fr:tex display="inline"><![CDATA[L]]></fr:tex>, which we define below in terms of concatenation:</html:p><fr:tex display="block"><![CDATA[
 L^\star  =
 {\mathopen {}\left \{\epsilon \right \}\mathclose {}}
 \cup 
 L
 \cup  LL
 \cup  \ldots  =
 \bigcup _{n\in \mathbb {N}}
 {\mathopen {}\left \{u_1\ldots  u_n\,\middle \vert \,u_i\in  L\right \}\mathclose {}}
]]></fr:tex>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be a <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">finite automaton</fr:link> with <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=L]]></fr:tex>. We shall describe an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M^\star ]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M^\star \right )\mathclose {}}=L^\star ]]></fr:tex>; we take <fr:tex display="inline"><![CDATA[M]]></fr:tex> and add a new starting state <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> with an <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition to the old starting state, and then we make an <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-transition from every old accepting state back to <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>.</html:p>

 <html:figure><fr:resource hash="9eaa6a97b79fc14f2e9cb361ec8f0be4"><fr:resource-content><html:img src="/9eaa6a97b79fc14f2e9cb361ec8f0be4.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
   \begin {tikzpicture}[node distance=2cm,on grid]
     \node [state,initial,accepting] (q0) {$q_0$};
     \node [state,right=of q0] (s) {$s_{M}$};
     \node [right=1.5cm of s] (M) {$M$};
     \node [state,accepting,right=1.5cm of M] (qf) {$\cdots $};

     \path [->]
       (q0) edge node[sloped,above] {$\varepsilon $} (s)
       (qf) edge[bend left=30] node[sloped,below] {$\varepsilon $} (q0)
     ;

     \path [dotted]
       (s) edge (M)
       (M) edge (qf)
     ;

     \begin {scope}[on background layer]
       \node [blue halo, fit=(s)(M)(qf)]{};
     \end {scope}
   \end {tikzpicture}
  ]]></fr:resource-source></fr:resource></html:figure>

 <html:p>The only accepting state of <fr:tex display="inline"><![CDATA[M^\star ]]></fr:tex> is <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>.</html:p>

 <html:p>It holds by inspection that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M^\star \right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}^\star ]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018A/</fr:uri>
                    <fr:display-uri>jms-018A</fr:display-uri>
                    <fr:route>/jms-018A/</fr:route>
                    <fr:title text="All regular languages are automatical">All <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link></fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>If a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> <fr:tex display="inline"><![CDATA[L]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>, then it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[U]]></fr:tex> be the set of all <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expressions</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>. We wish to show that the set of all <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expressions</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is contained in <fr:tex display="inline"><![CDATA[U]]></fr:tex>. By <fr:link href="/jms-0171/" title="Rule induction" uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" type="local">rule induction</fr:link> it suffices to check the following cases:</html:p>

 <html:ol><html:li>We need to know that <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a},\texttt {Null}, \texttt {Never} \in  U]]></fr:tex>, which is the same as to say that the languages <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{a\right \}\mathclose {}}, {\mathopen {}\left \{\epsilon \right \}\mathclose {}}, \varnothing ]]></fr:tex> are all <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>. This is <fr:link href="/jms-0186/" title="automaticality of basic regular languages" uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0186/" display-uri="jms-0186" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R,S\in  U]]></fr:tex> then <fr:tex display="inline"><![CDATA[\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that the language <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\cup \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> assuming that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> are. This is <fr:link href="/jms-0187/" title="Closure of automaticality under union" uri="https://www.jonmsterling.com/jms-0187/" display-uri="jms-0187" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0187/" display-uri="jms-0187" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R,S\in  U]]></fr:tex> then <fr:tex display="inline"><![CDATA[\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that the language <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}} = {\mathopen {}\left \{uv\,\middle \vert \,u\in \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}},v\in \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right \}\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> assuming that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> are. This is <fr:link href="/jms-0188/" title="Closure of automaticality under concatenation" uri="https://www.jonmsterling.com/jms-0188/" display-uri="jms-0188" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0188/" display-uri="jms-0188" /></fr:link>.</html:li>
  <html:li>We need to show that if <fr:tex display="inline"><![CDATA[R\in  U]]></fr:tex> then so is <fr:tex display="inline"><![CDATA[\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}\in  U]]></fr:tex>, which is to say that if <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> then so is <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}^\star ]]></fr:tex>. This is <fr:link href="/jms-0189/" title="Closure of automaticality under repetition" uri="https://www.jonmsterling.com/jms-0189/" display-uri="jms-0189" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0189/" display-uri="jms-0189" /></fr:link>.</html:li></html:ol>

 <html:p>We are done.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>14</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>14</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017Z/</fr:uri>
                <fr:display-uri>jms-017Z</fr:display-uri>
                <fr:route>/jms-017Z/</fr:route>
                <fr:title text="Decompiling a regular expression from an NFA">Decompiling a <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link> from an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We want to “decompile” any <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> to an equivalent <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link>; it is not easy to do so directly, so we will actually solve a more general problem first.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0181/</fr:uri>
                    <fr:display-uri>jms-0181</fr:display-uri>
                    <fr:route>/jms-0181/</fr:route>
                    <fr:title text="Region of an NFA">Region of an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>. A <html:em><html:strong>region</html:strong></html:em> of <fr:tex display="inline"><![CDATA[M]]></fr:tex> is defined to be a triple <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> with <fr:tex display="inline"><![CDATA[S\subseteq Q_{M}]]></fr:tex> and <fr:tex display="inline"><![CDATA[q,q'\in  Q_{M}]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>A <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">region</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> in an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> is meant to encode a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> whose strings consist of those that can be consumed starting from states <fr:tex display="inline"><![CDATA[q]]></fr:tex> and ending in state <fr:tex display="inline"><![CDATA[q']]></fr:tex> passing only through states that lie in <fr:tex display="inline"><![CDATA[S]]></fr:tex>. We define this more formally below.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0182/</fr:uri>
                    <fr:display-uri>jms-0182</fr:display-uri>
                    <fr:route>/jms-0182/</fr:route>
                    <fr:title text="The formal language accepted within a region">The <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted within a <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">region</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> be a <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">region</fr:link> in an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex>. The <html:em><html:strong><fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted within <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex></html:strong></html:em> is defined to be the following set of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link>:</html:p>
                    <fr:tex display="block"><![CDATA[
 \mathcal {L}_{M}{\mathopen {}\left (q,S,q'\right )\mathclose {}} =
 {\mathopen {}\left \{u \in \Sigma _M^\star \,\middle \vert \,
   q \mathrel {\vphantom {\xrightarrow {u}}\smash {\xrightarrow {u}}^*}
 q'
   \text { with all intermediate states lying in S}
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>We shall also refer to <fr:tex display="inline"><![CDATA[\mathcal {L}_{M}{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> as the <html:em><html:strong>regional language</html:strong></html:em> of <fr:tex display="inline"><![CDATA[M]]></fr:tex> in <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0180/</fr:uri>
                    <fr:display-uri>jms-0180</fr:display-uri>
                    <fr:route>/jms-0180/</fr:route>
                    <fr:title text="Generalised NFA decompilation">Generalised <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> decompilation</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Any <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional language</fr:link> of an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> is <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We proceed by induction on the number of elements in <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:p>

 <html:p>In the base case, we know that <fr:tex display="inline"><![CDATA[S]]></fr:tex> is empty; the <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional language</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {L}_{M}{\mathopen {}\left (q,\varnothing ,q'\right )\mathclose {}}]]></fr:tex> therefore consist of those <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> <fr:tex display="inline"><![CDATA[u]]></fr:tex> such that either <fr:tex display="inline"><![CDATA[u=\epsilon ]]></fr:tex> and <fr:tex display="inline"><![CDATA[q=q']]></fr:tex>, or <fr:tex display="inline"><![CDATA[u=a]]></fr:tex> for some <fr:tex display="inline"><![CDATA[a\in \Sigma _M]]></fr:tex> and <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {a}}q']]></fr:tex>. Writing this more formally, we have:</html:p>

 <fr:tex display="block"><![CDATA[
  \mathcal {L}_{M}{\mathopen {}\left (q,\varnothing ,q'\right )\mathclose {}} =
  {\mathopen {}\left \{\epsilon \,\middle \vert \,q=q'\right \}\mathclose {}}\cup  \bigcup {\mathopen {}\left \{{\mathopen {}\left \{a\right \}\mathclose {}}\,\middle \vert \,q\mathrel {\xrightarrow {a}}q'\right \}\mathclose {}}
 ]]></fr:tex>

 <html:p>The above is a finite union of <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link>, and so it is evidently <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>

 <html:p>In the inductive step, we assume that any <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional language</fr:link> whose interior state set has <fr:tex display="inline"><![CDATA[n]]></fr:tex> elements is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>, and we must show the same for any <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional language</fr:link> whose interior state set has <fr:tex display="inline"><![CDATA[n+1]]></fr:tex> elements. Fixing such a <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">region</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> with <fr:tex display="inline"><![CDATA[\#S=n+1]]></fr:tex>, we will try to reduce the <fr:tex display="inline"><![CDATA[\mathcal {L}_{M}{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex> to something in terms <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link> that we know by our inductive hypothesis to be <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. Our strategy is to simply remove an arbitrary element from <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:p>

 <html:p>To that end, we pick some arbitrary <fr:tex display="inline"><![CDATA[q_0\in  S]]></fr:tex> so that the set difference <fr:tex display="inline"><![CDATA[S' = S\setminus {\mathopen {}\left \{q_0\right \}\mathclose {}}]]></fr:tex> has <fr:tex display="inline"><![CDATA[n]]></fr:tex> elements. IF we think about all the ways taht we could get from <fr:tex display="inline"><![CDATA[q]]></fr:tex> to <fr:tex display="inline"><![CDATA[q']]></fr:tex> passing through states lying only in <fr:tex display="inline"><![CDATA[S]]></fr:tex>, there are a two possibilities in relation to the state <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>:</html:p>
 <html:ol><html:li>We might have never pass through <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> at all. This would correspond to the <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional language</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {L}_{M}{\mathopen {}\left (q,S',q'\right )\mathclose {}}]]></fr:tex>, which we know to be <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> by our induction hypothesis.</html:li>
  <html:li>If we <html:em>do</html:em> pass through <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>, we must first go from <fr:tex display="inline"><![CDATA[q]]></fr:tex> to <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> without passing through <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>, then we return to <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> arbitrarily many times, and then we finally go from <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> to <fr:tex display="inline"><![CDATA[q]]></fr:tex> without passing through <fr:tex display="inline"><![CDATA[q_0]]></fr:tex>. This corresponds to the following concatenation of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link>, which we know to be <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> by our induction hypothesis and the fact that <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are closed under concatenation and repetition:
   <fr:tex display="block"><![CDATA[
    \mathcal {L}_{M}{\mathopen {}\left (q,S',q_0\right )\mathclose {}}
    \mathcal {L}_{M}{\mathopen {}\left (q_0,S',q_0\right )\mathclose {}}^\star 
    \mathcal {L}_{M}{\mathopen {}\left (q_0,S',q'\right )\mathclose {}}
   ]]></fr:tex></html:li></html:ol>

 <html:p>We see the following by inspection:</html:p>
 <fr:tex display="block"><![CDATA[
  \mathcal {L}_{M}{\mathopen {}\left (q,S,q'\right )\mathclose {}} =
  \mathcal {L}_{M}{\mathopen {}\left (q,S',q\right )\mathclose {}} \cup 
  {\mathopen {}\left (
    \mathcal {L}_{M}{\mathopen {}\left (q,S',q_0\right )\mathclose {}}
    \mathcal {L}_{M}{\mathopen {}\left (q_0,S',q_0\right )\mathclose {}}^\star 
    \mathcal {L}_{M}{\mathopen {}\left (q_0,S',q'\right )\mathclose {}}
  \right )\mathclose {}}
 ]]></fr:tex>

 <html:p>As <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are closed under finite unions, we are done.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0183/</fr:uri>
                    <fr:display-uri>jms-0183</fr:display-uri>
                    <fr:route>/jms-0183/</fr:route>
                    <fr:title text="Decompilation of NFAs">Decompilation of <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>s</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Any <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link> <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We have shown in <fr:link href="/jms-0180/" title="Generalised NFA decompilation" uri="https://www.jonmsterling.com/jms-0180/" display-uri="jms-0180" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-0180/" display-uri="jms-0180" /></fr:link> that each <fr:link href="/jms-0182/" title="The formal language accepted within a region" uri="https://www.jonmsterling.com/jms-0182/" display-uri="jms-0182" type="local">regional langauge</fr:link> of an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>; <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are closed under finite unions, so it suffices to decompose <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> into a finite union of regional languages <fr:tex display="inline"><![CDATA[\mathcal {L}_{M}{\mathopen {}\left (q,S,q'\right )\mathclose {}}]]></fr:tex>.</html:p>

 <html:p>We note that if a <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> is accepted by <fr:tex display="inline"><![CDATA[M]]></fr:tex>, it does so by means of a path from the starting state to some accepting state; each of these scenarios for a given accepting state specifies a <fr:link href="/jms-0181/" title="Region of an NFA" uri="https://www.jonmsterling.com/jms-0181/" display-uri="jms-0181" type="local">region</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (s_{M},Q_{M},q\right )\mathclose {}}]]></fr:tex> with <fr:tex display="inline"><![CDATA[q\in F_{M}]]></fr:tex>. Therefore, we immediately deduce:</html:p>

 <fr:tex display="block"><![CDATA[
  \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}} =
  \bigcup _{q\in F_{M}}
  \mathcal {L}_{M}{\mathopen {}\left (s_{M},Q_{M},q\right )\mathclose {}}
 ]]></fr:tex>

 <html:p>Therefore it follows that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-018D/</fr:uri>
                <fr:display-uri>jms-018D</fr:display-uri>
                <fr:route>/jms-018D/</fr:route>
                <fr:title text="Kleene’s theorem and its consequences">Kleene’s theorem and its consequences</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We now come to the main result of this lecture.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018B/</fr:uri>
                    <fr:display-uri>jms-018B</fr:display-uri>
                    <fr:route>/jms-018B/</fr:route>
                    <fr:title text="Kleene’s theorem">Kleene’s theorem</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>A <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> if and only if it is <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">automatical</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>By <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> and <fr:link href="/jms-0183/" title="Decompilation of NFAs" uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-0183/" display-uri="jms-0183" /></fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <html:p>In light of the above, we will from now on refer mainly to <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">regular languages</fr:link>, and leave behind the non-standard terminology of <fr:link href="/jms-0185/" title="Automatical language" uri="https://www.jonmsterling.com/jms-0185/" display-uri="jms-0185" type="local">“automatical languages”</fr:link>. Several questions that we left unanswered (see <fr:link href="/jms-017F/" title="Questions about regular expression matching" uri="https://www.jonmsterling.com/jms-017F/" display-uri="jms-017F" type="local">Discussion <fr:contextual-number uri="https://www.jonmsterling.com/jms-017F/" display-uri="jms-017F" /></fr:link>) can now be addressed in light of <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018E/</fr:uri>
                    <fr:display-uri>jms-018E</fr:display-uri>
                    <fr:route>/jms-018E/</fr:route>
                    <fr:title text="Decidability of regular expression matching">Decidability of <fr:link href="/jms-017C/" title="Regular expression matching" uri="https://www.jonmsterling.com/jms-017C/" display-uri="jms-017C" type="local">regular expression matching</fr:link></fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">regular expression</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. Then there exists an algorithm to compute whether a given <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u\in \Sigma ^\star ]]></fr:tex> <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">matches</fr:link> <fr:tex display="inline"><![CDATA[R]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>The idea of the proof is to find a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex>; so for this we need only <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link> rather than the full <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link>. Then our algorithm is to feed the given string <fr:tex display="inline"><![CDATA[u]]></fr:tex> through <fr:tex display="inline"><![CDATA[M]]></fr:tex> and check whether the final state is accepting or not.</html:p>
</fr:mainmatter></fr:tree>
 
<html:p>There is a subtlety in the argument above: we need the <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> to have computably decidable equality of states. The way to deal with this is that <fr:tex display="inline"><![CDATA[M]]></fr:tex> has a <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local"><html:em>finite</html:em></fr:link> set of states, and so <fr:link href="/jms-00L0/" title="Isomorphic sets" uri="https://www.jonmsterling.com/jms-00L0/" display-uri="jms-00L0" type="local">isomorphic</fr:link> to a standard finite set of the form <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>, which has computably decidable equality. A more important subtlety is that we need it to be computably decidable whether a given state is an accepting state, and we also need the transition function to be computable; any subset of a finite set is going to be decidable for roughly the same reason—ahead of time, we can enumerate it as a list of numbers in <fr:tex display="inline"><![CDATA[\mathbb {N}_{<n}]]></fr:tex>.</html:p></fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018F/</fr:uri>
                    <fr:display-uri>jms-018F</fr:display-uri>
                    <fr:route>/jms-018F/</fr:route>
                    <fr:title text="Closure of regular languages under complementation">Closure of <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> under complementation</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[L]]></fr:tex> is a <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, then so is its complement <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>Let <fr:tex display="inline"><![CDATA[L]]></fr:tex> be a <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular language</fr:link>, and so by <fr:link href="/jms-018B/" title="Kleene’s theorem" uri="https://www.jonmsterling.com/jms-018B/" display-uri="jms-018B" type="local">Kleene’s theorem</fr:link> we have some <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[L=\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>. We define a new <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (\lnot {M}\right )\mathclose {}} = \Sigma ^\star \setminus  L]]></fr:tex> by setting <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> to have the same states, transition function, and starting state as <fr:tex display="inline"><![CDATA[M]]></fr:tex> but with the opposite set of accepting states:</html:p>
 <fr:tex display="block"><![CDATA[
  F_{\lnot {M}} = Q_{M}\setminus F_{M}
 ]]></fr:tex>

 <html:p>The desired property of <fr:tex display="inline"><![CDATA[\lnot {M}]]></fr:tex> is immediate.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018G/</fr:uri>
                    <fr:display-uri>jms-018G</fr:display-uri>
                    <fr:route>/jms-018G/</fr:route>
                    <fr:title text="Closure of regular languages under intersection">Closure of <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> under intersection</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The intersection of two <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We fix <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> <fr:tex display="inline"><![CDATA[L_1,L_2\subseteq \Sigma ^\star ]]></fr:tex> and consider the intersection <fr:tex display="inline"><![CDATA[L_1\cap  L_2]]></fr:tex>. By De Morgan’s laws, we have:</html:p>

 <fr:tex display="block"><![CDATA[
  L_1\cap  L_2 =
  \Sigma ^\star \setminus {\mathopen {}\left (
   {\mathopen {}\left (
    \Sigma ^\star \setminus  L_1
   \right )\mathclose {}}\cup  {\mathopen {}\left (
    \Sigma ^\star \setminus  L_2
   \right )\mathclose {}}
  \right )\mathclose {}}
 ]]></fr:tex>

 <html:p>Because <fr:link href="/jms-018F/" title="Closure of regular languages under complementation" uri="https://www.jonmsterling.com/jms-018F/" display-uri="jms-018F" type="local"><fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular languages</fr:link> are closed under complementation</fr:link>, it suffices to check that <fr:tex display="block"><![CDATA[
   {\mathopen {}\left (
    \Sigma ^\star \setminus  L_1
   \right )\mathclose {}}\cup  {\mathopen {}\left (
    \Sigma ^\star \setminus  L_2
   \right )\mathclose {}}
 ]]></fr:tex> is <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">Regular languages</fr:link> are, by definition, closed under finite unions, so it remains to check that the complements <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[\Sigma ^\star \setminus  L_2]]></fr:tex> are <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link>. This follows from our assumption that <fr:tex display="inline"><![CDATA[L_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[L_2]]></fr:tex> are <fr:link href="/jms-017Y/" title="Regular language" uri="https://www.jonmsterling.com/jms-017Y/" display-uri="jms-017Y" type="local">regular</fr:link> via <fr:link href="/jms-018F/" title="Closure of regular languages under complementation" uri="https://www.jonmsterling.com/jms-018F/" display-uri="jms-018F" type="local">closure under complements</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-018H/</fr:uri>
                    <fr:display-uri>jms-018H</fr:display-uri>
                    <fr:route>/jms-018H/</fr:route>
                    <fr:title text="Decidability of regular expression equivalence">Decidability of <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local">regular expression</fr:link> equivalence</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>It is decidable whether two regular expressions <fr:tex display="inline"><![CDATA[R,S]]></fr:tex> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> are equivalent in the sense that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We note that two subsets are equal if and only if the intersection of one with the complement of the other is empty, and vice versa:</html:p>

 <fr:tex display="block"><![CDATA[
  \begin {aligned}
   & \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}
   \\
   &\quad \Leftrightarrow 
   \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\subseteq \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\land  \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\subseteq \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}
   \\
   &\quad \Leftrightarrow 
   {\mathopen {}\left ({\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}} =\varnothing  = {\mathopen {}\left ({\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}
  \end {aligned}
 ]]></fr:tex>

 <html:p>We therefore let <fr:tex display="inline"><![CDATA[M]]></fr:tex> and <fr:tex display="inline"><![CDATA[N]]></fr:tex> be two <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link> recognising the language <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ^\star \setminus \mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}\right )\mathclose {}}\cap \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> respectively. (These <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link> can be obtained computably using the compilation procedure by which we proved <fr:link href="/jms-018A/" title="All regular languages are automatical" uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" type="local">Corollary <fr:contextual-number uri="https://www.jonmsterling.com/jms-018A/" display-uri="jms-018A" /></fr:link>.) It follows then that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (S\right )\mathclose {}}]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}=\varnothing =\mathcal {L}{\mathopen {}\left (N\right )\mathclose {}}]]></fr:tex>.</html:p>

 <html:p>So it now remains to check whether there exists <html:em>any</html:em> <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> at all that is accepted by <fr:tex display="inline"><![CDATA[M]]></fr:tex> and likewise for <fr:tex display="inline"><![CDATA[N]]></fr:tex>. We do not have to check <html:em>all</html:em> <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, which would be impossible: we observe that the number of states in <fr:tex display="inline"><![CDATA[M]]></fr:tex> bounds the number of transitions required to reach an accepting state, because any loops about a state <fr:tex display="inline"><![CDATA[q]]></fr:tex> can be excised from the path without changing the result. This is a special property of the <fr:link href="/jms-017J/" title="Kinds of finite automata" uri="https://www.jonmsterling.com/jms-017J/" display-uri="jms-017J" type="local">finite automata</fr:link> that we have studied so far, corresponding to the fact that they have no memory.</html:p>

</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/ianleslie/" title="Ian Leslie" uri="https://www.jonmsterling.com/ianleslie/" display-uri="ianleslie" type="local">Ian Leslie</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0174/</fr:uri>
            <fr:display-uri>jms-0174</fr:display-uri>
            <fr:route>/jms-0174/</fr:route>
            <fr:title text="Lecture 21: regular expressions and pattern matching">Lecture 21: regular expressions and pattern matching</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> by adapting prior notes created by <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link> that I inherited from <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0175/</fr:uri>
                <fr:display-uri>jms-0175</fr:display-uri>
                <fr:route>/jms-0175/</fr:route>
                <fr:title text="Concrete and abstract syntax">Concrete and abstract syntax</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Syntax comes in two forms: there is <html:em><html:strong>concrete syntax</html:strong></html:em>, and this is what people are talking about when they say things like:</html:p>
                <html:blockquote>I prefer the syntax of Rust to C++.</html:blockquote>
                <html:blockquote>I (can’t stand, love) the way that Haskell and Python have indentation-sensitive syntax.</html:blockquote>
                <html:p>Concrete syntax is usually defined in terms of strings of symbols. In general, concrete syntax may use a variety of tools (including brackets, whitespace, etc.) to disambiguiate what would not be ambiguous in a structured representation, e.g. as a syntax tree. The <html:em>structured</html:em> representation of syntax as trees or a similar data structure (like a directed acyclic graph) is called <html:em><html:strong>abstract syntax</html:strong></html:em>. The process of converting concrete syntax to abstract syntax is called <html:em><html:strong>parsing</html:strong></html:em>.</html:p>
                <html:p>Here is an example of concrete syntax, in the OCaml language:</html:p>
                <html:pre><![CDATA[if x > 100
  then x - 10
  else f (f (x + 11))]]></html:pre>
                <html:p>The OCaml parser then converts this into a <html:em>tree</html:em>, with vertices labelled by syntactic forms and subtrees given by arguments. Parenthesisation and operator precedence is now replaced by the parent-child relationship.</html:p>
                <html:figure>
                  <fr:resource hash="2cf6e88801806672c9911cbd726cf180">
                    <fr:resource-content>
                      <html:img src="/2cf6e88801806672c9911cbd726cf180.svg" />
                    </fr:resource-content>
                    <fr:resource-source type="latex" part="preamble"><![CDATA[\usepackage {forest,libertine}]]></fr:resource-source>
                    <fr:resource-source type="latex" part="body"><![CDATA[
  \begin {forest}
    [\textsf {if}
      [$>$ [$x$] [$100$]]
      [$-$ [$x$] [$10$]]
      [@ [$f$]
         [@ [$f$]
            [$+$ [$x$] [$11$]]]
      ]
    ]
  \end {forest}
 ]]></fr:resource-source>
                  </fr:resource>
                </html:figure>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0178/</fr:uri>
                <fr:display-uri>jms-0178</fr:display-uri>
                <fr:route>/jms-0178/</fr:route>
                <fr:title text="Regular expressions">Regular expressions</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Using the tools that we have built up in <fr:link href="/jms-016F/" title="Lecture 20: formal languages, inductive definitions, rule induction" uri="https://www.jonmsterling.com/jms-016F/" display-uri="jms-016F" type="local">Lecture 20</fr:link>, we can smoothly study both concrete and abstract syntax. Somewhat confusingly, our running example will be the <html:em>language of regular expressions</html:em> (this might be confusing because regular expressions are a streamlined way to <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">present</fr:link> the grammar of certain kinds of formal languages—but we are treating the grammar of regular expressions themselves).</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0176/</fr:uri>
                    <fr:display-uri>jms-0176</fr:display-uri>
                    <fr:route>/jms-0176/</fr:route>
                    <fr:title text="Regular expressions (concrete syntax)">Regular expressions (concrete syntax)</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> be an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link>. We then let <fr:tex display="inline"><![CDATA[\Sigma _{\mathsf {rx}}]]></fr:tex> be the disjoint union of <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> with the set <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{\underline {\epsilon },\varnothing , \vert ,*,(,)\right \}\mathclose {}}]]></fr:tex>. Then a <html:em>concrete</html:em> syntax of regular expressions over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> can be defined as a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma _{\mathsf {rx}}]]></fr:tex>, which we <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">present</fr:link> by means of the following <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link>:</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {gathered}
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad a\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \underline {\epsilon }\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \varnothing \quad }


   \\
   
 
 \displaystyle \frac {\displaystyle r}{\displaystyle \quad (r)\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle r\quad  s}{\displaystyle \quad r\vert  s\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle r\quad  s}{\displaystyle \quad rs\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle r}{\displaystyle \quad r*\quad }


 \end {gathered}
]]></fr:tex>
                    <html:p>Above we let <fr:tex display="inline"><![CDATA[a]]></fr:tex> range over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> and <fr:tex display="inline"><![CDATA[r,s]]></fr:tex> range over <fr:tex display="inline"><![CDATA[\Sigma _{\mathsf {rx}}^\star ]]></fr:tex>. We are careful to distinguish the formal symbol <fr:tex display="inline"><![CDATA[\underline {\epsilon }]]></fr:tex> from <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>: <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> is literally the empty <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link>, whereas <fr:tex display="inline"><![CDATA[\underline {\epsilon }]]></fr:tex> is the symbol representing the regular expression that <html:em>matches</html:em> the empty <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link>!</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0177/</fr:uri>
                    <fr:display-uri>jms-0177</fr:display-uri>
                    <fr:route>/jms-0177/</fr:route>
                    <fr:title text="Derivation of a concrete regular expression">Derivation of a concrete regular expression</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The (concrete) regular expression <fr:tex display="inline"><![CDATA[\underline {\epsilon }\vert  ab*]]></fr:tex> can be <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derived</fr:link> in the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">presented</fr:link> in <fr:link href="/jms-0176/" title="Regular expressions (concrete syntax)" uri="https://www.jonmsterling.com/jms-0176/" display-uri="jms-0176" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-0176/" display-uri="jms-0176" /></fr:link> as follows:</html:p>
                    <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \underline {\epsilon }\quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad a\quad }


   \quad 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad b\quad }


   }{\displaystyle \quad b*\quad }


  }{\displaystyle \quad ab*\quad }


 }{\displaystyle \quad 
  \underline {\epsilon }\vert  ab*
 \quad }


]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0179/</fr:uri>
                    <fr:display-uri>jms-0179</fr:display-uri>
                    <fr:route>/jms-0179/</fr:route>
                    <fr:title text="Regular expressions (abstract syntax)">Regular expressions (abstract syntax)</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <html:em>abstract</html:em> syntax of regular expressions over an alphabet <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> will be represented by trees whose vertices are labelled by the symbols <fr:tex display="inline"><![CDATA[\texttt {Union}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Concat}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Star}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Null}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Never}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a}]]></fr:tex> for any <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex>. More specifically, each node of a tree will be of the following form:</html:p>
                    <html:ol><html:li>A node labelled by either <fr:tex display="inline"><![CDATA[\texttt {Union}]]></fr:tex> or <fr:tex display="inline"><![CDATA[\texttt {Concat}]]></fr:tex> has exactly two children.</html:li>
 <html:li>A node labelled by <fr:tex display="inline"><![CDATA[\texttt {Star}]]></fr:tex> has exactly one child.</html:li>
 <html:li>A node labelled by <fr:tex display="inline"><![CDATA[\texttt {Null}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Never}]]></fr:tex>, or <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a}]]></fr:tex> has no children.</html:li></html:ol>
                    <html:p>The plain English description above could be expressed as an <fr:link href="/jms-016N/" title="Inductive definitions" uri="https://www.jonmsterling.com/jms-016N/" display-uri="jms-016N" type="local">inductive definition</fr:link> of a subset of the set of all trees.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017A/</fr:uri>
                    <fr:display-uri>jms-017A</fr:display-uri>
                    <fr:route>/jms-017A/</fr:route>
                    <fr:title text="Examples of abstract syntax trees">Examples of abstract syntax trees</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We recall the derivation for the concrete regular expression <fr:tex display="inline"><![CDATA[\underline {\epsilon }\vert  ab*]]></fr:tex>. This will correspond eventually to the following abstract syntax tree as specified by <fr:link href="/jms-0179/" title="Regular expressions (abstract syntax)" uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-0179/" display-uri="jms-0179" /></fr:link>:</html:p>
                    <html:figure>
                      <fr:resource hash="ec9f65b212e1ed0db533f659b439e2d9">
                        <fr:resource-content>
                          <html:img src="/ec9f65b212e1ed0db533f659b439e2d9.svg" />
                        </fr:resource-content>
                        <fr:resource-source type="latex" part="preamble"><![CDATA[\usepackage {forest}\usepackage [tt=false]{libertine}]]></fr:resource-source>
                        <fr:resource-source type="latex" part="body"><![CDATA[
   \begin {forest}
     [\texttt {Union}
      [\texttt {Null}]
      [\texttt {Concat}
       [$\texttt {Sym}_{a}$]
       [\texttt {Star} [$\texttt {Sym}_{b}$]]
      ]
     ]
   \end {forest}
 ]]></fr:resource-source>
                      </fr:resource>
                    </html:figure>
                    <html:p>Observe that we had to decide whether how tightly the concatenation and union operators bind with respect to each other. That is part of defining the <html:em>parsing</html:em> relation.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017B/</fr:uri>
                    <fr:display-uri>jms-017B</fr:display-uri>
                    <fr:route>/jms-017B/</fr:route>
                    <fr:title text="Precedence parsing for regular expressions">Precedence parsing for regular expressions</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Parsing is decribed by a <fr:link href="/jms-00I7/" title="Relation" uri="https://www.jonmsterling.com/jms-00I7/" display-uri="jms-00I7" type="local">relation</fr:link> from concrete syntax to abstract syntax. Ideally, this relation would be <fr:link href="/jms-00K7/" title="Partial function" uri="https://www.jonmsterling.com/jms-00K7/" display-uri="jms-00K7" type="local">functional</fr:link> and so give rise to a <fr:link href="/jms-00K7/" title="Partial function" uri="https://www.jonmsterling.com/jms-00K7/" display-uri="jms-00K7" type="local">partial function</fr:link>. In order to achieve this, we address ahead of time any ambiguity in how tightly operators bind: for example, <fr:tex display="inline"><![CDATA[ab\vert  c]]></fr:tex> should be the union of <fr:tex display="inline"><![CDATA[ab]]></fr:tex> and <fr:tex display="inline"><![CDATA[c]]></fr:tex>, rather than the concatenation of <fr:tex display="inline"><![CDATA[a]]></fr:tex> with <fr:tex display="inline"><![CDATA[b\vert  c]]></fr:tex>.</html:p>
                    <html:p>This can be achieved by defining a more complex three-place relation <fr:tex display="block"><![CDATA[{r} \leadsto  {R} \mathrel {@} {n}]]></fr:tex> on concrete syntax <fr:tex display="inline"><![CDATA[r]]></fr:tex>, abstract syntax <fr:tex display="inline"><![CDATA[R]]></fr:tex>, and <html:em>precedences</html:em> <fr:tex display="inline"><![CDATA[n]]></fr:tex>. The idea is that we parse operations in the order of increasing tightness/precedence: in this case, that will be <fr:tex display="inline"><![CDATA[\texttt {Union}]]></fr:tex> followed by <fr:tex display="inline"><![CDATA[\texttt {Concat}]]></fr:tex> followed by <fr:tex display="inline"><![CDATA[\texttt {Star}]]></fr:tex> followed by all the atomic regular expressions: <fr:tex display="inline"><![CDATA[\texttt {Sym}_{a}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\texttt {Null}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[\texttt {Never}]]></fr:tex>.</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {gathered}
   
 
 \displaystyle \frac {\displaystyle 
    {r} \leadsto  {R} \mathrel {@} {0}
    \quad 
    {s} \leadsto  {S} \mathrel {@} {1}
   }{\displaystyle \quad 
    {r\vert  s} \leadsto  {\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}} \mathrel {@} {0}
   \quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle 
    {r} \leadsto  {R} \mathrel {@} {1}
    \quad 
    {s} \leadsto  {S} \mathrel {@} {2}
   }{\displaystyle \quad 
    {rs} \leadsto  {\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}} \mathrel {@} {1}
   \quad }


   \\[10pt]
   
 
 \displaystyle \frac {\displaystyle 
    {r} \leadsto  {R} \mathrel {@} {2}
   }{\displaystyle \quad 
    {r*} \leadsto  {\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}} \mathrel {@} {2}
   \quad }


   \\[10pt]
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
    {a} \leadsto  {\texttt {Sym}_{a}} \mathrel {@} {3}
   \quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
    {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {3}
   \quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
    {\varnothing } \leadsto  {\texttt {Never}} \mathrel {@} {3}
   \quad }


  \end {gathered}
]]></fr:tex>
                    <html:p>If we are parsing, e.g., unions but we encounter only a symbol, that needs to be allowed too. So we add a rule that coerces a higher precedence to a lower one silently:</html:p>
                    <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  {r} \leadsto  {R} \mathrel {@} {n+k}
 }{\displaystyle \quad 
  {r} \leadsto  {R} \mathrel {@} {n}
 \quad }


]]></fr:tex>
                    <html:p>Finally, we allow the use of parentheses to coerce a precedences in the other direction; this is what would make it possible to concatenate a union with another regular expression.</html:p>
                    <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  {r} \leadsto  {R} \mathrel {@} {n - k}
 }{\displaystyle \quad 
  {(r)} \leadsto  {R} \mathrel {@} {n}
 \quad }


]]></fr:tex>
                    <html:p>We then define the parsing relation <fr:tex display="inline"><![CDATA[{r}\leadsto  {R}]]></fr:tex> to hold if and only if <fr:tex display="inline"><![CDATA[{r} \leadsto  {R} \mathrel {@} {0}]]></fr:tex> holds. We demonstrate parsing <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> for <fr:tex display="inline"><![CDATA[\underline {\epsilon }\vert  ab*]]></fr:tex> and <fr:tex display="inline"><![CDATA[(\underline {\epsilon }\vert  a)b*]]></fr:tex> as follows:</html:p>
                    <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {3}\quad }


  }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {0}\quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {a} \leadsto  {\texttt {Sym}_{a}} \mathrel {@} {3}\quad }


   }{\displaystyle \quad {a} \leadsto  {\texttt {Sym}_{a}} \mathrel {@} {1}\quad }


   \quad 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle 
     
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {b} \leadsto  {\texttt {Sym}_{b}} \mathrel {@} {3}\quad }


    }{\displaystyle \quad {b} \leadsto  {\texttt {Sym}_{b}} \mathrel {@} {2}\quad }


   }{\displaystyle \quad {b*} \leadsto  {\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}} \mathrel {@} {2}\quad }


  }{\displaystyle \quad {ab*} \leadsto  {\texttt {Concat}{\mathopen {}\left (\texttt {Sym}_{a},\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}\right )\mathclose {}}} \mathrel {@} {1}\quad }


 }{\displaystyle \quad 
  {\underline {\epsilon }\vert  ab*} \leadsto  {\texttt {Union}{\mathopen {}\left (\texttt {Null},\texttt {Concat}{\mathopen {}\left (\texttt {Sym}_{a},\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}\right )\mathclose {}}\right )\mathclose {}}} \mathrel {@} {0}
 \quad }


]]></fr:tex>
                    <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle 
     
 
 \displaystyle \frac {\displaystyle 
      
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {3}\quad }


     }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {0}\quad }


     \quad 
     
 
 \displaystyle \frac {\displaystyle 
      
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Sym}_{a}} \mathrel {@} {3}\quad }


     }{\displaystyle \quad {\underline {\epsilon }} \leadsto  {\texttt {Null}} \mathrel {@} {\texttt {Sym}_{a}}{0}\quad }


    }{\displaystyle \quad 
     {\underline {\epsilon }\vert  a} \leadsto  {
      \texttt {Union}{\mathopen {}\left (\texttt {Null},\texttt {Sym}_{a}\right )\mathclose {}}
     } \mathrel {@} {0}
    \quad }


   }{\displaystyle \quad 
    {{\mathopen {}\left (\underline {\epsilon }\vert  a\right )\mathclose {}}} \leadsto  {
     \texttt {Union}{\mathopen {}\left (\texttt {Null},\texttt {Sym}_{a}\right )\mathclose {}}
    } \mathrel {@} {1}
   \quad }


   \quad 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle 
     
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad {b} \leadsto  {\texttt {Sym}_{b}} \mathrel {@} {3}\quad }


    }{\displaystyle \quad {b} \leadsto  {\texttt {Sym}_{b}} \mathrel {@} {2}\quad }


   }{\displaystyle \quad 
    {b*} \leadsto  {\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}} \mathrel {@} {2}
   \quad }


  }{\displaystyle \quad 
   {{\mathopen {}\left (\underline {\epsilon }\vert  a\right )\mathclose {}}b*} \leadsto  {
    \texttt {Concat}{\mathopen {}\left (\texttt {Union}{\mathopen {}\left (\texttt {Null},\texttt {Sym}_{a}\right )\mathclose {}},\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}\right )\mathclose {}}
   } \mathrel {@} {1}
  \quad }


 }{\displaystyle \quad 
  {{\mathopen {}\left (\underline {\epsilon }\vert  a\right )\mathclose {}}b*} \leadsto  {
   \texttt {Concat}{\mathopen {}\left (\texttt {Union}{\mathopen {}\left (\texttt {Null},\texttt {Sym}_{a}\right )\mathclose {}},\texttt {Star}{\mathopen {}\left (\texttt {Sym}_{b}\right )\mathclose {}}\right )\mathclose {}}
  } \mathrel {@} {0}
 \quad }


]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017C/</fr:uri>
                <fr:display-uri>jms-017C</fr:display-uri>
                <fr:route>/jms-017C/</fr:route>
                <fr:title text="Regular expression matching">Regular expression matching</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We have seen the <fr:link href="/jms-0178/" title="Regular expressions" uri="https://www.jonmsterling.com/jms-0178/" display-uri="jms-0178" type="local"><html:em>syntax</html:em> of regular expressions</fr:link> in both concrete and abstract form. What about <html:em>semantics</html:em>, i.e. what do regular expressions actually do? The meaning of a given regular expression over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is a <html:em><html:strong>matching predicate</html:strong></html:em> on <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> that says when a given string is matched by the regular expression. In this course, we are particularly interested in the class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> that can be recognised by regular expressions, and later on we will develop tools that allow us to show that some <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> are too complex to be recognised by regular expressions. In the meanwhile, we will first explain how matching works.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017D/</fr:uri>
                    <fr:display-uri>jms-017D</fr:display-uri>
                    <fr:route>/jms-017D/</fr:route>
                    <fr:title text="The matching relation for regular expressions">The matching relation for regular expressions</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The matching relation <fr:tex display="inline"><![CDATA[u\mathrel {\textsf {matches}}R]]></fr:tex> is given by an <html:em>inductive</html:em> definition over <fr:tex display="inline"><![CDATA[\Sigma ^\star \times \mathsf {Regexp}_{\Sigma }]]></fr:tex>.</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {gathered}
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({a},{\texttt {Sym}_{a}}\right )\mathclose {}}
  \quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Null}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({u},{\texttt {Union}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({v},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({w},{S}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({vw},{\texttt {Concat}{\mathopen {}\left (R,S\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \\[10pt]
  
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 
   {\mathopen {}\left ({\epsilon },{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


  \qquad 
  
 
 \displaystyle \frac {\displaystyle 
   {\mathopen {}\left ({u},{R}\right )\mathclose {}}
   \quad 
   {\mathopen {}\left ({v},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  }{\displaystyle \quad 
   {\mathopen {}\left ({uv},{\texttt {Star}{\mathopen {}\left (R\right )\mathclose {}}}\right )\mathclose {}}
  \quad }


 \end {gathered}
]]></fr:tex>
                    <html:p>We will write <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (R\right )\mathclose {}}]]></fr:tex> for the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> matching or “recognised” by the regular expression <fr:tex display="inline"><![CDATA[R]]></fr:tex>:</html:p>
                    <fr:tex display="block"><![CDATA[
 \mathcal {L}{\mathopen {}\left (R\right )\mathclose {}} =
 {\mathopen {}\left \{
  u\in \Sigma ^\star 
  \mid 
  u\mathrel {\textsf {matches}}R
 \right \}\mathclose {}}
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>We can also obtain a version of the <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">matching relation</fr:link> between <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> and <fr:link href="/jms-0176/" title="Regular expressions (concrete syntax)" uri="https://www.jonmsterling.com/jms-0176/" display-uri="jms-0176" type="local"><html:em>concrete</html:em> regular expressions</fr:link> by <fr:link href="/jms-00IN/" title="Relational composite" uri="https://www.jonmsterling.com/jms-00IN/" display-uri="jms-00IN" type="local">relational composition</fr:link> with the (transpose of) the <fr:link href="/jms-017B/" title="Precedence parsing for regular expressions" uri="https://www.jonmsterling.com/jms-017B/" display-uri="jms-017B" type="local">parsing relation</fr:link>. Alternatively, we can simply <html:em>write</html:em> the concrete syntax as a mere notation (to be eliminated by the reader immediately) for the abstract syntax. In fact, that is what we will do in the future.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017E/</fr:uri>
                    <fr:display-uri>jms-017E</fr:display-uri>
                    <fr:route>/jms-017E/</fr:route>
                    <fr:title text="Examples of regular expression matching">Examples of regular expression matching</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Consider <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">regular expression matching</fr:link> over the alphabet <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex>.</html:p>
                    <html:ol><html:li><fr:tex display="inline"><![CDATA[a\vert  b]]></fr:tex> is matched by each symbol in <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[(a\vert  b)*]]></fr:tex> is matched every <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[b(a\vert  b)*]]></fr:tex> is matched by any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> that starts with a <fr:tex display="inline"><![CDATA[b]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[((a\vert  b)(a\vert  b))*]]></fr:tex> is matched by any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> of even length over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[(\underline {\epsilon }\vert  a)(\underline {\epsilon }\vert  b)\vert  bb]]></fr:tex> is matched just by the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>, <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, <fr:tex display="inline"><![CDATA[ab]]></fr:tex>, and <fr:tex display="inline"><![CDATA[bb]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[\varnothing  b\vert  a]]></fr:tex> is matched only by the symbol <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017F/</fr:uri>
                    <fr:display-uri>jms-017F</fr:display-uri>
                    <fr:route>/jms-017F/</fr:route>
                    <fr:title text="Questions about regular expression matching">Questions about regular expression matching</fr:title>
                    <fr:taxon>Discussion</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Here are some questions for discussion.</html:p>
                    <html:ol><html:li>Is there an algorithm which, given a string <fr:tex display="inline"><![CDATA[u]]></fr:tex> and a regular expression <fr:tex display="inline"><![CDATA[r]]></fr:tex>, computes whether or not <fr:tex display="inline"><![CDATA[u]]></fr:tex> matches <fr:tex display="inline"><![CDATA[r]]></fr:tex>?</html:li>
 <html:li>In formulating the definition of regular expressions, have we missed out on some practically useful notions of pattern?</html:li>
 <html:li>Is there an algorithm that will compute whether two regular expressions generate the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>?</html:li>
 <html:li>Is every <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> of generated by a regular expression?</html:li></html:ol>
                    <html:p>We will come back to these questions in subsequent lectures. In the meantime, we can say:</html:p>
                    <html:ol><html:li><html:em>Is there an algorithm which, given a string <fr:tex display="inline"><![CDATA[u]]></fr:tex> and a regular expression <fr:tex display="inline"><![CDATA[r]]></fr:tex>, computes whether or not <fr:tex display="inline"><![CDATA[u]]></fr:tex> matches <fr:tex display="inline"><![CDATA[r]]></fr:tex>?</html:em> Yes. One very simple way is to simply use the rules of <fr:link href="/jms-017D/" title="The matching relation for regular expressions" uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-017D/" display-uri="jms-017D" /></fr:link> as a search algorithm, but this is not very efficient; better ways to decide regular expression matching can be achieved using <html:em>finite automata</html:em>, which we will study in the next lecture.</html:li>
 <html:li><html:em>In formulating the definition of regular expressions, have we missed out on some practically useful notions of pattern?</html:em>
  Yes! For example, it can be useful to specify a <html:em>range</html:em> of symbols (including all symbols!) over an alphabet like most practical regular expression libraries allow. A more sophisticated example is complementation, where a <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> matches <fr:tex display="inline"><![CDATA[\mathord {\sim }(r)]]></fr:tex> if and only if it does <html:em>not</html:em> match <fr:tex display="inline"><![CDATA[r]]></fr:tex>. We will ultimately see that the complement of any regular expression already exists—but it can be useful to include it as a built-in feature.</html:li>
 <html:li><html:em>Is there an algorithm that will compute whether two regular expressions generate the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>?</html:em> Yes, but we will need the theory of finite automata to see that this is the case.</html:li>
 <html:li><html:em>Is every <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> of generated by a regular expression?</html:em> No: we will ultimately learn a technique, called the <html:em>pumping lemma</html:em> to find counter-examples.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/ianleslie/" title="Ian Leslie" uri="https://www.jonmsterling.com/ianleslie/" display-uri="ianleslie" type="local">Ian Leslie</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-016F/</fr:uri>
            <fr:display-uri>jms-016F</fr:display-uri>
            <fr:route>/jms-016F/</fr:route>
            <fr:title text="Lecture 20: formal languages, inductive definitions, rule induction">Lecture 20: formal languages, inductive definitions, rule induction</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> by adapting prior notes created by <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link> that I inherited from <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>7</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-016G/</fr:uri>
                <fr:display-uri>jms-016G</fr:display-uri>
                <fr:route>/jms-016G/</fr:route>
                <fr:title text="Formal languages">Formal languages</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016H/</fr:uri>
                    <fr:display-uri>jms-016H</fr:display-uri>
                    <fr:route>/jms-016H/</fr:route>
                    <fr:title text="Alphabet">Alphabet</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>An <html:em><html:strong>alphabet</html:strong></html:em> is specified by giving a <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local">finite set</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> whose elements are called <html:em>symbols</html:em>. Any <fr:link href="/jms-00LX/" title="Finite set" uri="https://www.jonmsterling.com/jms-00LX/" display-uri="jms-00LX" type="local">finite set</fr:link> can serve as an alphabet as far as we are concerned.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016I/</fr:uri>
                    <fr:display-uri>jms-016I</fr:display-uri>
                    <fr:route>/jms-016I/</fr:route>
                    <fr:title text="String over an alphabet">String over an alphabet</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> be an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link>. A <html:em><html:strong>string of length <fr:tex display="inline"><![CDATA[n]]></fr:tex></html:strong></html:em> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined to be an <fr:tex display="inline"><![CDATA[n]]></fr:tex>-tuple of elements of <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. We write these without any punctuation between them. For example, <fr:tex display="inline"><![CDATA[aaabc]]></fr:tex> is a string over the Latin alphabet; we will write <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> for the empty string. The set of all strings (of any length) over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is written <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex>; for a string <fr:tex display="inline"><![CDATA[u\in \Sigma ^\star ]]></fr:tex>, we will write <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert u\right \rvert \mathclose {}}\in \mathbb {N}]]></fr:tex> for its length.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016J/</fr:uri>
                    <fr:display-uri>jms-016J</fr:display-uri>
                    <fr:route>/jms-016J/</fr:route>
                    <fr:title text="Concatenation of strings">Concatenation of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">Strings</fr:link> over a fixed <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> can be concatenated. When <fr:tex display="inline"><![CDATA[u,v\in \Sigma ^\star ]]></fr:tex> are two <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>, their <html:em><html:strong>concatenation</html:strong></html:em> is denoted <fr:tex display="inline"><![CDATA[uv\in  \Sigma ^\star ]]></fr:tex> and is obtained by joining them end-to-end.</html:p>
                    <html:p>For example, if <fr:tex display="inline"><![CDATA[u=ab]]></fr:tex> and <fr:tex display="inline"><![CDATA[v=ba]]></fr:tex> then <fr:tex display="inline"><![CDATA[uv]]></fr:tex> = <fr:tex display="inline"><![CDATA[abba]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016K/</fr:uri>
                    <fr:display-uri>jms-016K</fr:display-uri>
                    <fr:route>/jms-016K/</fr:route>
                    <fr:title text="Properties of concatenation">Properties of <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">concatenation</fr:link></fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">Concatenation</fr:link> satisfies several algebraic laws:</html:p>
                    <html:ol><html:li>The <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">empty string</fr:link> <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> is a neutral element for <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">concatenation</fr:link> on both the left and right right:
   <fr:tex display="block"><![CDATA[\forall  u\in \Sigma ^\star \mathpunct {.} \epsilon  u = u\land  u\epsilon  = u]]></fr:tex></html:li>
 <html:li><fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">Concatenation</fr:link> is associative:
  <fr:tex display="block"><![CDATA[
   \forall  u,v,w\in \Sigma ^\star 
   \mathpunct {.}
   u(vw) = (uv)w
  ]]></fr:tex></html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016L/</fr:uri>
                    <fr:display-uri>jms-016L</fr:display-uri>
                    <fr:route>/jms-016L/</fr:route>
                    <fr:title text="Monoid structure of strings">Monoid structure of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link></fr:title>
                    <fr:taxon>Observation</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>By <fr:link href="/jms-016K/" title="Properties of concatenation" uri="https://www.jonmsterling.com/jms-016K/" display-uri="jms-016K" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-016K/" display-uri="jms-016K" /></fr:link>, <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> under <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">concatenation</fr:link> form a <html:em>monoid</html:em>, but not a commutative monoid (indeed, we don’t have <fr:tex display="inline"><![CDATA[uv=vu]]></fr:tex> unless either <fr:tex display="inline"><![CDATA[u]]></fr:tex> or <fr:tex display="inline"><![CDATA[v]]></fr:tex> is empty or <fr:tex display="inline"><![CDATA[u=v]]></fr:tex>). Viewing <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex> as a monoid, we see that the length function <fr:tex display="inline"><![CDATA[{\mathopen {}\left \lvert -\right \rvert \mathclose {}}\colon  \Sigma ^\star \to \mathbb {N}]]></fr:tex> is a homomorphism of monoids from <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">strings</fr:link> to the additive monoid of the natural numbers:</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {aligned}
 {\mathopen {}\left \lvert \epsilon \right \rvert \mathclose {}} &= 0\\
 {\mathopen {}\left \lvert uv\right \rvert \mathclose {}} &= {\mathopen {}\left \lvert u\right \rvert \mathclose {}}+{\mathopen {}\left \lvert v\right \rvert \mathclose {}}
 \end {aligned}
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>We are now ready to define what a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is. We are used to thinking of languages as being defined by a grammar, but a more abstract or “extensional” point of view is that a formal language is nothing more than the set of strings it generates. We adopt that perspective below.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016M/</fr:uri>
                    <fr:display-uri>jms-016M</fr:display-uri>
                    <fr:route>/jms-016M/</fr:route>
                    <fr:title text="Formal language">Formal language</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <html:em><html:strong>formal language</html:strong></html:em> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined to be a <html:em>subset</html:em> of <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex>, i.e. a set of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>Although we have defined <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> in this very extensional manner, “rules of grammar” still plays a role: in particular, we will use <html:em>inductive definitions</html:em> of grammatical rules to generate formal languages by building on our prior experience with inductive definitions:</html:p>
                <html:ol><html:li>In <fr:link href="/jms-00JA/" title="Lecture 14: directed graphs and paths" uri="https://www.jonmsterling.com/jms-00JA/" display-uri="jms-00JA" type="local">Lecture 14</fr:link>, we learned how to define the reflexive-transitive closure of a binary relation on a set, i.e. the path relation on a directed graph.</html:li>
 <html:li>In <fr:link href="/jms-00KG/" title="functions are uniquely-valued relations" uri="https://www.jonmsterling.com/jms-00KG/" display-uri="jms-00KG" type="local">Lecture 15</fr:link>, we learned how to <fr:link href="/jms-00KP/" title="Existence of inductively defined functions" uri="https://www.jonmsterling.com/jms-00KP/" display-uri="jms-00KP" type="local">define a function inductively</fr:link> by taking the least relation “closed” under some clauses.</html:li></html:ol>
                <html:p>In what remains of this lecture, we will be studying strategies for defining and using inductive definitions of subsets of a given set.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>7</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-016N/</fr:uri>
                <fr:display-uri>jms-016N</fr:display-uri>
                <fr:route>/jms-016N/</fr:route>
                <fr:title text="Inductive definitions">Inductive definitions</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-016O/</fr:uri>
                    <fr:display-uri>jms-016O</fr:display-uri>
                    <fr:route>/jms-016O/</fr:route>
                    <fr:title text="Axioms and rules">Axioms and rules</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In many cases, a subset is defined implicitly by describing the <html:em>rules</html:em> that you must follow in order to construct an element of it.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016Q/</fr:uri>
                        <fr:display-uri>jms-016Q</fr:display-uri>
                        <fr:route>/jms-016Q/</fr:route>
                        <fr:title text="Informal rules for constructing naturals">Informal rules for constructing naturals</fr:title>
                        <fr:taxon>Example</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>For example, consider the set of natural numbers <fr:tex display="inline"><![CDATA[\mathbb {N}]]></fr:tex> viewed as a subset of the reals <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex>; this could be described by the following rules of construction:</html:p>
                        <html:ol><html:li><fr:tex display="inline"><![CDATA[0]]></fr:tex> is a natural number.</html:li>
 <html:li>If <fr:tex display="inline"><![CDATA[x]]></fr:tex> is a natural number, then <fr:tex display="inline"><![CDATA[x+1]]></fr:tex> is also a natural number.</html:li></html:ol>
                        <html:p>The set of natural numbers is then described as the <html:em>smallest</html:em> subset of <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> that obeys these rules, i.e. the <html:em>intersection</html:em> of all the subsets of <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> that contain <fr:tex display="inline"><![CDATA[0]]></fr:tex> and are closed under the successor function <fr:tex display="inline"><![CDATA[x \mapsto  x+1]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>This is the same process as we saw when <fr:link href="/jms-00KP/" title="Existence of inductively defined functions" uri="https://www.jonmsterling.com/jms-00KP/" display-uri="jms-00KP" type="local">constructing</fr:link> <fr:link href="/jms-00KM/" title="Inductively defined function" uri="https://www.jonmsterling.com/jms-00KM/" display-uri="jms-00KM" type="local">inductively defined functions</fr:link>, where we first defined the equational rules we wanted the function to follow as a <html:em>closure condition</html:em> on a relation and then we defined the function as the smallest relation satisfying the closure condition.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016R/</fr:uri>
                        <fr:display-uri>jms-016R</fr:display-uri>
                        <fr:route>/jms-016R/</fr:route>
                        <fr:title text="Inductive definition of the naturals via closure conditions">Inductive definition of the naturals via closure conditions</fr:title>
                        <fr:taxon>Example</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In <fr:link href="/jms-016Q/" title="Informal rules for constructing naturals" uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" /></fr:link> we described the rules for constructing natural numbers in plain English. Formally, the two rules above would be understood each as a subset of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (\mathbb {R}\right )\mathclose {}}]]></fr:tex>.</html:p>
                        <fr:tex display="block"><![CDATA[
 \begin {aligned}
   \mathsf {ZeroClosed},\mathsf {SuccClosed} &\subseteq  \mathcal {P}{\mathopen {}\left (\mathbb {R}\right )\mathclose {}}
   \\
   S\in \mathsf {ZeroClosed} &\Leftrightarrow  0\in  S\\
   S\in \mathsf {SuccClosed} &\Leftrightarrow  \forall  x\in  S\mathpunct {.} x+1\in  S
 \end {aligned}
]]></fr:tex>
                        <html:p>Then natural numbers would be defined to be the smallest subset of <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> that lies both in <fr:tex display="inline"><![CDATA[\mathsf {ZeroClosed}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathsf {SuccClosed}]]></fr:tex>:</html:p>
                        <fr:tex display="block"><![CDATA[
 \mathbb {N} =
 \bigcap {\mathopen {}\left \{S\subseteq \mathbb {R}\,\middle \vert \,S\in  \mathsf {ZeroClosed}\cap \mathsf {SuccClosed}\right \}\mathclose {}}
]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>8</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0172/</fr:uri>
                        <fr:display-uri>jms-0172</fr:display-uri>
                        <fr:route>/jms-0172/</fr:route>
                        <fr:title text="Closure conditions must be closed under intersection">Closure conditions must be closed under intersection</fr:title>
                        <fr:taxon>Warning</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In general, for the definition of <fr:tex display="inline"><![CDATA[\mathbb {N}\subseteq \mathbb {R}]]></fr:tex> in <fr:link href="/jms-016R/" title="Inductive definition of the naturals via closure conditions" uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" /></fr:link> to work, the subsets of <fr:tex display="inline"><![CDATA[\pow {X}]]></fr:tex> must themselves be closed under intersection: otherwise, taking the big intersection to get the smallest subset “closed under the rules” might not work because the intersection might no longer be closed under the rules. So, for example, you need to check that if you have a family of subsets <fr:tex display="inline"><![CDATA[X_i\subseteq  \mathbb {R}]]></fr:tex>, then if each <fr:tex display="inline"><![CDATA[X_i\in \mathsf {SuccClosed}]]></fr:tex> we also have <fr:tex display="inline"><![CDATA[\bigcap _i X_i\in  \mathsf {SuccClosed}]]></fr:tex>. But this is nearly always obvious for closure conditions encountered in practice.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016P/</fr:uri>
                        <fr:display-uri>jms-016P</fr:display-uri>
                        <fr:route>/jms-016P/</fr:route>
                        <fr:title text="Syntactic description of rules">Syntactic description of rules</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The plain-English description of rules of construction that we saw in <fr:link href="/jms-016Q/" title="Informal rules for constructing naturals" uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" /></fr:link> are a bit lengthy to read and write; by contrast, the more precise depiction of rules as subsets of the powerset that we saw in <fr:link href="/jms-016R/" title="Inductive definition of the naturals via closure conditions" uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" /></fr:link> is perhaps overly formal and obfuscated. For this reason, computer scientists and logicians have developed an alternative notation for describing rules of construction that involves drawing things above and below horizontal lines (these are not fractions!).</html:p>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>7</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-016S/</fr:uri>
                            <fr:display-uri>jms-016S</fr:display-uri>
                            <fr:route>/jms-016S/</fr:route>
                            <fr:title text="Syntactic rule">Syntactic rule</fr:title>
                            <fr:taxon>Definition</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>The basic form of a rule that describes a subset of a set <fr:tex display="inline"><![CDATA[X]]></fr:tex> is as follows:</html:p>
                            <fr:tex display="block"><![CDATA[
 \frac {
  u_1 \quad  \ldots  \quad  u_n
 }{
  v
 }
]]></fr:tex>
                            <html:p>The plain English meaning of the rule is: <html:em>If <fr:tex display="inline"><![CDATA[u_1]]></fr:tex> through <fr:tex display="inline"><![CDATA[u_n]]></fr:tex> are elements of the subset that I am defining, then so is <fr:tex display="inline"><![CDATA[v]]></fr:tex>.</html:em> In such a rule, the items on top of the horizontal line are called <html:em><html:strong>premises</html:strong></html:em> or <html:em><html:strong>antecedents</html:strong></html:em> or <html:em><html:strong>hypotheses</html:strong></html:em>, and the item on the bottom of the horizontal line is called the <html:em><html:strong>conclusion</html:strong></html:em>. When a rule has no premises, it is called an <html:em><html:strong>axiom</html:strong></html:em>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>7</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-016T/</fr:uri>
                            <fr:display-uri>jms-016T</fr:display-uri>
                            <fr:route>/jms-016T/</fr:route>
                            <fr:title text="syntactic rules for forming natural numbers"><fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> for forming natural numbers</fr:title>
                            <fr:taxon>Example</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>We can translate the <fr:link href="/jms-016Q/" title="Informal rules for constructing naturals" uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" type="local">plain-English description of the natural numbers</fr:link> into the syntactic form specified by <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" /></fr:link>. In particular, the rules expression closure under zero and successor are rendered as follows:</html:p>
                            <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 0\quad }


 \qquad 
 
 
 \displaystyle \frac {\displaystyle x}{\displaystyle \quad x+1\quad }


]]></fr:tex>
                            <html:p>The above are to be understood as <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> describing a subset of <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex>. The first rule is an <html:em>axiom</html:em> in the sense of our definition, because it has no premises.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2025</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>7</fr:day>
                            </fr:date>
                            <fr:uri>https://www.jonmsterling.com/jms-016U/</fr:uri>
                            <fr:display-uri>jms-016U</fr:display-uri>
                            <fr:route>/jms-016U/</fr:route>
                            <fr:title text="The closure condition denoted by a syntactic rule">The closure condition denoted by a <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rule</fr:link></fr:title>
                            <fr:taxon>Definition</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>A <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rule</fr:link> like <fr:tex display="inline"><![CDATA[
 \scriptstyle \frac {\scriptstyle u_1\quad \ldots \quad  u_n}{\scriptstyle v}
]]></fr:tex> on a set <fr:tex display="inline"><![CDATA[X]]></fr:tex> denotes a <html:em>closure condition</html:em> on subsets of <fr:tex display="inline"><![CDATA[X]]></fr:tex>, i.e. a subset of the powerset <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (X\right )\mathclose {}}]]></fr:tex>. In particular, the meaning of this rule is the following subset of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (X\right )\mathclose {}}]]></fr:tex>:</html:p>
                            <fr:tex display="block"><![CDATA[
 {\mathopen {}\left \{S\subseteq  X\,\middle \vert \,
  u_1,\ldots ,u_n\in  S\implies 
  v\in  S
 \right \}\mathclose {}}
]]></fr:tex>
                            <html:p>When <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex> is a set of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rules</fr:link> over <fr:tex display="inline"><![CDATA[X]]></fr:tex>, we will write <fr:tex display="inline"><![CDATA[\mathrm {Cl}_{\mathcal {R}}\subseteq  \mathcal {P}{\mathopen {}\left (X\right )\mathclose {}}]]></fr:tex> for the intersection of the closure conditions denoted by each rule in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>. This is, in other words, the set of subsets of <fr:tex display="inline"><![CDATA[X]]></fr:tex> that lie in the <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closure condition</fr:link> for each <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rule</fr:link> <fr:tex display="inline"><![CDATA[r\in  \mathcal {R}]]></fr:tex>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <html:p>In light of <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" /></fr:link>, we see that the closure conditions denoted by the syntactic rules for the naturals in <fr:link href="/jms-016T/" title="syntactic rules for forming natural numbers" uri="https://www.jonmsterling.com/jms-016T/" display-uri="jms-016T" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016T/" display-uri="jms-016T" /></fr:link> are precisely those specified in <fr:link href="/jms-016R/" title="Inductive definition of the naturals via closure conditions" uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" /></fr:link>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016X/</fr:uri>
                        <fr:display-uri>jms-016X</fr:display-uri>
                        <fr:route>/jms-016X/</fr:route>
                        <fr:title text="Derivations">Derivations</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In the presence of a set <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex> of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> describing a subset of <fr:tex display="inline"><![CDATA[X]]></fr:tex>, a <html:em><html:strong>derivation</html:strong></html:em> that a particular element <fr:tex display="inline"><![CDATA[u]]></fr:tex> lies in that subset is given by a finite tree with vertices labelled by elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> such that:</html:p>
                        <html:ol><html:li>the root of the tree is <fr:tex display="inline"><![CDATA[u]]></fr:tex>;</html:li>
 <html:li>each vertex of the tree is the <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">conclusion</fr:link> of a rule whose <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">premises</fr:link> are the children of the node</html:li>
 <html:li>each leaf of the tree is an <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">axiom</fr:link>.</html:li></html:ol>
                        <html:p>Viewing a tree as growing upwards from the root, we have the following derivation for <fr:tex display="inline"><![CDATA[3\in \mathbb {N}]]></fr:tex> in when <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex> is the two rules from <fr:link href="/jms-016T/" title="syntactic rules for forming natural numbers" uri="https://www.jonmsterling.com/jms-016T/" display-uri="jms-016T" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016T/" display-uri="jms-016T" /></fr:link>:</html:p>
                        <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad 0\quad }


   }{\displaystyle \quad 1\quad }


  }{\displaystyle \quad 2\quad }


 }{\displaystyle \quad 3\quad }


]]></fr:tex>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>We recall the definition of a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local"><html:em>formal language</html:em></fr:link>:</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016M/</fr:uri>
                        <fr:display-uri>jms-016M</fr:display-uri>
                        <fr:route>/jms-016M/</fr:route>
                        <fr:title text="Formal language">Formal language</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A <html:em><html:strong>formal language</html:strong></html:em> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined to be a <html:em>subset</html:em> of <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex>, i.e. a set of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>Because a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> is nothing more than a subset, we can define them by rules of construction—either in the form of <fr:link href="/jms-016Q/" title="Informal rules for constructing naturals" uri="https://www.jonmsterling.com/jms-016Q/" display-uri="jms-016Q" type="local">plain English rules</fr:link>, <fr:link href="/jms-016R/" title="Inductive definition of the naturals via closure conditions" uri="https://www.jonmsterling.com/jms-016R/" display-uri="jms-016R" type="local">closure conditions</fr:link>, or <fr:link href="/jms-016T/" title="syntactic rules for forming natural numbers" uri="https://www.jonmsterling.com/jms-016T/" display-uri="jms-016T" type="local">syntactic rules</fr:link>. We will focus on the use of syntactic rules and their relationship to the closure conditions they denote.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>7</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016W/</fr:uri>
                        <fr:display-uri>jms-016W</fr:display-uri>
                        <fr:route>/jms-016W/</fr:route>
                        <fr:title text="Syntactic presentation of a formal language">Syntactic presentation of a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link></fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A <html:em><html:strong>syntactic presentation</html:strong></html:em> of a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is defined to be a set of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> over the set of <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">strings</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ^\star ]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>8</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016Y/</fr:uri>
                        <fr:display-uri>jms-016Y</fr:display-uri>
                        <fr:route>/jms-016Y/</fr:route>
                        <fr:title text="A syntactic presentation of a formal language">A <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">syntactic presentation</fr:link> of a <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link></fr:title>
                        <fr:taxon>Example</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We can <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">present</fr:link> an example <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over the <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma  = {\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> by a set of rules:</html:p>
                        <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u}{\displaystyle \quad aub\quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u}{\displaystyle \quad bua\quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u\quad  v}{\displaystyle \quad uv\quad }


]]></fr:tex>
                        <html:p>The <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[abaabb]]></fr:tex> can be generated from these rules in at least two ways by means of the following <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivations</fr:link>:</html:p>
                        <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


  }{\displaystyle \quad ab\quad }


  \quad 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


   }{\displaystyle \quad ab\quad }


  }{\displaystyle \quad aabb\quad }


 }{\displaystyle \quad abaabb\quad }


 \qquad 
 
 
 \displaystyle \frac {\displaystyle 
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


   }{\displaystyle \quad ba\quad }


   \quad 
   
 
 \displaystyle \frac {\displaystyle 
    
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


   }{\displaystyle \quad ab\quad }


  }{\displaystyle \quad baab\quad }


 }{\displaystyle \quad abaabb\quad }


]]></fr:tex>
                        <html:p>On the other hand, there is <html:em>no</html:em> <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> for the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[abaab]]></fr:tex>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>8</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-016Z/</fr:uri>
                        <fr:display-uri>jms-016Z</fr:display-uri>
                        <fr:route>/jms-016Z/</fr:route>
                        <fr:title text="Revisiting reflexive-transitive closure">Revisiting <fr:link href="/jms-003K/" title="Initial objects in wild categories" uri="https://www.jonmsterling.com/jms-003K/" display-uri="jms-003K" type="local">reflexive-transitive closure</fr:link></fr:title>
                        <fr:taxon>Example</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Let <fr:tex display="inline"><![CDATA[R\colon  X\mathbin {\nrightarrow } X]]></fr:tex> be a binary <fr:link href="/jms-00I7/" title="Relation" uri="https://www.jonmsterling.com/jms-00I7/" display-uri="jms-00I7" type="local">relation</fr:link> on a set <fr:tex display="inline"><![CDATA[X]]></fr:tex>. In <fr:link href="/jms-00JA/" title="Lecture 14: directed graphs and paths" uri="https://www.jonmsterling.com/jms-00JA/" display-uri="jms-00JA" type="local">Lecture 14</fr:link> we saw that the reflexive-transitive closure of <fr:tex display="inline"><![CDATA[R]]></fr:tex> can be defined in two equivalent ways:</html:p>
                        <html:ol><html:li><html:strong>Concretely:</html:strong> it can be <fr:link href="/jms-00JH/" title="The reflexive-transitive closure of an endo-relation" uri="https://www.jonmsterling.com/jms-00JH/" display-uri="jms-00JH" type="local">defined</fr:link> to be the smallest relation closed under all finite <fr:link href="/jms-00JF/" title="Path in a directed graph" uri="https://www.jonmsterling.com/jms-00JF/" display-uri="jms-00JF" type="local">paths</fr:link> in <fr:tex display="inline"><![CDATA[R]]></fr:tex>, viewed as a <fr:link href="/jms-00JC/" title="Directed graph" uri="https://www.jonmsterling.com/jms-00JC/" display-uri="jms-00JC" type="local">directed graph</fr:link>.</html:li>
 <html:li><html:strong>Abstractly:</html:strong> it is the <fr:link href="/jms-00JZ/" title="preorders and reflexive-transitive closure" uri="https://www.jonmsterling.com/jms-00JZ/" display-uri="jms-00JZ" type="local">smallest preorder</fr:link> containing <fr:tex display="inline"><![CDATA[R]]></fr:tex> as a subrelation.</html:li></html:ol>
                        <html:p>There is a “middle ground” between the most concrete and abstract ways of looking at reflexive-transitive closure: we can present it by means of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> whose <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">induced closure conditions</fr:link> isolate the “set of preorders containing <fr:tex display="inline"><![CDATA[R]]></fr:tex> as a subrelation”.</html:p>
                        <html:p>We first add the following <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rules</fr:link> over <fr:tex display="inline"><![CDATA[X\times  X]]></fr:tex> that correspond to the laws of a preorder.</html:p>
                        <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad (x,x)\quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle (x,y)\quad  (y,z)}{\displaystyle \quad (x,z)\quad }


]]></fr:tex>
                        <html:p>Finally, we add the following rule for any <fr:tex display="inline"><![CDATA[x,y\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\mathrel {R}y]]></fr:tex>:</html:p>
                        <fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad (x,y)\quad }

\quad  (x\mathrel {R}y)
]]></fr:tex>
                        <html:p>To be very clear, this last rule only applies when <fr:tex display="inline"><![CDATA[x\mathrel {R}y]]></fr:tex>. This is called a <html:em>side condition</html:em>.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                    <html:p>In order to see that the rules described in <fr:link href="/jms-016Z/" title="Revisiting reflexive-transitive closure" uri="https://www.jonmsterling.com/jms-016Z/" display-uri="jms-016Z" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016Z/" display-uri="jms-016Z" /></fr:link> actually define the reflexive transitive closure in the sense that a pair <fr:tex display="inline"><![CDATA[(x,y)]]></fr:tex> has a <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> if and only if there is a <fr:link href="/jms-00JF/" title="Path in a directed graph" uri="https://www.jonmsterling.com/jms-00JF/" display-uri="jms-00JF" type="local">path</fr:link> from <fr:tex display="inline"><![CDATA[x]]></fr:tex> to <fr:tex display="inline"><![CDATA[y]]></fr:tex>, we will need the <html:em>rule induction</html:em> theorem, which is the topic of the rest of this lecture.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>8</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0170/</fr:uri>
                <fr:display-uri>jms-0170</fr:display-uri>
                <fr:route>/jms-0170/</fr:route>
                <fr:title text="The rule induction principle">The rule induction principle</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We have been dancing around the relationship between sets of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> over a set <fr:tex display="inline"><![CDATA[X]]></fr:tex> the subsets of <fr:tex display="inline"><![CDATA[X]]></fr:tex> that they carve out by means of <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivations</fr:link>. <html:em><html:strong>Rule induction</html:strong></html:em> is the principle that allows us to prove that these two perspectives are equivalent.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>8</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0171/</fr:uri>
                    <fr:display-uri>jms-0171</fr:display-uri>
                    <fr:route>/jms-0171/</fr:route>
                    <fr:title text="Rule induction">Rule induction</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex> be a set of <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">syntactic rules</fr:link> over a set <fr:tex display="inline"><![CDATA[X]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}\subseteq  X]]></fr:tex> be the subset containing just those <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that there exists a derivation of <fr:tex display="inline"><![CDATA[x]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>.</html:p><html:p>Then <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex> is <html:em><fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closed under</fr:link></html:em> each of the <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rules</fr:link> in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex> and it is moreover the <html:em>smallest</html:em> such subset of <fr:tex display="inline"><![CDATA[X]]></fr:tex>. In other words, <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}\in  \mathrm {Cl}_{\mathcal {R}}]]></fr:tex> and if <fr:tex display="inline"><![CDATA[S\in \mathrm {Cl}_{\mathcal {R}}]]></fr:tex> then <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}\subseteq  S]]></fr:tex>. Equivalently, <fr:tex display="inline"><![CDATA[X_{\mathcal {R}} = \bigcap  \mathrm {Cl}_{\mathcal {R}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We first check that <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[\mathrm {Cl}_{\mathcal {R}}]]></fr:tex>. We first fix a <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rule</fr:link> in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>:</html:p>
 <fr:tex display="block"><![CDATA[
  
 
 \displaystyle \frac {\displaystyle u_1\quad \ldots \quad  u_n}{\displaystyle \quad v\quad }


 ]]></fr:tex>

 <html:p>We must show that <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex> satisfies the <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closure condition described</fr:link> by the rule depicted above. For that, we assume that <fr:tex display="inline"><![CDATA[u_1,\ldots ,u_n]]></fr:tex> lie in <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex> and we need to verify that <fr:tex display="inline"><![CDATA[v]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex>. By definition, we therefore have <fr:tex display="inline"><![CDATA[
 \scriptstyle \frac {\scriptstyle \vdots }{\scriptstyle u_i}
]]></fr:tex> <html:em><fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivations</fr:link></html:em> of each <fr:tex display="inline"><![CDATA[u_i]]></fr:tex> and we need to find a <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> of <fr:tex display="inline"><![CDATA[v]]></fr:tex>. We do this by combining the assumed <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivations</fr:link> using the rule as follows to obtain a <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> of <fr:tex display="inline"><![CDATA[v]]></fr:tex>:</html:p>
 <fr:tex display="block"><![CDATA[
  
 
 \displaystyle \frac {\displaystyle 
   
 
 \displaystyle \frac {\displaystyle \vdots }{\displaystyle \quad u_1\quad }

\quad \ldots \quad  
 
 \displaystyle \frac {\displaystyle \vdots }{\displaystyle \quad u_n\quad }


  }{\displaystyle \quad v\quad }


 ]]></fr:tex>
</fr:mainmatter></fr:tree>
 
<html:p>We have therefore shown that <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}\in \mathrm {Cl}_{\mathcal {R}}]]></fr:tex>.</html:p><html:p>For the remainder of the proof, we fix any <fr:tex display="inline"><![CDATA[S\in \mathcal {Cl}_{\mathcal {R}}]]></fr:tex> to check that <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}\subseteq  S]]></fr:tex>. In other words, we must prove:</html:p><html:blockquote>For all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x]]></fr:tex> has a <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[x\in  S]]></fr:tex>.</html:blockquote><html:p>But the above can be rephrased as follows:</html:p><html:blockquote>For all derivations <fr:tex display="inline"><![CDATA[d]]></fr:tex> generated by <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>, the conclusion of <fr:tex display="inline"><![CDATA[d]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:blockquote><html:p>As every derivation has a (maximum) height, we can further rephrase the goal in terms that will be amenable to the use of <html:em>mathematical induction</html:em>.</html:p><html:blockquote>For all <fr:tex display="inline"><![CDATA[n\in  \mathbb {N}]]></fr:tex>, the conclusion of any derivation with height less than or equal to <fr:tex display="inline"><![CDATA[n]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:blockquote><html:p>We now proceed by induction.</html:p><html:ol><html:li>In the <html:strong>base case</html:strong>, we must show that the conclusion of any derivation <fr:tex display="inline"><![CDATA[d]]></fr:tex> with height less than or equal to <fr:tex display="inline"><![CDATA[0]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>. But any derivation has height at least <fr:tex display="inline"><![CDATA[1]]></fr:tex>, so this is vacuous.</html:li>
 <html:li><html:p>In the <html:strong>inductive step</html:strong>, we suppose that the conclusion of every derivation of height less than or equal to <fr:tex display="inline"><![CDATA[n]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>; we must prove that the conclusion of every derivation of height less than or equal to <fr:tex display="inline"><![CDATA[n+1]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:p>
  <html:p>To that end, consider a derivation of height less than or equal to <fr:tex display="inline"><![CDATA[n+1]]></fr:tex> with conclusion <fr:tex display="inline"><![CDATA[v]]></fr:tex>, which we might depict below as follows:</html:p>
  <fr:tex display="block"><![CDATA[
   
 
 \displaystyle \frac {\displaystyle 
    \frac {\vdots }{u_1}\quad \ldots \quad \frac {\vdots }{u_n}
   }{\displaystyle \quad v\quad }


  ]]></fr:tex>

  <html:p>Such a <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">derivation</fr:link> must come from a <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rule</fr:link> of the following form in <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>:</html:p>
  <fr:tex display="block"><![CDATA[
   
 
 \displaystyle \frac {\displaystyle u_1\quad \ldots \quad  u_n}{\displaystyle \quad v\quad }


  ]]></fr:tex>

  <html:p>We need to show that <fr:tex display="inline"><![CDATA[v]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>. Naturally, all the <fr:link href="/jms-016X/" title="Derivations" uri="https://www.jonmsterling.com/jms-016X/" display-uri="jms-016X" type="local">subderivations</fr:link> of <fr:tex display="inline"><![CDATA[u_i]]></fr:tex> depicted above have height less than or equal to <fr:tex display="inline"><![CDATA[n]]></fr:tex>; therefore, our inductive hypothesis ensures that each <fr:tex display="inline"><![CDATA[u_i]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:p>

  <html:p>The rule <fr:tex display="inline"><![CDATA[
 \scriptstyle \frac {\scriptstyle u_1\quad \ldots \quad  u_n}{\scriptstyle v}
]]></fr:tex> specifies a <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closure condition</fr:link>, and because <fr:tex display="inline"><![CDATA[S\in  \mathrm {Cl}_{\mathcal {R}}]]></fr:tex> we know that <fr:tex display="inline"><![CDATA[S]]></fr:tex> is closed under it. Recalling the <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closure condition induced by a rule</fr:link>, we can immediately conclude <fr:tex display="inline"><![CDATA[v\in  S]]></fr:tex> from <fr:tex display="inline"><![CDATA[u_1,\ldots ,u_n\in  S]]></fr:tex>.</html:p></html:li></html:ol></fr:mainmatter>
                </fr:tree>
                <html:p>By virtue of <fr:link href="/jms-0171/" title="Rule induction" uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" type="local">Theorem <fr:contextual-number uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" /></fr:link>, we are justified in referring to <fr:tex display="inline"><![CDATA[X_{\mathcal {R}}]]></fr:tex> as the subset of <fr:tex display="inline"><![CDATA[X]]></fr:tex> <html:em><html:strong>inductively defined</html:strong></html:em> by <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>8</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0173/</fr:uri>
                    <fr:display-uri>jms-0173</fr:display-uri>
                    <fr:route>/jms-0173/</fr:route>
                    <fr:title text="Application of rule induction">Application of rule induction</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>We recall the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> <fr:link href="/jms-016W/" title="Syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016W/" display-uri="jms-016W" type="local">presented</fr:link> in <fr:link href="/jms-016Y/" title="A syntactic presentation of a formal language" uri="https://www.jonmsterling.com/jms-016Y/" display-uri="jms-016Y" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-016Y/" display-uri="jms-016Y" /></fr:link> by the following <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rule</fr:link> set <fr:tex display="inline"><![CDATA[\mathcal {R}]]></fr:tex>:</html:p><fr:tex display="block"><![CDATA[
 
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad \epsilon \quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u}{\displaystyle \quad aub\quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u}{\displaystyle \quad bua\quad }


 \quad 
 
 
 \displaystyle \frac {\displaystyle u\quad  v}{\displaystyle \quad uv\quad }


]]></fr:tex><html:p>For any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u\in  {\mathopen {}\left \{a,b\right \}\mathclose {}}^\star ]]></fr:tex>, let <fr:tex display="inline"><![CDATA[P(u)]]></fr:tex> be the property that <fr:tex display="inline"><![CDATA[u]]></fr:tex> contains the same number of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> symbols. Then for all <fr:tex display="inline"><![CDATA[u\in  \Sigma ^\star _{\mathcal {R}}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[P(u)]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>We proceed by <fr:link href="/jms-0171/" title="Rule induction" uri="https://www.jonmsterling.com/jms-0171/" display-uri="jms-0171" type="local">rule induction</fr:link>, letting <fr:tex display="inline"><![CDATA[S = {\mathopen {}\left \{u\,\middle \vert \,P(u)\right \}\mathclose {}}]]></fr:tex>. In particular, we need only show that <fr:tex display="inline"><![CDATA[S]]></fr:tex> is <fr:link href="/jms-016U/" title="The closure condition denoted by a syntactic rule" uri="https://www.jonmsterling.com/jms-016U/" display-uri="jms-016U" type="local">closed under</fr:link> each of the <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rules</fr:link>:</html:p>

 <html:ol><html:li>We note that the empty string has the same (zero) number of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> symbols.</html:li>
  <html:li>Adding both an <fr:tex display="inline"><![CDATA[a]]></fr:tex> and a <fr:tex display="inline"><![CDATA[b]]></fr:tex> to a given string in whatever location preserves the relationship between the number of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> symbols.</html:li>
  <html:li>If <fr:tex display="inline"><![CDATA[u]]></fr:tex> has <fr:tex display="inline"><![CDATA[n]]></fr:tex> copies of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> each and <fr:tex display="inline"><![CDATA[v]]></fr:tex> has <fr:tex display="inline"><![CDATA[m]]></fr:tex> copies of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> each, then the <fr:link href="/jms-016J/" title="Concatenation of strings" uri="https://www.jonmsterling.com/jms-016J/" display-uri="jms-016J" type="local">concatenation</fr:link> <fr:tex display="inline"><![CDATA[uv]]></fr:tex> has <fr:tex display="inline"><![CDATA[m+n]]></fr:tex> copies of <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> each.</html:li></html:ol>

 <html:p>Therefore <fr:tex display="inline"><![CDATA[S\in \mathrm {Cl}_{\mathcal {R}}]]></fr:tex> and thus <fr:tex display="inline"><![CDATA[\Sigma ^\star _{\mathcal {R}}\subseteq  S]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/ianleslie/" title="Ian Leslie" uri="https://www.jonmsterling.com/ianleslie/" display-uri="ianleslie" type="local">Ian Leslie</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>2</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00OC/</fr:uri>
            <fr:display-uri>jms-00OC</fr:display-uri>
            <fr:route>/jms-00OC/</fr:route>
            <fr:title text="Lecture 22: finite automata">Lecture 22: finite automata</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> by adapting prior notes created by <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link> that I inherited from <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>.</html:p>
            <html:p>In this lecture, we introduce our a fundamental mathematical model of computatation: the finite automaton.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017J/</fr:uri>
                <fr:display-uri>jms-017J</fr:display-uri>
                <fr:route>/jms-017J/</fr:route>
                <fr:title text="Kinds of finite automata">Kinds of finite automata</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The most basic form of automaton is the <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">non-deterministic finite automaton</fr:link> as defined below.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017H/</fr:uri>
                    <fr:display-uri>jms-017H</fr:display-uri>
                    <fr:route>/jms-017H/</fr:route>
                    <fr:title text="Non-deterministic finite automaton">Non-deterministic finite automaton</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <html:em><html:strong>non-deterministic finite automaton</html:strong></html:em> or <html:em><html:strong>NFA</html:strong></html:em> for short is defined to be a tuple <fr:tex display="inline"><![CDATA[M = {\mathopen {}\left (Q,\Sigma ,\Delta ,s,F\right )\mathclose {}}]]></fr:tex> where:</html:p>
                    <html:ol><html:li><fr:tex display="inline"><![CDATA[Q]]></fr:tex> is a finite set (of “states”).</html:li>
 <html:li><fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> is an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link>, i.e. a finite set.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[\Delta ]]></fr:tex> is a ternary relation <fr:tex display="inline"><![CDATA[\Delta \colon  Q\times \Sigma \mathbin {\nrightarrow } Q]]></fr:tex> called the <html:em>transition</html:em> relation: we write <fr:tex display="inline"><![CDATA[q\xrightarrow {a}{q'}]]></fr:tex> to mean that <fr:tex display="inline"><![CDATA[(q,a,q')\in \Delta ]]></fr:tex>.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[s]]></fr:tex> is an element of <fr:tex display="inline"><![CDATA[Q]]></fr:tex>, the “starting state”.</html:li>
 <html:li><fr:tex display="inline"><![CDATA[F]]></fr:tex> is a subset of <fr:tex display="inline"><![CDATA[Q]]></fr:tex>, the “accepting states”.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>The idea of an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> is that you “feed” it a <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> after initialising it to its starting state, and then you explore the transitions it makes by biting off characters from the string until it is consumed. If the automaton ends up in an <html:em>accepting state</html:em> then the string is accepted; otherwise, the string is considered <html:em>rejected</html:em>. More formally:</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017K/</fr:uri>
                    <fr:display-uri>jms-017K</fr:display-uri>
                    <fr:route>/jms-017K/</fr:route>
                    <fr:title text="The formal language accepted by an NFA">The <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted by an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M=(Q,\Sigma ,\Delta ,s,F)]]></fr:tex> be a <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">non-deterministic finite automaton</fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. Then the <html:em><html:strong><fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted by <fr:tex display="inline"><![CDATA[M]]></fr:tex></html:strong></html:em> is defined to be the subset <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}\subseteq \Sigma ^\star ]]></fr:tex> specified as follows:</html:p>
                    <fr:tex display="block"><![CDATA[
 \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}} =
 {\mathopen {}\left \{
  u\in \Sigma ^\star \mid 
  \exists  q\in  F\mathpunct {.}
  s\mathrel {\vphantom {\xrightarrow {u}}\smash {\xrightarrow {u}}^*}
 q
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>For the above, we define the relation <fr:tex display="inline"><![CDATA[q\mathrel {\vphantom {\xrightarrow {u}}\smash {\xrightarrow {u}}^*}
 q']]></fr:tex> by induction on the <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u]]></fr:tex>:</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {aligned}
   q\mathrel {\vphantom {\xrightarrow {\epsilon }}\smash {\xrightarrow {\epsilon }}^*}
 q' &\Leftrightarrow  q=q'
   \\
   q\mathrel {\vphantom {\xrightarrow {au}}\smash {\xrightarrow {au}}^*}
 q' &\Leftrightarrow  \exists  q''\in  Q\mathpunct {.} q\mathrel {\xrightarrow {a}}q''\land  q''\mathrel {\vphantom {\xrightarrow {u}}\smash {\xrightarrow {u}}^*}
q'
 \end {aligned}
]]></fr:tex>
                    <html:p>This is similar to <fr:link href="/jms-00JI/" title="The path relation via reflexive-transitive closure" uri="https://www.jonmsterling.com/jms-00JI/" display-uri="jms-00JI" type="local">reflexive-transitive closure</fr:link> in a <fr:link href="/jms-00JC/" title="Directed graph" uri="https://www.jonmsterling.com/jms-00JC/" display-uri="jms-00JC" type="local">directed graph</fr:link>, except that the edges of our graph are <html:em>labelled</html:em> by symbols from the <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p><fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> represent an extremely limited but nonetheless useful form of computational power; intuitively, this is because they don’t have any memory. It is therefore an interesting theorem when a language can be recognised by an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>. In this lecture we will show that (1) <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> can be given some more capabilities without changing the class of languages they recognise, and (2) the non-determinism of the transition relation is not necessary. Having more capabilities is helpful when constructing an automaton, but having fewer capabilities is helpful when investigating the class of <html:em>all</html:em> automata.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017I/</fr:uri>
                    <fr:display-uri>jms-017I</fr:display-uri>
                    <fr:route>/jms-017I/</fr:route>
                    <fr:title text="Graphical depiction of an NFA">Graphical depiction of an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link></fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> are usually drawn in a graphical notation that depicts the states as circled nodes, with possible transitions given by arrows between the nodes. The starting state is drawn with an arrow pointing from it out of nowhere, and the accepting states are drawn in double-struck circles. For example, consider the following picture:</html:p>
                    <html:figure>
                      <fr:resource hash="5d52962cee4763584c5d623e5d311896">
                        <fr:resource-content>
                          <html:img src="/5d52962cee4763584c5d623e5d311896.svg" />
                        </fr:resource-content>
                        <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source>
                        <fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=2cm,on grid]
    \node [state,initial] (q0) {$q_0$};
    \node [state,right=of q0] (q1) {$q_1$};
    \node [state,right=of q1] (q2) {$q_2$};
    \node [state,accepting,right=of q2] (q3) {$q_3$};
    \path [->]
      (q0) edge[loop above] node {$a$} ()
      (q0) edge[loop below] node {$b$} ()
      (q0) edge node[above] {$a$} (q1)
      (q1) edge node[above] {$a$} (q2)
      (q2) edge node[above] {$a$} (q3)
      (q3) edge[loop above] node {$a$} ()
      (q3) edge[loop below] node {$b$} ()
    ;
  \end {tikzpicture}
 ]]></fr:resource-source>
                      </fr:resource>
                    </html:figure>
                    <html:p>The picture above depicts an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> <fr:link href="/jms-017K/" title="The formal language accepted by an NFA" uri="https://www.jonmsterling.com/jms-017K/" display-uri="jms-017K" type="local">accepting</fr:link> the following <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> over the <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex>:</html:p>
                    <fr:tex display="block"><![CDATA[
 {\mathopen {}\left \{
  u\in  {\mathopen {}\left \{a,b\right \}\mathclose {}}^\star  \mid 
  \text {$u$ contains three consecutive $a$s}
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>Indeed, from the initial state we can consume as many <fr:tex display="inline"><![CDATA[a]]></fr:tex>s and <fr:tex display="inline"><![CDATA[b]]></fr:tex>s as we like but at some point we must transition along an <fr:tex display="inline"><![CDATA[a]]></fr:tex> to <fr:tex display="inline"><![CDATA[q_1]]></fr:tex> after which we have no choice but to consume two <fr:tex display="inline"><![CDATA[a]]></fr:tex>s until we reach an accepting state <fr:tex display="inline"><![CDATA[q_3]]></fr:tex>. At this point, we can continue with as many <fr:tex display="inline"><![CDATA[a]]></fr:tex>s and <fr:tex display="inline"><![CDATA[b]]></fr:tex>s as we like (an accepting state does not have to be a terminal state!).</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017L/</fr:uri>
                    <fr:display-uri>jms-017L</fr:display-uri>
                    <fr:route>/jms-017L/</fr:route>
                    <fr:title text="Deterministic finite automaton">Deterministic finite automaton</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <html:em><html:strong>deterministic finite automaton</html:strong></html:em> or <html:em><html:strong>DFA</html:strong></html:em> for short is an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> for which the transition relation <fr:tex display="inline"><![CDATA[\Delta \colon  Q\times  \Sigma \mathbin {\nrightarrow } Q]]></fr:tex> is a <fr:link href="/jms-00KF/" title="Function" uri="https://www.jonmsterling.com/jms-00KF/" display-uri="jms-00KF" type="local">function</fr:link>, i.e. a <fr:link href="/jms-00KF/" title="Function" uri="https://www.jonmsterling.com/jms-00KF/" display-uri="jms-00KF" type="local">total</fr:link> and <fr:link href="/jms-00K7/" title="Partial function" uri="https://www.jonmsterling.com/jms-00K7/" display-uri="jms-00K7" type="local">functional</fr:link> relation. This states, in other words, that to each state each state <fr:tex display="inline"><![CDATA[q\in  Q]]></fr:tex> can transition along each symbol <fr:tex display="inline"><![CDATA[a\in \Sigma ]]></fr:tex> to one and only one state, which we conventionally write <fr:tex display="inline"><![CDATA[\delta {\mathopen {}\left (q,a\right )\mathclose {}}]]></fr:tex>. Indeed, we will often write <fr:tex display="inline"><![CDATA[M = (Q,\Sigma ,\delta ,s,F)]]></fr:tex> for a DFA. In this case, we have <fr:tex display="inline"><![CDATA[q \mathrel {\xrightarrow {a}}q']]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[\delta {\mathopen {}\left (q,a\right )\mathclose {}}=q']]></fr:tex>.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>11</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-017M/</fr:uri>
                        <fr:display-uri>jms-017M</fr:display-uri>
                        <fr:route>/jms-017M/</fr:route>
                        <fr:title text="Non-exclusive privatives in mathematical English">Non-exclusive privatives in mathematical English</fr:title>
                        <fr:taxon>Aside</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>As an aside, it might feel strange to speak of “deterministic non-deterministic finite automata”. This is OK but can take some getting used to: mathematicians have discovered over the past several centuries that it is better for negations in terminology to mean “not necessarily” rather than “definitely not”; this is similar to the way that mathematicians often say “greater than” to mean “greater than or equal to”, reserving “strictly greater than” for the notion that excludes equality.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>11</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017N/</fr:uri>
                    <fr:display-uri>jms-017N</fr:display-uri>
                    <fr:route>/jms-017N/</fr:route>
                    <fr:title text="NFAs versus DFAs"><fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> versus <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link></fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>An <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> can fail to be <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">deterministic</fr:link> in just two ways:</html:p>
                    <html:ol><html:li>There could be a pair <fr:tex display="inline"><![CDATA[(q,a)]]></fr:tex> for which there exists no transition <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {a}}q']]></fr:tex>.</html:li>
 <html:li>There could be a pair <fr:tex display="inline"><![CDATA[(q,a)]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {a}}q']]></fr:tex> and <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {a}}q'']]></fr:tex> for distinct states <fr:tex display="inline"><![CDATA[q',q''\in  Q]]></fr:tex>.</html:li></html:ol>
                    <html:p>We recall our sample <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> from <fr:link href="/jms-017I/" title="Graphical depiction of an NFA" uri="https://www.jonmsterling.com/jms-017I/" display-uri="jms-017I" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-017I/" display-uri="jms-017I" /></fr:link> fails to be deterministic in both ways: we have both <fr:tex display="inline"><![CDATA[q_0\mathrel {\xrightarrow {a}}q_0]]></fr:tex> and <fr:tex display="inline"><![CDATA[q_0\mathrel {\xrightarrow {a}}q_1]]></fr:tex>, and moreover there is no transition along <fr:tex display="inline"><![CDATA[b]]></fr:tex> from state <fr:tex display="inline"><![CDATA[q_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[q_2]]></fr:tex>.</html:p>
                    <html:figure>
                      <fr:resource hash="9a7545c23ce5f9aa6cf1e5b6398ef864">
                        <fr:resource-content>
                          <html:img src="/9a7545c23ce5f9aa6cf1e5b6398ef864.svg" />
                        </fr:resource-content>
                        <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source>
                        <fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=2cm,on grid]
    \node [state,initial] (q0) {$q_0$};
    \node [state,right=of q0,red] (q1) {$q_1$};
    \node [state,right=of q1,red] (q2) {$q_2$};
    \node [state,accepting,right=of q2] (q3) {$q_3$};
    \path [->]
      (q0) edge[loop above,red] node {$a$} ()
      (q0) edge[loop below] node {$b$} ()
      (q0) edge node[above] {$a$} (q1)
      (q1) edge node[above] {$a$} (q2)
      (q2) edge node[above] {$a$} (q3)
      (q3) edge[loop above] node {$a$} ()
      (q3) edge[loop below] node {$b$} ()
    ;
  \end {tikzpicture}
 ]]></fr:resource-source>
                      </fr:resource>
                    </html:figure>
                    <html:p>We could make the automaton deterministic by removing some transitions and adding others, while still <fr:link href="/jms-017K/" title="The formal language accepted by an NFA" uri="https://www.jonmsterling.com/jms-017K/" display-uri="jms-017K" type="local">accepting</fr:link> the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>:</html:p>
                    <html:figure>
                      <fr:resource hash="89cb1707293fbb18156dd39da0774f03">
                        <fr:resource-content>
                          <html:img src="/89cb1707293fbb18156dd39da0774f03.svg" />
                        </fr:resource-content>
                        <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source>
                        <fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=2cm,on grid]
    \node [state,initial] (q0) {$q_0$};
    \node [state,right=of q0] (q1) {$q_1$};
    \node [state,right=of q1] (q2) {$q_2$};
    \node [state,accepting,right=of q2] (q3) {$q_3$};
    \path [->]
      (q0) edge[loop below] node {$b$} ()
      (q0) edge node[above] {$a$} (q1)
      (q1) edge node[above] {$a$} (q2)
      (q2) edge node[above] {$a$} (q3)
      (q1) edge[bend right=50,blue] node[above] {$b$} (q0)
      (q2) edge[bend left,blue] node[below] {$b$} (q0)
      (q3) edge[loop above] node {$a$} ()
      (q3) edge[loop below] node {$b$} ()
    ;
  \end {tikzpicture}
 ]]></fr:resource-source>
                      </fr:resource>
                    </html:figure>
                    <html:p>So the above is a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>. But if were to view it as an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> over the extended alphabet <fr:tex display="inline"><![CDATA[\Sigma ' = {\mathopen {}\left \{a,b,c\right \}\mathclose {}}]]></fr:tex>, then it would again fail to be <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">deterministic</fr:link> because there would be no transitions along <fr:tex display="inline"><![CDATA[c]]></fr:tex>!</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>We will ultimately show that every <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> can be transformed into a more complicated <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> that accepts the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>. But before we do so, we introduce a further strengthening of the features of <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> that can be reduced <html:em>directly</html:em> to <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFAs</fr:link> in one go.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017O/</fr:uri>
                    <fr:display-uri>jms-017O</fr:display-uri>
                    <fr:route>/jms-017O/</fr:route>
                    <fr:title text="non-deterministic finite automaton with \varepsilon -transitions"><fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">non-deterministic finite automaton</fr:link> with <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A <html:em><html:strong><fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">non-deterministic finite automaton</fr:link> with <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions</html:strong></html:em> or <html:em><html:strong>NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></html:strong></html:em> for short is an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> <fr:tex display="inline"><![CDATA[M = {\mathopen {}\left (Q,\Sigma ,\Delta ,s,F\right )\mathclose {}}]]></fr:tex> together with an additional <fr:link href="/jms-00I7/" title="Relation" uri="https://www.jonmsterling.com/jms-00I7/" display-uri="jms-00I7" type="local">relation</fr:link> <fr:tex display="inline"><![CDATA[T\colon  Q\mathbin {\nrightarrow } Q]]></fr:tex> called the <html:em><html:strong><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition relation</html:strong></html:em>.</html:p>
                    <html:p>We will write <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {\varepsilon }}q']]></fr:tex> to mean that <fr:tex display="inline"><![CDATA[q\mathrel {T}q']]></fr:tex>. This notation is a little confusing! Note that this <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex> is not the same as the <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex> denoting the empty <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link>, and that therefore <fr:tex display="inline"><![CDATA[q\mathrel {\xrightarrow {\varepsilon }}q']]></fr:tex> means something very different from <fr:tex display="inline"><![CDATA[q\mathrel {\vphantom {\xrightarrow {\epsilon }}\smash {\xrightarrow {\epsilon }}^*}
q']]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>The purpose of the <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition relation in an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> is to allow the automaton to transition to states <html:em>without</html:em> consuming a symbol.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017P/</fr:uri>
                    <fr:display-uri>jms-017P</fr:display-uri>
                    <fr:route>/jms-017P/</fr:route>
                    <fr:title text="Graphical depiction of an NFA\varepsilon ">Graphical depiction of an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link></fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The graphical notation of <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link> that we introduced in <fr:link href="/jms-017I/" title="Graphical depiction of an NFA" uri="https://www.jonmsterling.com/jms-017I/" display-uri="jms-017I" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-017I/" display-uri="jms-017I" /></fr:link> can be extended to handle <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local"><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions</fr:link> in a straightforward way. For example:</html:p>
                    <html:figure>
                      <fr:resource hash="f608361e633aa902a39c4512ce0052a3">
                        <fr:resource-content>
                          <html:img src="/f608361e633aa902a39c4512ce0052a3.svg" />
                        </fr:resource-content>
                        <fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source>
                        <fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=2cm,on grid]
    \node [state,initial] (q0) {$q_0$};
    \node [state,above right=of q0] (q1) {$q_1$};
    \node [state,right=of q1] (q2) {$q_2$};
    \node [state,accepting,right=of q2] (q3) {$q_3$};
    \node [state,accepting,below right=of q3] (q7) {$q_7$};
    \node [state,below right=of q0] (q4) {$q_4$};
    \node [state,right=of q4] (q5) {$q_5$};
    \node [state,accepting,right=of q5] (q6) {$q_6$};
    \path [->]
      (q0) edge[loop above] node {$a$} ()
      (q0) edge[loop below] node {$b$} ()
      (q0) edge node[sloped,above] {$\varepsilon $} (q1)
      (q1) edge node[above] {$a$} (q2)
      (q2) edge node[above] {$a$} (q3)
      (q3) edge node[sloped,above] {$\varepsilon $} (q7)
      (q0) edge node[sloped,below] {$\varepsilon $} (q4)
      (q4) edge node[below] {$b$} (q5)
      (q5) edge node[below] {$b$} (q6)
      (q6) edge node[sloped,below] {$\varepsilon $} (q7)
      (q7) edge[loop above] node {$a$} ()
      (q7) edge[loop below] node {$b$} ()
    ;
  \end {tikzpicture}
 ]]></fr:resource-source>
                      </fr:resource>
                    </html:figure>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>In <fr:link href="/jms-017K/" title="The formal language accepted by an NFA" uri="https://www.jonmsterling.com/jms-017K/" display-uri="jms-017K" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-017K/" display-uri="jms-017K" /></fr:link> we described the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted by an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> in terms of a labelled path relation <fr:tex display="inline"><![CDATA[q\mathrel {\vphantom {\xrightarrow {u}}\smash {\xrightarrow {u}}^*}
q']]></fr:tex>. Below, we give an analogous definition that accounts for <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local"><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions</fr:link>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017Q/</fr:uri>
                    <fr:display-uri>jms-017Q</fr:display-uri>
                    <fr:route>/jms-017Q/</fr:route>
                    <fr:title text="The formal language accepted by an NFA\varepsilon ">The <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> accepted by an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link></fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M=(Q,\Sigma ,\Delta ,s,F,T)]]></fr:tex> be an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>. The <html:em><html:strong><fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal lanuage</fr:link> accepted by <fr:tex display="inline"><![CDATA[M]]></fr:tex></html:strong></html:em> is defined to be the subset <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}\subseteq \Sigma ^\star ]]></fr:tex> specified as follows:</html:p>
                    <fr:tex display="block"><![CDATA[
 \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}} = {\mathopen {}\left \{
  u\in \Sigma ^\star  \mid 
  \exists  q\in  F\mathpunct {.}
  s \mathrel {\xRightarrow {u}} q
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>Above we define the relation <fr:tex display="inline"><![CDATA[q\mathrel {\xRightarrow {u}} q']]></fr:tex> to mean that there exists a path through <fr:tex display="inline"><![CDATA[M]]></fr:tex> from <fr:tex display="inline"><![CDATA[q]]></fr:tex> to <fr:tex display="inline"><![CDATA[q']]></fr:tex> whose non-<fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions consume the string <fr:tex display="inline"><![CDATA[u]]></fr:tex>. In more formal terms, we can define the relation inductively by <fr:link href="/jms-016S/" title="Syntactic rule" uri="https://www.jonmsterling.com/jms-016S/" display-uri="jms-016S" type="local">rules</fr:link>:</html:p>
                    <fr:tex display="block"><![CDATA[
 \begin {gathered}
   
 
 \displaystyle \frac {\displaystyle }{\displaystyle \quad q\mathrel {\xRightarrow {\epsilon }}q\quad }


   \quad 
   
 
 \displaystyle \frac {\displaystyle 
    q\mathrel {\xrightarrow {a}}q''
    \quad 
    q''\mathrel {\xRightarrow {u}}q'
   }{\displaystyle \quad q\mathrel {\xRightarrow {au}}q'\quad }


   \qquad 
   
 
 \displaystyle \frac {\displaystyle 
    q\mathrel {\xrightarrow {\varepsilon }}q''
    \quad 
    q''\mathrel {\xRightarrow {u}}q'
   }{\displaystyle \quad q\mathrel {\xRightarrow {u}}q'\quad }


 \end {gathered}
]]></fr:tex>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017R/</fr:uri>
                    <fr:display-uri>jms-017R</fr:display-uri>
                    <fr:route>/jms-017R/</fr:route>
                    <fr:title text="The formal language depicted in Example [https://www.jonmsterling.com/jms-017P/]">The <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> depicted in <fr:link href="/jms-017P/" title="Graphical depiction of an NFA\varepsilon " uri="https://www.jonmsterling.com/jms-017P/" display-uri="jms-017P" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-017P/" display-uri="jms-017P" /></fr:link></fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Returning to the <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> depicted in <fr:link href="/jms-017P/" title="Graphical depiction of an NFA\varepsilon " uri="https://www.jonmsterling.com/jms-017P/" display-uri="jms-017P" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-017P/" display-uri="jms-017P" /></fr:link> in light of <fr:link href="/jms-017Q/" title="The formal language accepted by an NFA\varepsilon " uri="https://www.jonmsterling.com/jms-017Q/" display-uri="jms-017Q" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-017Q/" display-uri="jms-017Q" /></fr:link>, we see for example that we have paths <fr:tex display="inline"><![CDATA[q_0\mathrel {\xRightarrow {aa}}q_2]]></fr:tex>, <fr:tex display="inline"><![CDATA[q_0\mathrel {\xRightarrow {aa}}q_3]]></fr:tex>, and <fr:tex display="inline"><![CDATA[q_0\mathrel {\xRightarrow {bb}}q_7]]></fr:tex>. Overall, the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link> of this <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> is that of the regular expression <fr:tex display="inline"><![CDATA[(a\vert  b){*}(aa\vert  bb)(a\vert  b){*}]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>We see from <fr:link href="/jms-017R/" title="The formal language depicted in Example [https://www.jonmsterling.com/jms-017P/]" uri="https://www.jonmsterling.com/jms-017R/" display-uri="jms-017R" type="local">Example <fr:contextual-number uri="https://www.jonmsterling.com/jms-017R/" display-uri="jms-017R" /></fr:link> that the possibility of <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local"><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions</fr:link> makes it much easier to design an automaton that corresponds to a given regular expression. This is one of the motivations adding this feature to <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFAs</fr:link>, as we shall see in a subsequent lecture.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                  <fr:contributor>
                    <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
                  </fr:contributor>
                  <fr:contributor>
                    <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
                  </fr:contributor>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017G/</fr:uri>
                <fr:display-uri>jms-017G</fr:display-uri>
                <fr:route>/jms-017G/</fr:route>
                <fr:title text="The subset construction: equivalence of NFA\varepsilon s with DFAs">The subset construction: equivalence of <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s with <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Although very few <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s are <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>s and very few of those are <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s, all these kinds of automata nonetheless generate the same classes of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link>. In the upward direction, it is easy to see that any <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> is also an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> with a deterministic and total transition relation, and moreover any <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> is an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> with an <html:em>empty</html:em> <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transition relation, and that the <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal languages</fr:link> induced by all these agree. Conversely, it is much less obvious that we can go the other direction, i.e. that we can associate to a given <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> an <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> or a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> that accepts the same <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">formal language</fr:link>. That is the purpose of the <html:em>subset construction</html:em> which we shall study in this section.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017T/</fr:uri>
                    <fr:display-uri>jms-017T</fr:display-uri>
                    <fr:route>/jms-017T/</fr:route>
                    <fr:title text="Subset construction">Subset construction</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> over an <fr:link href="/jms-016H/" title="Alphabet" uri="https://www.jonmsterling.com/jms-016H/" display-uri="jms-016H" type="local">alphabet</fr:link> <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>; we define an <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> over <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> called the <html:em><html:strong>subset construction</html:strong></html:em> of <fr:tex display="inline"><![CDATA[M]]></fr:tex> as follows:</html:p>
                    <html:ol><html:li>We define the set of states of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> to be the powerset of the set of states of <fr:tex display="inline"><![CDATA[M]]></fr:tex>.
  <fr:tex display="block"><![CDATA[Q_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} = \mathcal {P}{\mathopen {}\left (Q_{M}\right )\mathclose {}} = {\mathopen {}\left \{S\,\middle \vert \,S\subseteq  Q_{M}\right \}\mathclose {}}]]></fr:tex></html:li>

 <html:li>The transition function <fr:tex display="inline"><![CDATA[\delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\colon  \mathcal {P}{\mathopen {}\left (Q_{M}\right )\mathclose {}} \times \Sigma \to \mathcal {P}{\mathopen {}\left (Q_{M}\right )\mathclose {}}]]></fr:tex> is so that a set of states <fr:tex display="inline"><![CDATA[S]]></fr:tex> transitions along the symbol <fr:tex display="inline"><![CDATA[a\in  \Sigma ]]></fr:tex> to the set of states reachable via <fr:tex display="inline"><![CDATA[a]]></fr:tex> from <html:em>some</html:em> element of <fr:tex display="inline"><![CDATA[S]]></fr:tex>:
  <fr:tex display="block"><![CDATA[
   \delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}{\mathopen {}\left (S,a\right )\mathclose {}} =
   {\mathopen {}\left \{
    q'\in Q_{M}
   \,\middle \vert \,
    \exists  q\in  S\mathpunct {.}
    q\mathrel {\xRightarrow {a}} q' \text { in } M
   \right \}\mathclose {}}
  ]]></fr:tex>

  (Optional observation: this is a <fr:link href="/jms-00NC/" title="Relational images" uri="https://www.jonmsterling.com/jms-00NC/" display-uri="jms-00NC" type="local">relational direct image</fr:link>.)</html:li>

 <html:li>The starting state of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> is the set of states reachable by any number of <fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex>-transitions from the starting state of <fr:tex display="inline"><![CDATA[M]]></fr:tex>, i.e. the set of states reachable from <fr:tex display="inline"><![CDATA[s_{M}]]></fr:tex> via the empty <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link>:
  <fr:tex display="block"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} = {\mathopen {}\left \{q\in  Q\,\middle \vert \,s_{M}\mathrel {\xRightarrow {\epsilon }}q\right \}\mathclose {}}]]></fr:tex></html:li>

 <html:li>An accepting set of states is one that contains an accepting state from <fr:tex display="inline"><![CDATA[M]]></fr:tex>:
  <fr:tex display="block"><![CDATA[
   F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} =
   {\mathopen {}\left \{S\subseteq Q_{M}\,\middle \vert \,
    \exists  q\in  S\mathpunct {.}
    q\in F_{M}
   \right \}\mathclose {}}
  ]]></fr:tex></html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017V/</fr:uri>
                    <fr:display-uri>jms-017V</fr:display-uri>
                    <fr:route>/jms-017V/</fr:route>
                    <fr:title text="Example of the subset construction">Example of the <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link></fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In order to get a thorough intuition for the <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link> we will see how it acts on a sample <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> over <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex> which we draw below:</html:p>
                    <html:figure><fr:resource hash="71092b60c80528f52786f8eaf7154473"><fr:resource-content><html:img src="/71092b60c80528f52786f8eaf7154473.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=1.5cm,on grid]
    \node [state,initial] (q0) {$q_0$};
    \node [state,above=of q0] (q1) {$q_1$};
    \node [state,accepting,below=of q0] (q2) {$q_2$};
    \path [->]
      (q0) edge[loop right] node {$a$} ()
      (q1) edge[loop above] node {$a$} ()
      (q2) edge[loop below] node {$b$} ()
      (q0) edge node[left] {$\varepsilon $} (q1)
      (q0) edge node[left] {$\varepsilon $} (q2)
    ;
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource>
 <html:figcaption>A sample <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> over <fr:tex display="inline"><![CDATA[\Sigma ={\mathopen {}\left \{a,b\right \}\mathclose {}}]]></fr:tex>, where <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}={\mathopen {}\left \{a^mb^n\right \}\mathclose {}}=\mathcal {L}{\mathopen {}\left (a{*}b{*}\right )\mathclose {}}]]></fr:tex>.</html:figcaption></html:figure>
                    <html:p>The states of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> are all the subsets of <fr:tex display="inline"><![CDATA[Q_{M}]]></fr:tex>:</html:p>
                    <fr:tex display="block"><![CDATA[
 Q_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} = {\mathopen {}\left \{
  \varnothing ,
  {\mathopen {}\left \{q_0\right \}\mathclose {}},
  {\mathopen {}\left \{q_1\right \}\mathclose {}},
  {\mathopen {}\left \{q_2\right \}\mathclose {}},
  {\mathopen {}\left \{q_0,q_1\right \}\mathclose {}},
  {\mathopen {}\left \{q_0,q_2\right \}\mathclose {}},
  {\mathopen {}\left \{q_1,q_2\right \}\mathclose {}},
  {\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>The starting state of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> is the set of states reachable from <fr:tex display="inline"><![CDATA[q_0]]></fr:tex> via the empty <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link>:</html:p>
                    <fr:tex display="block"><![CDATA[
 s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} = {\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}
]]></fr:tex>
                    <html:p>The accepting states of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> are all the sets of states containing an accepting state of <fr:tex display="inline"><![CDATA[M]]></fr:tex>:</html:p>
                    <fr:tex display="block"><![CDATA[
 F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}} =
 {\mathopen {}\left \{
  {\mathopen {}\left \{q_2\right \}\mathclose {}},
  {\mathopen {}\left \{q_2,q_0\right \}\mathclose {}},
  {\mathopen {}\left \{q_2,q_1\right \}\mathclose {}},
  {\mathopen {}\left \{q_2,q_1,q_0\right \}\mathclose {}}
 \right \}\mathclose {}}
]]></fr:tex>
                    <html:p>We then describe the transition function of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> by means of a table:</html:p>
                    <html:figure><html:table>
  
  <html:tr>
   
  <html:th><fr:tex display="inline"><![CDATA[S]]></fr:tex></html:th>

   
  <html:th><fr:tex display="inline"><![CDATA[\delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}{\mathopen {}\left (S,a\right )\mathclose {}}]]></fr:tex></html:th>

   
  <html:th><fr:tex display="inline"><![CDATA[\delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}{\mathopen {}\left (S,b\right )\mathclose {}}]]></fr:tex></html:th>

  </html:tr>


  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[\varnothing ]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[\varnothing ]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[\varnothing ]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_1\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_1\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[\varnothing ]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[\varnothing ]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_1\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>



  
 
  <html:tr>
  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}]]></fr:tex></html:td>

  
  <html:td><fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q_2\right \}\mathclose {}}]]></fr:tex></html:td>

 </html:tr>


 </html:table>


 <html:figcaption>The transition table for <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>.</html:figcaption></html:figure>
                    <html:p>All in all, we have the following <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>:</html:p>
                    <html:figure><fr:resource hash="03e13ba8409b1a6c4c97c9044a829fc6"><fr:resource-content><html:img src="/03e13ba8409b1a6c4c97c9044a829fc6.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
  \usepackage {tikz}
  \usepackage {amssymb}
  \usepackage [tt=false]{libertine}
  \usetikzlibrary {automata,positioning}
  \usetikzlibrary {backgrounds, intersections, calc, spath3, fit}
  \tikzstyle {blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
  \tikzstyle {white halo}=[fill=white, opacity=0.7, rounded corners]
]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[node distance=2.5cm,on grid]
    \node [state] (emp) {$\varnothing $};
    \node [state,below=of emp] (q1) {${\mathopen {}\left \{q_1\right \}\mathclose {}}$};
    \node [state,accepting,right=of emp] (q2) {${\mathopen {}\left \{q_2\right \}\mathclose {}}$};
    \node [state,accepting,below=of q2] (q12) {${\mathopen {}\left \{q_1,q_2\right \}\mathclose {}}$};
    \node [state,above=of q2] (q0) {${\mathopen {}\left \{q_0\right \}\mathclose {}}$};
    \node [state,below=of q2] (q12) {${\mathopen {}\left \{q_1,q_2\right \}\mathclose {}}$};
    \node [state,initial,initial where=right,accepting,right=of q0] (q012) {${\mathopen {}\left \{q_0,q_1,q_2\right \}\mathclose {}}$};
    \node [state,accepting,right=of q2] (q02) {${\mathopen {}\left \{q_0,q_2\right \}\mathclose {}}$};
    \node [state,right=of q02] (q01) {${\mathopen {}\left \{q_0,q_1\right \}\mathclose {}}$};
    \path [->]
      (emp) edge[loop above] node {$a$} ()
      (emp) edge[loop left] node {$b$} ()
      (q0) edge node[above] {$a$} (q012)
      (q0) edge node[left] {$b$} (q2)
      (q1) edge[loop left] node {$a$} ()
      (q1) edge node[left] {$b$} (emp)
      (q2) edge node[above] {$a$} (emp)
      (q2) edge[loop below] node {$b$} (q2)
      (q01) edge node[sloped,above] {$a$} (q012)
      (q01) edge[bend left=50] node[sloped,below] {$b$} (q2)
      (q02) edge node[left] {$a$} (q012)
      (q02) edge node[above] {$b$} (q2)
      (q12) edge node[below] {$a$} (q1)
      (q12) edge[bend left=30] node[left] {$b$} (q2)
      (q012) edge[loop above] node {$a$} ()
      (q012) edge node[sloped,above] {$b$} (q2)
    ;
  \end {tikzpicture}
 ]]></fr:resource-source></fr:resource>
 <html:figcaption>The <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link> of <fr:tex display="inline"><![CDATA[M]]></fr:tex>.</html:figcaption></html:figure>
                    <html:p>As you can see, the resulting <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> is kind of strange and has many redundant states. But it does accept the desired <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>The goal of <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">Definition <fr:contextual-number uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" /></fr:link> is to transform an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> <fr:tex display="inline"><![CDATA[M]]></fr:tex> into a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> that accepts the <html:em>same</html:em> language, i.e. that <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}\right )\mathclose {}}=\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>. We prove this in two steps below.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:contributor>
                        <fr:link href="/frankstajano/" title="Frank Stajano" uri="https://www.jonmsterling.com/frankstajano/" display-uri="frankstajano" type="local">Frank Stajano</fr:link>
                      </fr:contributor>
                      <fr:contributor>
                        <fr:link href="/andrewpitts/" title="Andrew Pitts" uri="https://www.jonmsterling.com/andrewpitts/" display-uri="andrewpitts" type="local">Andrew Pitts</fr:link>
                      </fr:contributor>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-00OD/</fr:uri>
                    <fr:display-uri>jms-00OD</fr:display-uri>
                    <fr:route>/jms-00OD/</fr:route>
                    <fr:title text="Soundness of the subset construction">Soundness of the <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link></fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>; then <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}\right )\mathclose {}}\subseteq  \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>.</html:p>
                    <fr:tree show-metadata="false" toc="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>9</fr:day>
                        </fr:date>
                        <fr:taxon>Proof</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We must show that any <fr:link href="/jms-016I/" title="String over an alphabet" uri="https://www.jonmsterling.com/jms-016I/" display-uri="jms-016I" type="local">string</fr:link> <fr:tex display="inline"><![CDATA[u\in  \mathcal {L}{\mathopen {}\left (\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>.</html:p>
                        <fr:tree show-metadata="false" toc="false" numbered="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2024</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>9</fr:day>
                            </fr:date>
                            <fr:title text="Empty string">Empty string</fr:title>
                            <fr:taxon>Case</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>If <fr:tex display="inline"><![CDATA[u=\epsilon ]]></fr:tex>, then by definition we have <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\in F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex> and so by definition, there exists <fr:tex display="inline"><![CDATA[q\in  s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q\in  F_{M}]]></fr:tex>. By definition of <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>, we therefore have <fr:tex display="inline"><![CDATA[s\mathrel {\xRightarrow {\epsilon }}q]]></fr:tex>; because <fr:tex display="inline"><![CDATA[q\in  F_{M}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[\epsilon \in \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false" toc="false" numbered="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2024</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>9</fr:day>
                            </fr:date>
                            <fr:title text="Non-empty string">Non-empty string</fr:title>
                            <fr:taxon>Case</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>Suppose on the other hand that <fr:tex display="inline"><![CDATA[u=a_1\cdots  a_n]]></fr:tex>, and so we therefore have transitions <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\mathrel {\xrightarrow {a_1}}S_1\mathrel {\xrightarrow {\ldots }}S_{n-1}\mathrel {\xrightarrow {a_n}}S_n]]></fr:tex> with <fr:tex display="inline"><![CDATA[S_n\in  F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>, and so there exists some <fr:tex display="inline"><![CDATA[q_n\in  S_n\cap  F_{M}]]></fr:tex>. Define <fr:tex display="inline"><![CDATA[S_0 = s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>.</html:p>
                            <html:p>By definition of <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex>, from the transition <fr:tex display="inline"><![CDATA[S_{n-1}\mathrel {\xrightarrow {a_n}}S_n]]></fr:tex> we may find some <fr:tex display="inline"><![CDATA[q_{n-1}\in  S_{n-1}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q_{n-1}\mathrel {\xRightarrow {a_n}}q_n]]></fr:tex>. Iterating this process, we may find states <fr:tex display="inline"><![CDATA[q_i\in  S_{i}]]></fr:tex> such that we have a sequence of transitions <fr:tex display="inline"><![CDATA[q_{i-1}\mathrel {\xRightarrow {a_i}}q_i]]></fr:tex> in <fr:tex display="inline"><![CDATA[M]]></fr:tex>; thus we have a sequence of transitions <fr:tex display="inline"><![CDATA[q_0\mathrel {\xRightarrow {u}}q_n]]></fr:tex>. Because <fr:tex display="inline"><![CDATA[q_0\in  S_0=s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[s_{M}\mathrel {\xRightarrow {\epsilon }}q_0]]></fr:tex> and thus <fr:tex display="inline"><![CDATA[s_{M}\mathrel {\xRightarrow {\epsilon }}q_0\mathrel {\xRightarrow {u}}q_n]]></fr:tex> and therefore <fr:tex display="inline"><![CDATA[s_{M}\mathrel {\xRightarrow {u}} q_n]]></fr:tex>. Because <fr:tex display="inline"><![CDATA[q_n\in  F_{M}]]></fr:tex>, we are done.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-00OE/</fr:uri>
                    <fr:display-uri>jms-00OE</fr:display-uri>
                    <fr:route>/jms-00OE/</fr:route>
                    <fr:title text="Completeness of the subset construction">Completeness of the <fr:link href="/jms-017T/" title="Subset construction" uri="https://www.jonmsterling.com/jms-017T/" display-uri="jms-017T" type="local">subset construction</fr:link></fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[M]]></fr:tex> be an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>; then <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}\subseteq \mathcal {L}{\mathopen {}\left (\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex>.</html:p>
                    <fr:tree show-metadata="false" toc="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>9</fr:day>
                        </fr:date>
                        <fr:taxon>Proof</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>We must show that any string <fr:tex display="inline"><![CDATA[u\in \mathcal {L}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[\mathcal {L}{\mathopen {}\left (\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex>.</html:p>
                        <fr:tree show-metadata="false" toc="false" numbered="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2024</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>9</fr:day>
                            </fr:date>
                            <fr:title text="Empty string">Empty string</fr:title>
                            <fr:taxon>Case</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>If <fr:tex display="inline"><![CDATA[u=\epsilon ]]></fr:tex>, then we have assumed that <fr:tex display="inline"><![CDATA[s_{M}\xRightarrow {\epsilon }q]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q\in F_{M}]]></fr:tex>; therefore, by definition, we have <fr:tex display="inline"><![CDATA[q\in  s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>. Thus we have <fr:tex display="inline"><![CDATA[q\in  s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\cap F_{M}]]></fr:tex> and so it follows by definition that <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\in  F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                        <fr:tree show-metadata="false" toc="false" numbered="false">
                          <fr:frontmatter>
                            <fr:authors>
                              <fr:author>
                                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                              </fr:author>
                            </fr:authors>
                            <fr:date>
                              <fr:year>2024</fr:year>
                              <fr:month>2</fr:month>
                              <fr:day>9</fr:day>
                            </fr:date>
                            <fr:title text="Non-empty string">Non-empty string</fr:title>
                            <fr:taxon>Case</fr:taxon>
                          </fr:frontmatter>
                          <fr:mainmatter>
                            <html:p>Suppose that <fr:tex display="inline"><![CDATA[u=a_1\cdots  a_n]]></fr:tex>, and so we have transitions <fr:tex display="inline"><![CDATA[s_{M}\xRightarrow {a_1}q_1\xRightarrow {\cdots } q_{n-1}\xRightarrow {a_n}q_n]]></fr:tex> with <fr:tex display="inline"><![CDATA[q_n\in F_{M}]]></fr:tex>.</html:p>
                            <html:p>We <fr:link href="/jms-00KK/" title="Inductive definitions" uri="https://www.jonmsterling.com/jms-00KK/" display-uri="jms-00KK" type="local">inductively define</fr:link> a sequence of states <fr:tex display="inline"><![CDATA[S_i]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> as follows:</html:p>
                            <fr:tex display="block"><![CDATA[
   \begin {aligned}
    S_0 &= s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\\
    S_{k+1} &= \delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}{\mathopen {}\left (S_k,a_{k+1}\right )\mathclose {}}
   \end {aligned}
  ]]></fr:tex>
                            <html:p>Define <fr:tex display="inline"><![CDATA[q_0=s_{M}]]></fr:tex>. Then for all <fr:tex display="inline"><![CDATA[0\leq  i \leq  n]]></fr:tex>, we observe that we have <fr:tex display="inline"><![CDATA[q_i\in  S_i]]></fr:tex>.</html:p>
                            <fr:tree show-metadata="false" toc="false" numbered="false">
                              <fr:frontmatter>
                                <fr:authors>
                                  <fr:author>
                                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                                  </fr:author>
                                </fr:authors>
                                <fr:date>
                                  <fr:year>2024</fr:year>
                                  <fr:month>2</fr:month>
                                  <fr:day>9</fr:day>
                                </fr:date>
                                <fr:taxon>Subproof</fr:taxon>
                              </fr:frontmatter>
                              <fr:mainmatter>
                                <html:p>We proceed by induction on <fr:tex display="inline"><![CDATA[i]]></fr:tex>. For <fr:tex display="inline"><![CDATA[i=0]]></fr:tex>, we need <fr:tex display="inline"><![CDATA[s_{M}\in  s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>; but this holds by definition. Next, assuming <fr:tex display="inline"><![CDATA[q_i\in  S_i]]></fr:tex> we must show that <fr:tex display="inline"><![CDATA[q_{i+1}\in  S_{i+1} = \delta _{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}{\mathopen {}\left (S_i,a_{i+1}\right )\mathclose {}}]]></fr:tex>. Unfolding definitions, this follows from the transition <fr:tex display="inline"><![CDATA[q_i\xRightarrow {a_{i+1}} q_{i+1}]]></fr:tex> that we have assumed, as our inductive hypothesis ensures <fr:tex display="inline"><![CDATA[q_i\in  S_i]]></fr:tex>.</html:p>
                              </fr:mainmatter>
                            </fr:tree>
                            <html:p>It follows from the above that we have transitions <fr:tex display="inline"><![CDATA[S_0=s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\xrightarrow {a_1}S_1\xrightarrow {\cdots }S_{n-1}\xrightarrow {a_n}S_n]]></fr:tex>. Becuase we have shown <fr:tex display="inline"><![CDATA[q_n\in  S_n]]></fr:tex> and we have assumed <fr:tex display="inline"><![CDATA[q_n\in  F_{M}]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[S_n\in  F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>. Thus it follows that <fr:tex display="inline"><![CDATA[\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}]]></fr:tex> accepts <fr:tex display="inline"><![CDATA[u]]></fr:tex>.</html:p>
                          </fr:mainmatter>
                        </fr:tree>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>12</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-017U/</fr:uri>
                    <fr:display-uri>jms-017U</fr:display-uri>
                    <fr:route>/jms-017U/</fr:route>
                    <fr:title text="Equivalence between NFA\varepsilon s, NFAs, and DFAs">Equivalence between <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s, <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>s, and <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p><fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s, <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>s, and <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s all generate the same class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">languages</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>12</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
 <html:p>In <fr:link href="/jms-00OD/" title="Soundness of the subset construction" uri="https://www.jonmsterling.com/jms-00OD/" display-uri="jms-00OD" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-00OD/" display-uri="jms-00OD" /></fr:link> and <fr:link href="/jms-00OE/" title="Completeness of the subset construction" uri="https://www.jonmsterling.com/jms-00OE/" display-uri="jms-00OE" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-00OE/" display-uri="jms-00OE" /></fr:link>, we have proved that <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>s and <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s generate the same class of <fr:link href="/jms-016M/" title="Formal language" uri="https://www.jonmsterling.com/jms-016M/" display-uri="jms-016M" type="local">language</fr:link> as any <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link> can be converted into a <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link> recognising the same language. As any <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link> is in particular an <fr:link href="/jms-017O/" title="non-deterministic finite automaton with \varepsilon -transitions" uri="https://www.jonmsterling.com/jms-017O/" display-uri="jms-017O" type="local">NFA<html:sup><fr:tex display="inline"><![CDATA[\varepsilon ]]></fr:tex></html:sup></fr:link>, we see that <fr:link href="/jms-017H/" title="Non-deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017H/" display-uri="jms-017H" type="local">NFA</fr:link>s are equivalent to <fr:link href="/jms-017L/" title="Deterministic finite automaton" uri="https://www.jonmsterling.com/jms-017L/" display-uri="jms-017L" type="local">DFA</fr:link>s in the same sense.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <html:hr />
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-017S/</fr:uri>
                <fr:display-uri>jms-017S</fr:display-uri>
                <fr:route>/jms-017S/</fr:route>
                <fr:title text="Optional material">Optional material</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-00OG/</fr:uri>
                    <fr:display-uri>jms-00OG</fr:display-uri>
                    <fr:route>/jms-00OG/</fr:route>
                    <fr:title text="Alternative definition of F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}?">Alternative definition of <fr:tex display="inline"><![CDATA[F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>?</fr:title>
                    <fr:taxon>Question</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Why can’t we define <fr:tex display="inline"><![CDATA[F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex> to be the set of singletons <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{q\right \}\mathclose {}}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[q\in F_{M}]]></fr:tex>?</html:p>
                    <fr:tree show-metadata="false" toc="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>9</fr:day>
                        </fr:date>
                        <fr:taxon>Answer</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>Because if we did, then <fr:link href="/jms-00OE/" title="Completeness of the subset construction" uri="https://www.jonmsterling.com/jms-00OE/" display-uri="jms-00OE" type="local">Lemma <fr:contextual-number uri="https://www.jonmsterling.com/jms-00OE/" display-uri="jms-00OE" /></fr:link> would fail already in the case of the empty string. We would have <fr:tex display="inline"><![CDATA[s_{M}\xRightarrow {\epsilon }{q}]]></fr:tex> with <fr:tex display="inline"><![CDATA[q\in  F_{M}]]></fr:tex> and thus <fr:tex display="inline"><![CDATA[q\in  s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex>; we would need <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}\in F_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex> and with the proposed definition, this would need to be a singleton. There is, however, nothing about our assumptions that allows us to deduce that and, indeed, we can certainly come up with examples where <fr:tex display="inline"><![CDATA[s_{\mathcal {P}{\mathopen {}\left (M\right )\mathclose {}}}]]></fr:tex> is not a singleton (e.g. if we have <html:span style="white-space: nowrap"><fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-transitions</html:span> of the form <fr:tex display="inline"><![CDATA[s_{M}\xRightarrow {\epsilon }q]]></fr:tex> for <fr:tex display="inline"><![CDATA[q\not = s_{M}]]></fr:tex>).</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>12</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00AL/</fr:uri>
            <fr:display-uri>jms-00AL</fr:display-uri>
            <fr:route>/jms-00AL/</fr:route>
            <fr:title text="Research Assistant / Associate: New Spaces Project (Fixed Term)">Research Assistant / Associate: <fr:link href="/jms-008K/" title="New Spaces for Denotational Semantics" uri="https://www.jonmsterling.com/jms-008K/" display-uri="jms-008K" type="local"><html:em>New Spaces</html:em></fr:link> Project (Fixed Term)</fr:title>
            <fr:taxon>Advertisement</fr:taxon>
            <fr:meta name="external">https://www.jobs.cam.ac.uk/job/43755/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We invite applications for a Research Assistant/Associate to join the <fr:link href="/jms-008K/" title="New Spaces for Denotational Semantics" uri="https://www.jonmsterling.com/jms-008K/" display-uri="jms-008K" type="local"><html:em>New Spaces for Denotational Semantics</html:em></fr:link> project. Appointment at Research Associate level is dependent on having a PhD. Those who have submitted but not yet received their PhD will be appointed at Research Assistant level, which will be amended to Research Associate once the PhD has been awarded.</html:p>
            <html:p>The <fr:link href="/jms-008K/" title="New Spaces for Denotational Semantics" uri="https://www.jonmsterling.com/jms-008K/" display-uri="jms-008K" type="local"><html:em>New Spaces</html:em></fr:link> project aims to develop an axiomatic framework for higher-dimensional program semantics with applications to concurrency, using recent advances in category theory, type theory, domain theory, and the polarised structure of computational effects. The project will focus initially on two-dimensional generalisations of <fr:link href="/levy-2003/" title="Call-by-push-value: a functional/imperative synthesis" uri="https://www.jonmsterling.com/levy-2003/" display-uri="levy-2003" type="local">call-by-push-value</fr:link>, <fr:link href="/munch-2014/" title="Models of a non-associative composition" uri="https://www.jonmsterling.com/munch-2014/" display-uri="munch-2014" type="local">duploids</fr:link>, and <fr:link href="/mellies-tabareau-2010/" title="Resource modalities in tensor logic" uri="https://www.jonmsterling.com/mellies-tabareau-2010/" display-uri="mellies-tabareau-2010" type="local">resource</fr:link> <fr:link href="/curien-fiore-munch-2016/" title="A theory of effects and resources: adjunction models and polarised calculi" uri="https://www.jonmsterling.com/curien-fiore-munch-2016/" display-uri="curien-fiore-munch-2016" type="local">modalities</fr:link>.</html:p>
            <html:p>The position will involve working with <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Dr Jon Sterling</fr:link> and other project collaborators, including both PhD students and faculty. It will run initially for 24 months, with the possibility for a further 12 month extension.</html:p>
            <html:p>The successful candidate is likely to have (or expect to be awarded soon) a PhD in computer science or a related discipline, as well as a track record of research expertise in a subset of the following topics:</html:p>
            <html:ol><html:li>Domain-theoretic semantics of programming languages</html:li>
  <html:li>Two-dimensional category theory and/or formal category theory</html:li>
  <html:li>Categorical semantics of linear logic</html:li>
  <html:li>Homotopy type theory and univalent foundations</html:li>
  <html:li>Event structure or presheaf semantics of concurrency</html:li>
  <html:li>Use of proof assistants such as Agda, Coq, Lean, or Isabelle</html:li></html:ol>
            <html:p>Informal enquiries are welcome and should be directed to <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Dr Jon Sterling</fr:link> (<fr:link href="mailto:js2878@cl.cam.ac.uk" type="external">js2878@cl.cam.ac.uk</fr:link>). To apply, please visit <fr:link href="https://www.jobs.cam.ac.uk/job/43755/" type="external">the official posting</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00A4/</fr:uri>
            <fr:display-uri>jms-00A4</fr:display-uri>
            <fr:route>/jms-00A4/</fr:route>
            <fr:title text="Jon Sterling’s cookbook"><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>’s cookbook</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>5</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00A0/</fr:uri>
                <fr:display-uri>jms-00A0</fr:display-uri>
                <fr:route>/jms-00A0/</fr:route>
                <fr:title text="Delicious numbing vinegar sauce">Delicious numbing vinegar sauce</fr:title>
                <fr:taxon>Recipe</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This sauce can be served over rice, noodles, dumplings, or fish.</html:p>
                <html:ol><html:li>Take some Szechuan peppercorns and dried chili flakes (or dried chilis that you have shattered) and crush them lightly in a mortar and pestle.</html:li>
  <html:li>Toast the peppercorns and chili lightly in a hot pan.</html:li>
  <html:li>Fry the peppercorns and chili in plenty of oil.</html:li>
  <html:li>Fry some thinly chopped garlic without burning it.</html:li>
  <html:li>Mix all this together (including the oil), and mix in some salt, mirin, rice vinegar, and (optionally) a very small amount of black vineger, to taste. Feel free to add more oil if needed.</html:li>
  <html:li>Finely chop some coriander and mix it into the sauce.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/treborhuang/" title="Trebor Huang" uri="https://www.jonmsterling.com/treborhuang/" display-uri="treborhuang" type="local">Trebor Huang</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/huang-2023/</fr:uri>
            <fr:display-uri>huang-2023</fr:display-uri>
            <fr:route>/huang-2023/</fr:route>
            <fr:title text="Synthetic Tait computability the hard way">Synthetic Tait computability the hard way</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2310.02051</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We walk through a few proofs of canonicity and normalization, each one with more aspects dissected and re-expressed in category theory, so that readers can compare the difference across proofs. During this process we isolate the different ideas that make up the proofs. Finally we arrive at <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> as proposed by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">J. Sterling</fr:link>. We also give a synthetic proof for parametricity of system F.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/karlcrary/" title="Karl Crary" uri="https://www.jonmsterling.com/karlcrary/" display-uri="karlcrary" type="local">Karl Crary</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-009L/</fr:uri>
            <fr:display-uri>jms-009L</fr:display-uri>
            <fr:route>/jms-009L/</fr:route>
            <fr:title text="Edmund M. Clarke Dissertation Award">Edmund M. Clarke Dissertation Award</fr:title>
            <fr:taxon>Letter</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Dear friends,</html:p>
            <html:p>I am delighted to announce that <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link> has been selected as the winner of the 2022 Edmund M. Clarke Dissertation Award in CSD for his thesis:</html:p>
            <html:p><fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">First Steps in Synthetic Tait Computability</fr:link>, October 2021</html:p>
            <html:p><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>’s PhD research was advised by <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
            <html:p>This award, endowed by a generous contribution from Professor Ed Clarke and his wife Martha, is given annually to an outstanding dissertation in the Computer Science Department.</html:p>
            <html:p>Congratulations <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan</fr:link>!</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-009H/</fr:uri>
            <fr:display-uri>jms-009H</fr:display-uri>
            <fr:route>/jms-009H/</fr:route>
            <fr:title text="List of forests">List of <fr:link href="https://www.forester-notes.org/tfmt-000R/" title="Forests and trees of evergreen notes" uri="https://www.forester-notes.org/tfmt-000R/" display-uri="https://www.forester-notes.org/tfmt-000R/" type="local">forests</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:ul><html:li><fr:link href="https://conair94.github.io/ModelTheoryWiki/" type="external">The Model Companion</fr:link></html:li>
  <html:li><fr:link href="/dannypsnl/" title="Lîm Tsú-thuàn" uri="https://www.jonmsterling.com/dannypsnl/" display-uri="dannypsnl" type="local">Lîm Tsú-thuàn</fr:link>: <fr:link href="https://dannypsnl.me/index.xml" type="external">dannypsnl.me</fr:link></html:li>
  <html:li><fr:link href="/masanoriogino/" title="Masanori Ogino" uri="https://www.jonmsterling.com/masanoriogino/" display-uri="masanoriogino" type="local">Masanori Ogino</fr:link>: <fr:link href="https://trail.brackets-salad.com/index.xml" type="external">trail.brackets-salad.com</fr:link></html:li>
  <html:li><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>: <fr:link href="https://yuesforest.com/index.xml" type="external">yuesforest.com</fr:link></html:li>
  <html:li><fr:link href="/kentookura/" title="Kento Okura" uri="https://www.jonmsterling.com/kentookura/" display-uri="kentookura" type="local">Kento Okura</fr:link>: <fr:link href="https://kentookura.srht.site/index.xml" type="external">kentookura.srht.site/index.xml</fr:link></html:li>
  <html:li><fr:link href="/rileyshahar/" title="Riley Shahar" uri="https://www.jonmsterling.com/rileyshahar/" display-uri="rileyshahar" type="local">Riley Shahar</fr:link>: <fr:link href="https://rileyshahar.com/" type="external">rileyshahar.com</fr:link></html:li>
  <html:li><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>: <fr:link href="/index/" title="Jon Sterling" uri="https://www.jonmsterling.com/index/" display-uri="index" type="local">jonmsterling.com</fr:link></html:li>
  <html:li><fr:link href="/ayberktosun/" title="Ayberk Tosun" uri="https://www.jonmsterling.com/ayberktosun/" display-uri="ayberktosun" type="local">Ayberk Tosun</fr:link>:
  <fr:link href="https://ayberkt.github.io/mathematical-forest/" type="external">ayberktosun.github.io/mathematical-forest</fr:link></html:li>
  <html:li>Zifan Wang: <fr:link href="https://chry-santhemum.github.io/forest/" type="external">chry-santhemum.github.io/forest</fr:link></html:li>
  <html:li>Bernardo Hummes Flores: <fr:link href="https://birromer.github.io/" type="external">birromer.github.io</fr:link></html:li>
  <html:li><fr:link href="/zhixuanyang/" title="Zhixuan Yang" uri="https://www.jonmsterling.com/zhixuanyang/" display-uri="zhixuanyang" type="local">Zhixuan Yang</fr:link>: <fr:link href="https://yangzhixuan.github.io/trees/index.xml" type="external">yangzhixuan.github.io/trees/</fr:link></html:li>
  <html:li><fr:link href="https://fizzyelt.github.io/functional-programming/" type="external">帶你入門 functional programming</fr:link></html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0097/</fr:uri>
            <fr:display-uri>jms-0097</fr:display-uri>
            <fr:route>/jms-0097/</fr:route>
            <fr:title text="What kind of background do I need to be a PhD student of Jon Sterling?">What kind of background do I need to be a PhD student of <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>?</fr:title>
            <fr:taxon>FAQ</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It will of course depend on the student, but I am preferring to recruit students with some existing mathematical maturity (and this could be in any area of mathematics, not just category theory). <html:strong>The purpose of Bachelors and Masters-level mathematical training is not to learn a specific topic but rather to <html:em>learn how to learn</html:em> any topic whatsoever.</html:strong> In short, I do not care if you do not know what a natural transformation is, but it will be a problem if it would take you more than twenty minutes to find out what a natural transformation is.</html:p>
            <html:p>If you aren’t sure where you stand, please contact me for a chat; I promise not to bite.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-008K/</fr:uri>
            <fr:display-uri>jms-008K</fr:display-uri>
            <fr:route>/jms-008K/</fr:route>
            <fr:title text="New Spaces for Denotational Semantics">New Spaces for Denotational Semantics</fr:title>
            <fr:taxon>Grant</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/afosr/" title="United States Air Force Office of Scientific Research" uri="https://www.jonmsterling.com/afosr/" display-uri="afosr" type="local">United States Air Force Office of Scientific Research</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>PI</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Institution</html:strong>:</html:td>

  <html:td><fr:link href="/ucam/" title="University of Cambridge" uri="https://www.jonmsterling.com/ucam/" display-uri="ucam" type="local">University of Cambridge</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funding Agency</html:strong>:</html:td>

  <html:td><fr:link href="/afosr/" title="United States Air Force Office of Scientific Research" uri="https://www.jonmsterling.com/afosr/" display-uri="afosr" type="local">United States Air Force Office of Scientific Research</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Program Officer</html:strong>:</html:td>

  <html:td><fr:link href="/tristannguyen/" title="Tristan Nguyen" uri="https://www.jonmsterling.com/tristannguyen/" display-uri="tristannguyen" type="local">Dr. Tristan Nguyen</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award No.</html:strong>:</html:td>

  <html:td>FA9550-23-1-0728</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2023–2028</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>1,221,099 USD</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Status</html:strong>:</html:td>

  <html:td>awarded <fr:link href="https://www.jonmsterling.com/2023-09-27/" type="external">2023-09-27</fr:link></html:td>
</html:tr>

  
</html:table>
<html:p>See <fr:link href="/jms-00AI/" title="Project bibliography" uri="https://www.jonmsterling.com/jms-00AI/" display-uri="jms-00AI" type="local">project bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> What does it mean for a piece of software to be correct? There are many possible degrees and dimensions of correctness, e.g. safety, functional correctness, computational complexity, and security. To grapple with this diversity of verification requirements, semanticists develop <html:strong><html:em>mathematical models of program behavior</html:em></html:strong> that put into relief <html:em>different aspects</html:em> of the physical reality of program execution on hardware, just as physicists create many idealized mathematical models to study different aspects of the material reality of the universe.</html:p><html:p>Mathematical models enable us to reason about program behavior by viewing highly complex objects as being glued together from smaller, simpler objects that are easier to study in isolation. For instance, <html:strong><html:em>operational models</html:em></html:strong> aim to reduce the behavior of a process to that of individual steps of discrete computation that take place on an idealized computer; in contrast, <html:strong><html:em>denotational models</html:em></html:strong> reduce the complex <html:em>global</html:em> behavior of a process to the simpler <html:em>local</html:em> behavior of its constituent subroutines.  One advantage of operational methods is that they are applicable even in situations that challenge the modularity of denotational semantics, e.g. where it is not yet understood how to reduce the global behavior of a program to that of its components. On the other hand, denotational methods provide vastly stronger <html:em>and</html:em> simpler reasoning principles for program verification when available.</html:p><html:p>The central thesis of denotational semantics is that programs arrange themselves into geometrical spaces called <html:strong><html:em>computational domains</html:em></html:strong>, and that a computational process can be thought of as the limit of a sequence of continuous transformations on these domains. Although this thesis has been amply born out for simple kinds of program, today’s most urgent verification requirements pertain to program constructs like concurrency and side effects whose treatment requires the introduction of <html:strong><html:em>new kinds of space</html:em></html:strong>: for instance, the correct treatment of branching behavior for concurrent processes requires the introduction of <html:em>higher-dimensional computational domains</html:em> in which programs can “remember” the specific way that they were glued together.</html:p><html:p><html:strong>This project will extend the reach of denotational semantics</html:strong> and its attendant advantages for program verification into terrains where scientists have historically struggled to enact the reduction of global behavior to local behavior, making essential use of new advances in the <html:em>homotopical</html:em> and <html:em>geometrical</html:em> understanding of computation via <html:strong><html:em>higher dimensional category theory</html:em></html:strong> and <html:strong><html:em>topos theory</html:em></html:strong>. I will investigate two areas that are ripe for reaping the benefits of a modern denotational semantics: the semantics of <html:em>side-effects</html:em> which govern the interaction of a program with the computer’s memory, and the semantics of concurrent processes.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>6</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/harper-2023-calco-mfps/</fr:uri>
            <fr:display-uri>harper-2023-calco-mfps</fr:display-uri>
            <fr:route>/harper-2023-calco-mfps/</fr:route>
            <fr:title text="Integrating cost and behavior in type theory">Integrating cost and behavior in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">http://www.cs.cmu.edu/~rwh/talks/calco-mfps-2023.pdf</fr:meta>
            <fr:meta name="venue"> Plenary invited lecture for CALCO/MFPS 2023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Joint work with <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link> (Carnegie Mellon), <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> (Carnegie Mellon), and <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> (Cambridge).</html:p>
            <html:p>The computational view of intuitionistic dependent type theory is as an intrinsic logic of (functional) programs in which types are viewed as specifications of their behavior. Equational reasoning is particularly relevant in the functional case, where correctness can be formulated as equality between two implementations of the same behavior. Besides behavior, it is also important to specify and verify the cost of programs, measured in terms of their resource usage, with respect to both sequential and parallel evaluation. Although program cost can—and has been—verified in type theory using an extrinsic formulation of programs as data objects, what we seek here is, instead, an intrinsic account within type theory itself.</html:p>
            <html:p>In this talk we discuss Calf, the <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Cost-Aware Logical Framework</fr:link>, which is an extension of dependent call-by-push-value type theory that provides an intrinsic account of both parallel and sequential resource usage for a variety of problem-specific measures of cost. Thus, for example, it is possible to prove that insertion sort and merge sort are equal as regards behavior, but differ in terms of the number of comparisons required to achieve the same results. But how can equal functions have different cost? To provide an intrinsic account of both intensional and extensional properties of programs, we make use of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">Sterling's notion of Synthetic Tait Computability</fr:link>, a generalization of Tait's method originally developed for the study of higher type theory. In STC the concept of a “phase” plays a central role: originally as the distinction between the syntactic and semantic aspects of a computability structure, but more recently applied to the formulation of type theories for program modules and for information flow properties of programs. In Calf we distinguish two phases, the intensional and extensional, which differ as regards the significance of cost accounting—extensionally it is neglected, intensionally it is of paramount importance. Thus, in the extensional phase insertion sort and merge sort are equal, but in the intensional phase they are distinct, and indeed one is proved to have optimal behavior as regards comparisons, and the other not. Importantly, both phases are needed in a cost verification—the proof of the complexity of an algorithm usually relies on aspects of its correctness.</html:p>
            <html:p>We will provide an overview of Calf itself, and of its application in the verification of the cost and behavior of a variety of programs. So far we have been able to verify cost bounds on Euclid's Algorithm, amortized bounds on batched queues, parallel cost bounds on a joinable form of red-black trees, and the equivalence and cost of the aforementioned sorting methods. In a <fr:link href="/grodin-harper-2023-calco/" title="Amortized analysis via coinduction" uri="https://www.jonmsterling.com/grodin-harper-2023-calco/" display-uri="grodin-harper-2023-calco" type="local">companion paper</fr:link> at this meeting <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Grodin</fr:link> and I develop an account of amortization that relates the standard inductive view of instruction sequences with the coinductive view of data structures characterized by the same operations. In ongoing work we are extending the base of verified deterministic algorithms to those taught in the undergraduate parallel algorithms course at Carnegie Mellon, and are extending Calf itself to account for probabilistic methods, which are also used in that course.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>14</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-001Q/</fr:uri>
            <fr:display-uri>jms-001Q</fr:display-uri>
            <fr:route>/jms-001Q/</fr:route>
            <fr:title text="Positivity in constructive domain theory">Positivity in constructive domain theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>, based in part on discussions with <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link> and <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>. Any errors belong to <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                  <fr:contributor>
                    <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                  </fr:contributor>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-002C/</fr:uri>
                <fr:display-uri>jms-002C</fr:display-uri>
                <fr:route>/jms-002C/</fr:route>
                <fr:title text="Basic properties of positivity">Basic properties of positivity</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001M/</fr:uri>
                    <fr:display-uri>jms-001M</fr:display-uri>
                    <fr:route>/jms-001M/</fr:route>
                    <fr:title text="The positive elements of a pointed dcpo">The positive elements of a pointed dcpo</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>An element <fr:tex display="inline"><![CDATA[u]]></fr:tex> of a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dpco <fr:tex display="inline"><![CDATA[A]]></fr:tex> is called <html:em>positive</html:em> when for any semidirected subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex>, if <fr:tex display="inline"><![CDATA[u\sqsubseteq  \bigsqcup {I}]]></fr:tex> then <fr:tex display="inline"><![CDATA[I]]></fr:tex> is inhabited. We will write <fr:tex display="inline"><![CDATA[\mathsf {pos}\,{u}]]></fr:tex> to mean that <fr:tex display="inline"><![CDATA[u]]></fr:tex> is a positive element.</html:p>
                    <html:p>(This is adapted from <fr:link href="/johnstone-1984/" title="Open locales and exponentiation" uri="https://www.jonmsterling.com/johnstone-1984/" display-uri="johnstone-1984" type="local">Johnstone</fr:link>’s definition of positive elements of frames to the case of dcpos by <fr:link href="/dejong-2023-thesis/" title="Domain theory in constructive and predicative univalent foundations" uri="https://www.jonmsterling.com/dejong-2023-thesis/" display-uri="dejong-2023-thesis" type="local">Tom de Jong</fr:link>.)</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002H/</fr:uri>
                    <fr:display-uri>jms-002H</fr:display-uri>
                    <fr:route>/jms-002H/</fr:route>
                    <fr:title text="The bottom element is not positive">The bottom element is not positive</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The bottom element <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex> of a pointed dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> is not <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Suppose that <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex> was positive. The empty set <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{\right \}\mathclose {}}\subseteq  A]]></fr:tex> is semidirected and <fr:tex display="inline"><![CDATA[\bot \sqsubseteq  \bigsqcup {\mathopen {}\left \{\right \}\mathclose {}}=\bot ]]></fr:tex>, but nonetheless <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{\right \}\mathclose {}}]]></fr:tex> is not inhabited.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0029/</fr:uri>
                    <fr:display-uri>jms-0029</fr:display-uri>
                    <fr:route>/jms-0029/</fr:route>
                    <fr:title text="Positivity is upward-closed">Positivity is upward-closed</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[i\sqsubseteq  j]]></fr:tex> in a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[i]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link>; then <fr:tex display="inline"><![CDATA[j]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Fixing semidirected <fr:tex display="inline"><![CDATA[J\subseteq  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[j\sqsubseteq  \bigsqcup {J}]]></fr:tex>, we must show that <fr:tex display="inline"><![CDATA[J]]></fr:tex> is inhabited. This follows from our assumption that <fr:tex display="inline"><![CDATA[i]]></fr:tex> is positive becuase <fr:tex display="inline"><![CDATA[i\sqsubseteq  j\sqsubseteq  \bigsqcup {J}]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001O/</fr:uri>
                    <fr:display-uri>jms-001O</fr:display-uri>
                    <fr:route>/jms-001O/</fr:route>
                    <fr:title text="Closure of positivity under directed suprema">Closure of positivity under directed suprema</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo; the <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positivity predicate</fr:link> <fr:tex display="inline"><![CDATA[{\Gamma  A}\xrightarrow {{\mathsf {pos}}}{\Omega }]]></fr:tex> is closed under directed suprema.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[J\subseteq  A]]></fr:tex> be a directed subset such that every <fr:tex display="inline"><![CDATA[u\in  J]]></fr:tex> is positive; we must show that <fr:tex display="inline"><![CDATA[\bigsqcup {J}]]></fr:tex> is positive. Fixing a subdirected subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\bigsqcup {J}\sqsubseteq  \bigsqcup  I]]></fr:tex>, we must check that <fr:tex display="inline"><![CDATA[I]]></fr:tex> is inhabited. The inequality <fr:tex display="inline"><![CDATA[\bigsqcup {J}\sqsubseteq  \bigsqcup  I]]></fr:tex> holds if and only if <fr:tex display="inline"><![CDATA[u\sqsubseteq  \bigsqcup {I}]]></fr:tex> for all <fr:tex display="inline"><![CDATA[u\in  u]]></fr:tex>; as <fr:tex display="inline"><![CDATA[J]]></fr:tex> is directed, we therefore have some positive <fr:tex display="inline"><![CDATA[u\in  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[u\sqsubseteq  \bigsqcup {I}]]></fr:tex> from which it follows that <fr:tex display="inline"><![CDATA[I]]></fr:tex> is inhabited.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001P/</fr:uri>
                    <fr:display-uri>jms-001P</fr:display-uri>
                    <fr:route>/jms-001P/</fr:route>
                    <fr:title text="The subdcpo spanned by positive elements">The subdcpo spanned by positive elements</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo; then the subposet <fr:tex display="inline"><![CDATA[A^+\subseteq  A]]></fr:tex> spanned by <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link> is a dcpo.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>This follows from the <fr:link href="/jms-001O/" title="Closure of positivity under directed suprema" uri="https://www.jonmsterling.com/jms-001O/" display-uri="jms-001O" type="local">closure of positive elements in an algebra under directed suprema</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0028/</fr:uri>
                    <fr:display-uri>jms-0028</fr:display-uri>
                    <fr:route>/jms-0028/</fr:route>
                    <fr:title text="The positive part of a semidirected subset is semidirected">The positive part of a semidirected subset is semidirected</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex> be a semidirected subset of a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex>; then the intersection <fr:tex display="inline"><![CDATA[I \cap  A^+]]></fr:tex> is semidirected, where <fr:tex display="inline"><![CDATA[A^+]]></fr:tex> is the <fr:link href="/jms-001P/" title="The subdcpo spanned by positive elements" uri="https://www.jonmsterling.com/jms-001P/" display-uri="jms-001P" type="local">subdcpo spanned by positive elements</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[i,j]]></fr:tex> be two <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link> elements of <fr:tex display="inline"><![CDATA[I]]></fr:tex>; we must show that there exists a positive element <fr:tex display="inline"><![CDATA[k\in  I]]></fr:tex> such that <fr:tex display="inline"><![CDATA[i\sqsubseteq  k]]></fr:tex> and <fr:tex display="inline"><![CDATA[j\sqsubseteq  k]]></fr:tex>. This follows immediately from the directedness of <fr:tex display="inline"><![CDATA[I]]></fr:tex> and <fr:link href="/jms-0029/" title="Positivity is upward-closed" uri="https://www.jonmsterling.com/jms-0029/" display-uri="jms-0029" type="local">the fact that positivity is monotone</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001N/</fr:uri>
                    <fr:display-uri>jms-001N</fr:display-uri>
                    <fr:route>/jms-001N/</fr:route>
                    <fr:title text="Positivity = definedness in a lifted dcpo">Positivity = definedness in a lifted dcpo</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>The <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link> elements of a lifted dcpo <fr:tex display="inline"><![CDATA[\mathsf {L}{A}]]></fr:tex> are exactly the <html:em>defined</html:em> elements, i.e. those lying in the image of <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{\eta }}{\mathsf {L}{A}}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[a\in  A]]></fr:tex> be an element of the dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex>. To show that <fr:tex display="inline"><![CDATA[\eta _A a]]></fr:tex> is positive, we fix a semidirected subset <fr:tex display="inline"><![CDATA[U\subseteq  \mathsf {L}{A}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\eta _A a\sqsubseteq  \bigsqcup  U]]></fr:tex> to show that <fr:tex display="inline"><![CDATA[U]]></fr:tex> is inhabited. The inequality implies that <fr:tex display="inline"><![CDATA[\top \sqsubseteq  \exists  u\in  U. u{\downarrow }]]></fr:tex>, so we know that <fr:tex display="inline"><![CDATA[U]]></fr:tex> is inhabited.</html:p>

  <html:p>Conversely, suppose that <fr:tex display="inline"><![CDATA[u\in \mathsf {L}{A}]]></fr:tex> is a positive element. Let <fr:tex display="inline"><![CDATA[U]]></fr:tex> be the semidirected family <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{v \mid  v = u \land  u\downarrow \right \}\mathclose {}}]]></fr:tex>; we evidently have <fr:tex display="inline"><![CDATA[u\sqsubseteq  \bigsqcup {U}]]></fr:tex>, so <fr:tex display="inline"><![CDATA[U]]></fr:tex> is inhabited. Thus it follows that <fr:tex display="inline"><![CDATA[u]]></fr:tex> is defined.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002T/</fr:uri>
                    <fr:display-uri>jms-002T</fr:display-uri>
                    <fr:route>/jms-002T/</fr:route>
                    <fr:title text="Characterization of positivity in terms of partial elements">Characterization of positivity in terms of partial elements</fr:title>
                    <fr:taxon>Theorem</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo. Then an element <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link> if and only if for any partial element <fr:tex display="inline"><![CDATA[u: LA]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a\sqsubseteq \bigsqcup _{p:u{\downarrow }}u[p]]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[u{\downarrow }=\top ]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Therefore, we first suppose that any <fr:tex display="inline"><![CDATA[u: LA]]></fr:tex> is defined supposing <fr:tex display="inline"><![CDATA[a\sqsubseteq \bigsqcup _{p:u{\downarrow }}u[p]]]></fr:tex> to check that <fr:tex display="inline"><![CDATA[a]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link>. Fixing a semidirected subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup {I}]]></fr:tex>, we must show that <fr:tex display="inline"><![CDATA[I]]></fr:tex> is inhabited.
  We consider the partial element <fr:tex display="inline"><![CDATA[u={\mathopen {}\left (\exists  i\in  I. \top , \lambda \_.\bigsqcup {I}\right )\mathclose {}}:LA]]></fr:tex>, and observe that <fr:tex display="inline"><![CDATA[\bigsqcup {I}=\bigsqcup _{i\in  I} \bigsqcup {I}=\bigsqcup _{p:u{\downarrow }}u[p]]]></fr:tex>, and so we have <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup _{p:u{\downarrow }}u[p]]]></fr:tex> and thus it follows that <fr:tex display="inline"><![CDATA[u{\downarrow }=\top ]]></fr:tex> and so <fr:tex display="inline"><![CDATA[I]]></fr:tex> is inhabited.</html:p>

  <html:p>Conversely, if <fr:tex display="inline"><![CDATA[a]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link>, it follows that any partial element <fr:tex display="inline"><![CDATA[u]]></fr:tex> is defined when <fr:tex display="inline"><![CDATA[a\sqsubseteq \bigsqcup _{p:u{\downarrow }}u[p]]]></fr:tex>, because the subset <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{y\mid  y=a\land  u{\downarrow }\right \}\mathclose {}}]]></fr:tex> is semidirected.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002X/</fr:uri>
                    <fr:display-uri>jms-002X</fr:display-uri>
                    <fr:route>/jms-002X/</fr:route>
                    <fr:title text="Positivity and the strictly-below relation">Positivity and the strictly-below relation</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>It follows from our <fr:link href="/jms-002T/" title="Characterization of positivity in terms of partial elements" uri="https://www.jonmsterling.com/jms-002T/" display-uri="jms-002T" type="local">characterization</fr:link> of <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positivity</fr:link> in terms of partial elements that an element <fr:tex display="inline"><![CDATA[a: A]]></fr:tex> of a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive</fr:link> if and only if it is <fr:link href="/jms-002W/" title="The strictly-below relation" uri="https://www.jonmsterling.com/jms-002W/" display-uri="jms-002W" type="local">strictly above</fr:link> the bottom element, i.e. <fr:tex display="inline"><![CDATA[\bot \sqsubset  a]]></fr:tex>.</html:p>
                    <html:p>(See also Proposition 6.2.12 of <fr:link href="/dejong-2023-thesis/" title="Domain theory in constructive and predicative univalent foundations" uri="https://www.jonmsterling.com/dejong-2023-thesis/" display-uri="dejong-2023-thesis" type="local">Tom de Jong’s thesis</fr:link>.)</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>21</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002O/</fr:uri>
                    <fr:display-uri>jms-002O</fr:display-uri>
                    <fr:route>/jms-002O/</fr:route>
                    <fr:title text="A general characterization of positivity">A general characterization of positivity</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>So far we have studied <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positivity</fr:link> as an order-theoretic property of domains; in this section, we explore a non-order-theoretic generalization of this condition that is applicable in the setting of axiomatic domain theory. This notion is inspired by the <fr:link href="/jms-002T/" title="Characterization of positivity in terms of partial elements" uri="https://www.jonmsterling.com/jms-002T/" display-uri="jms-002T" type="local">alternative characterization positivity in terms of partial elements</fr:link>.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002P/</fr:uri>
                        <fr:display-uri>jms-002P</fr:display-uri>
                        <fr:route>/jms-002P/</fr:route>
                        <fr:title text="The Sierpiński interval of a dominion">The Sierpiński interval of a dominion</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be a category with pullbacks, a terminal object and let <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> be a dominion on <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex>. A <html:em>Sierpiński space</html:em> for <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> is defined to be a universal <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex>-partial map, i.e. a morphism <fr:tex display="inline"><![CDATA[{\mathbf {1}_{\mathcal {C}}}\xrightarrow {{\top }}{\Sigma }\in \mathcal {M}]]></fr:tex> such that for any <fr:tex display="inline"><![CDATA[{U}\xrightarrow {{i}}{A}\in  \mathcal {M}]]></fr:tex> there exists a unique map <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{\chi _i}}{\Sigma }]]></fr:tex> making the following square cartesian:</html:p>
 
  
  <html:figure><fr:resource hash="23d06d21ba7b8cae296d9b9a89642b63"><fr:resource-content><html:img src="/23d06d21ba7b8cae296d9b9a89642b63.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    ne = \mathbf {1}_{\mathcal {C}},
    se = \Sigma ,
    east = \top \in  \mathcal {M},
    sw = A,
    nw = U,
    west = \mathcal {M}\ni  i,
    south = \chi _i,
    south/style = {->,exists},
    west/style = >->,
    east/style = >->,
    nw/style = pullback,
  }
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>When <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> has an initial object <fr:tex display="inline"><![CDATA[\mathbf {0}_{\mathcal {C}}]]></fr:tex> and every <fr:tex display="inline"><![CDATA[{\mathbf {0}_{\mathcal {C}}}\xrightarrow {{}}{A}]]></fr:tex> lies in <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex>, the Sierpiński space becomes an “interval object” <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ,\top ,\bot \right )\mathclose {}}]]></fr:tex> where <fr:tex display="inline"><![CDATA[{\mathbf {1}_{\mathcal {C}}}\xrightarrow {{\bot }}{\Sigma }]]></fr:tex> is given as follows:</html:p>
 
  
  <html:figure><fr:resource hash="90281a7184eaad2cfe27c224a486ee82"><fr:resource-content><html:img src="/90281a7184eaad2cfe27c224a486ee82.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    ne = \mathbf {1}_{\mathcal {C}},
    se = \Sigma ,
    east = \top ,
    sw = \mathbf {1}_{\mathcal {C}},
    nw = \mathbf {0}_{\mathcal {C}},
    south = \bot ,
    south/style = {->,exists},
    west/style = >->,
    east/style = >->,
    nw/style = pullback,
  }
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Under these circumstances, we refer to <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> as a dominion that has a <html:em>Sierpiński interval</html:em>.</html:p></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002Q/</fr:uri>
                        <fr:display-uri>jms-002Q</fr:display-uri>
                        <fr:route>/jms-002Q/</fr:route>
                        <fr:title text="Paths in a dominion">Paths in a dominion</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be category with pullbacks, a terminal object, and an initial object, equipped with a dominion <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> that has a <fr:link href="/jms-002P/" title="The Sierpiński interval of a dominion" uri="https://www.jonmsterling.com/jms-002P/" display-uri="jms-002P" type="local">Sierpiński interval</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ,\top ,\bot \right )\mathclose {}}]]></fr:tex>. A <html:em>path</html:em> from <fr:tex display="inline"><![CDATA[{I}\xrightarrow {{f}}{C}]]></fr:tex> to <fr:tex display="inline"><![CDATA[{I}\xrightarrow {{g}}{C}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> is defined to be a morphism <fr:tex display="inline"><![CDATA[{\Sigma \times  I}\xrightarrow {{p}}{C}]]></fr:tex> such that the following diagram commutes:</html:p>
 
  
  <html:figure><fr:resource hash="fcf5d2401e69e9d2846dee7512cbe681"><fr:resource-content><html:img src="/fcf5d2401e69e9d2846dee7512cbe681.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (IxSigma) {$I\times \Sigma $};
    \node [above = of IxSigma] (I/n) {$I$};
    \node [below = of IxSigma] (I/s) {$I$};
    \node [right = of IxSigma] (C) {$C$};
    \draw [>->] (I/n) to node[left] {${\mathopen {}\left \langle 1_{I},\bot \right \rangle \mathclose {}}$} (IxSigma);
    \draw [>->] (I/s) to node[left] {${\mathopen {}\left \langle 1_{I},\top \right \rangle \mathclose {}}$} (IxSigma);
    \draw [->] (IxSigma) to node[upright desc] {$p$} (C);
    \draw [->] (I/n) to node[sloped,above] {$f$} (C);
    \draw [->] (I/s) to node[sloped,below] {$g$} (C);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>We shall write <fr:tex display="inline"><![CDATA[p:f\leadsto  g]]></fr:tex> to denote a path from <fr:tex display="inline"><![CDATA[f]]></fr:tex> to <fr:tex display="inline"><![CDATA[g]]></fr:tex>.</html:p></fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002R/</fr:uri>
                        <fr:display-uri>jms-002R</fr:display-uri>
                        <fr:route>/jms-002R/</fr:route>
                        <fr:title text="Positive elements in a dominion">Positive elements in a dominion</fr:title>
                        <fr:taxon>Definition</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex> be category with pullbacks, a terminal object, and an initial object, equipped with a dominion <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex> that has a <fr:link href="/jms-002P/" title="The Sierpiński interval of a dominion" uri="https://www.jonmsterling.com/jms-002P/" display-uri="jms-002P" type="local">Sierpiński interval</fr:link> <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\Sigma ,\top ,\bot \right )\mathclose {}}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex>-partial map classifiers <fr:tex display="inline"><![CDATA[LA]]></fr:tex> exist for all <fr:tex display="inline"><![CDATA[A\in \mathcal {C}]]></fr:tex>. We will write <fr:tex display="inline"><![CDATA[\mathbb {L}={\mathopen {}\left (L,\eta ,\mu \right )\mathclose {}}]]></fr:tex> for the resulting partial map classifier monad on <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex>.</html:p><html:p>Let <fr:tex display="inline"><![CDATA[{\mathopen {}\left (A,\alpha \right )\mathclose {}}]]></fr:tex> be an <fr:tex display="inline"><![CDATA[\mathbb {L}]]></fr:tex>-algebra in <fr:tex display="inline"><![CDATA[\mathcal {C}]]></fr:tex>, and let <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{x}}{A}]]></fr:tex> be a generalized element of <fr:tex display="inline"><![CDATA[A]]></fr:tex>. We say that <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{x}}{A}]]></fr:tex> is <html:em>positive</html:em> when for any <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{u}}{LA}]]></fr:tex> such that there exists a path from <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{x}}{A}]]></fr:tex> to <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{u;\alpha }}{A}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{u}}{LA}]]></fr:tex> factors through some (necessarily unique) <fr:tex display="inline"><![CDATA[{C}\xrightarrow {{y}}{A}]]></fr:tex> as below:</html:p>
 
  
  <html:figure><fr:resource hash="8f3c547094546fda0775672b1fdbf7b2"><fr:resource-content><html:img src="/8f3c547094546fda0775672b1fdbf7b2.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (nw) {$C$};
    \node [right = of nw] (ne) {$A$};
    \node [below = of ne] (se) {$LA$};
    \draw [exists,->] (nw) to node[above] {$y$} (ne);
    \draw [>->] (ne) to node[right] {$\eta _A$} (se);
    \draw [->] (nw) to node[sloped,below] {$u$} (se);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>21</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002S/</fr:uri>
                        <fr:display-uri>jms-002S</fr:display-uri>
                        <fr:route>/jms-002S/</fr:route>
                        <fr:title text="The two notions of positivity coincide for pointed dcpos">The two notions of positivity coincide for pointed dcpos</fr:title>
                        <fr:taxon>Corollary</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo. Then an element <fr:tex display="inline"><![CDATA[x:A]]></fr:tex> is a <fr:link href="/jms-001M/" title="The positive elements of a pointed dcpo" uri="https://www.jonmsterling.com/jms-001M/" display-uri="jms-001M" type="local">positive element of the pointed dcpo</fr:link> if and only if <fr:tex display="inline"><![CDATA[{\mathbf {1}_{}}\xrightarrow {{x}}{A}]]></fr:tex> is a <fr:link href="/jms-002R/" title="Positive elements in a dominion" uri="https://www.jonmsterling.com/jms-002R/" display-uri="jms-002R" type="local">positive element in the dominion</fr:link> <fr:tex display="inline"><![CDATA[\mathcal {O}]]></fr:tex> of Scott-open immersions of dcpos.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>21</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We first observe that the <fr:link href="/jms-002R/" title="Positive elements in a dominion" uri="https://www.jonmsterling.com/jms-002R/" display-uri="jms-002R" type="local">latter condition</fr:link> is equivalent to the following:</html:p>
  <html:blockquote>For any <fr:tex display="inline"><![CDATA[u\in  LA]]></fr:tex>, if <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup _{p: u{\downarrow }}u[p]]]></fr:tex> then <fr:tex display="inline"><![CDATA[u{\downarrow }=\top ]]></fr:tex>.</html:blockquote>

  <html:p>This follows from the <fr:link href="https://github.com/jonsterling/coq-domains/blob/main/theories/Path.v" type="external">(constructive) characterization</fr:link> of the <fr:link href="/jms-002Q/" title="Paths in a dominion" uri="https://www.jonmsterling.com/jms-002Q/" display-uri="jms-002Q" type="local">path</fr:link> order in dcpos. Therefore, our result follows from our <fr:link href="/jms-002T/" title="Characterization of positivity in terms of partial elements" uri="https://www.jonmsterling.com/jms-002T/" display-uri="jms-002T" type="local">earlier characterization</fr:link> of positive elements of a pointed dcpo in terms of partial elements.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                  <fr:contributor>
                    <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                  </fr:contributor>
                  <fr:contributor>
                    <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                  </fr:contributor>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-002D/</fr:uri>
                <fr:display-uri>jms-002D</fr:display-uri>
                <fr:route>/jms-002D/</fr:route>
                <fr:title text="Positive generation and open positivity predicates">Positive generation and open positivity predicates</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In a lifted dcpo <fr:tex display="inline"><![CDATA[\mathsf {L}{A}]]></fr:tex>, the <fr:link href="/jms-001P/" title="The subdcpo spanned by positive elements" uri="https://www.jonmsterling.com/jms-001P/" display-uri="jms-001P" type="local">positive elements</fr:link> form an <html:em>open</html:em> subdcpo <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {L}{A}\right )\mathclose {}}^+\cong  A]]></fr:tex>: thus, it follows that positivity is always an open property in classical mathematics. On the other hand, it seems that constructive mathematics does not necessarily assert that the positive elements form an open subspace in general. In this section, we grapple with this subtlety by studying the relationship between openness of <fr:tex display="inline"><![CDATA[A^+]]></fr:tex> and a desirable property that we shall refer to as <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positive generation</fr:link>, which states that every element of <fr:tex display="inline"><![CDATA[A]]></fr:tex> is the supremum of its “positive part”.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0022/</fr:uri>
                    <fr:display-uri>jms-0022</fr:display-uri>
                    <fr:route>/jms-0022/</fr:route>
                    <fr:title text="Open positivity predicate">Open positivity predicate</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We say that a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> has an <html:em>open positivity predicate</html:em> if and only if any of the following equivalent conditions hold:</html:p>
                    <html:ol><html:li>The positivity predicate <fr:tex display="inline"><![CDATA[{\Gamma  A}\xrightarrow {{\mathsf {pos}}}{\Omega }]]></fr:tex> tracks a continuous morphism of dcpos <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{\mathsf {pos}}}{\Sigma }]]></fr:tex>.</html:li>

  <html:li>The embedding <fr:tex display="inline"><![CDATA[{A^+}\xrightarrow {{\iota ^+}}{A}]]></fr:tex> is a Scott-open immersion.</html:li>
  <html:li>For a directed subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex>, if <fr:tex display="inline"><![CDATA[\bigsqcup {A}]]></fr:tex> is positive then there exists an element <fr:tex display="inline"><![CDATA[a\in  I]]></fr:tex> that is positive in <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002F/</fr:uri>
                    <fr:display-uri>jms-002F</fr:display-uri>
                    <fr:route>/jms-002F/</fr:route>
                    <fr:title text="Positively generated elements">Positively generated elements</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a dcpo; then an element <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> is called <html:em>positively generated</html:em> when it is the supremum of the semidirected subset <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{b:A\mid  b=a\land  \mathsf {pos}\,{a}\right \}\mathclose {}}]]></fr:tex>, i.e. we have <fr:tex display="inline"><![CDATA[a \sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002J/</fr:uri>
                    <fr:display-uri>jms-002J</fr:display-uri>
                    <fr:route>/jms-002J/</fr:route>
                    <fr:title text="Non-negatively generated elements">Non-negatively generated elements</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>An element <fr:tex display="inline"><![CDATA[a]]></fr:tex> of a pointed dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> is called <html:em>non-negatively generated</html:em> when <fr:tex display="inline"><![CDATA[a \sqsubseteq  \bigsqcup _{\lnot {\mathopen {}\left (a=\bot \right )\mathclose {}}}a]]></fr:tex> holds.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002N/</fr:uri>
                    <fr:display-uri>jms-002N</fr:display-uri>
                    <fr:route>/jms-002N/</fr:route>
                    <fr:title text="Positively generated elements are non-negatively generated">Positively generated elements are non-negatively generated</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[a]]></fr:tex> be a <fr:link href="/jms-002F/" title="Positively generated elements" uri="https://www.jonmsterling.com/jms-002F/" display-uri="jms-002F" type="local">positively generated element</fr:link> of a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[a]]></fr:tex> is also <fr:link href="/jms-002J/" title="Non-negatively generated elements" uri="https://www.jonmsterling.com/jms-002J/" display-uri="jms-002J" type="local">non-negatively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We must check that <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup _{p:\lnot {\mathopen {}\left (a = \bot \right )\mathclose {}}}a]]></fr:tex>. By assumption, it suffices to check that <fr:tex display="inline"><![CDATA[\bigsqcup _{p:\mathsf {pos}\,a}a\sqsubseteq \bigsqcup _{p:\lnot {\mathopen {}\left (a=\bot \right )\mathclose {}}}a]]></fr:tex>, which follows because <fr:link href="/jms-002H/" title="The bottom element is not positive" uri="https://www.jonmsterling.com/jms-002H/" display-uri="jms-002H" type="local">the bottom element is not positive</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002I/</fr:uri>
                    <fr:display-uri>jms-002I</fr:display-uri>
                    <fr:route>/jms-002I/</fr:route>
                    <fr:title text="Bottom and non-bottom elements are non-negatively generated">Bottom and non-bottom elements are non-negatively generated</fr:title>
                    <fr:taxon>Example</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>In a pointed dcpo, any non-bottom element is non-negatively generated.</html:p><html:ol><html:li>The bottom element <fr:tex display="inline"><![CDATA[\bot ]]></fr:tex>.</html:li>
  <html:li>Any compact element <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> for which <fr:tex display="inline"><![CDATA[\lnot {\mathopen {}\left (a=\bot \right )\mathclose {}}]]></fr:tex> holds.</html:li></html:ol><html:p>Hence, any element <fr:tex display="inline"><![CDATA[a]]></fr:tex> for which it is decidable whether <fr:tex display="inline"><![CDATA[a=\bot ]]></fr:tex> is non-negatively generated.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>The bottom element is clearly non-negatively generated, as it lies beneath any element. Now fix <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> and assume <fr:tex display="inline"><![CDATA[\lnot {\mathopen {}\left (a=\bot \right )\mathclose {}}]]></fr:tex>; we must check that <fr:tex display="inline"><![CDATA[a \sqsubseteq  \bigsqcup _{p:\lnot {\mathopen {}\left (a=\bot \right )\mathclose {}}}a]]></fr:tex> but the latter is equal to <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0023/</fr:uri>
                    <fr:display-uri>jms-0023</fr:display-uri>
                    <fr:route>/jms-0023/</fr:route>
                    <fr:title text="Positively generated dcpos">Positively generated dcpos</fr:title>
                    <fr:taxon>Definition</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>When a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> satisfies either of the following equivalent conditions, we will refer to it as <html:em>positively generated</html:em>.</html:p><html:ol><html:li>Every element <fr:tex display="inline"><![CDATA[a: A]]></fr:tex> is <fr:link href="/jms-002F/" title="Positively generated elements" uri="https://www.jonmsterling.com/jms-002F/" display-uri="jms-002F" type="local">positively generated</fr:link>, i.e. we have <fr:tex display="inline"><![CDATA[a = \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>.</html:li>
  <html:li>For any semidirected subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[\bigsqcup  I = \bigsqcup  {\mathopen {}\left \{a\in  I \mid  \mathsf {pos}\,a\right \}\mathclose {}}]]></fr:tex>.</html:li></html:ol>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>(2) implies (1) by setting <fr:tex display="inline"><![CDATA[I = {\mathopen {}\left \{a\right \}\mathclose {}}]]></fr:tex>. Conversely, assume that each element is the supremum of its positive part and fix a semidirected subset <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex>. We compute:</html:p>

  <fr:tex display="block"><![CDATA[\bigsqcup {\mathopen {}\left \{a \in  I \mid  \mathsf {pos}\,a\right \}\mathclose {}}
  =
  \bigsqcup _{a\in  {\mathopen {}\left \{a \in  I\mid  \mathsf {pos}\,a\right \}\mathclose {}}}a
  =
  \bigsqcup _{a\in  I}\bigsqcup _{p\in  \mathsf {pos}\,a} a
  =
  \bigsqcup _{a\in  I} a
  ]]></fr:tex>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0027/</fr:uri>
                    <fr:display-uri>jms-0027</fr:display-uri>
                    <fr:route>/jms-0027/</fr:route>
                    <fr:title text="Positively generated dcpos have open positivity predicates">Positively generated dcpos have open positivity predicates</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link> <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo. Then <fr:tex display="inline"><![CDATA[A]]></fr:tex> has an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link></fr:author><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex> be a directed subset such that <fr:tex display="inline"><![CDATA[\bigsqcup {I}]]></fr:tex> is positive; we must find a positive element of <fr:tex display="inline"><![CDATA[I]]></fr:tex>. Because <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link> we know that <fr:tex display="inline"><![CDATA[\bigsqcup {I} \sqsubseteq  \bigsqcup {\mathopen {}\left (I\cap  A^+\right )\mathclose {}}]]></fr:tex>. Because <fr:tex display="inline"><![CDATA[\bigsqcup {I}]]></fr:tex> is positive and <fr:tex display="inline"><![CDATA[I\cap  A^+]]></fr:tex> <fr:link href="/jms-0028/" title="The positive part of a semidirected subset is semidirected" uri="https://www.jonmsterling.com/jms-0028/" display-uri="jms-0028" type="local">is semidirected</fr:link>, it follows that the latter is inhabited.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0025/</fr:uri>
                    <fr:display-uri>jms-0025</fr:display-uri>
                    <fr:route>/jms-0025/</fr:route>
                    <fr:title text="Lifted dcpos are positively generated">Lifted dcpos are positively generated</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a dcpo; then the lift <fr:tex display="inline"><![CDATA[\mathsf {L}{A}]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[u={\mathopen {}\left (\phi ,a\right )\mathclose {}}]]></fr:tex> be an element of <fr:tex display="inline"><![CDATA[\mathsf {L}{A}]]></fr:tex>. Note that <fr:tex display="inline"><![CDATA[u]]></fr:tex> is equal to <fr:tex display="inline"><![CDATA[\bigsqcup _{p:\phi }u]]></fr:tex>; as <fr:link href="/jms-001N/" title="Positivity = definedness in a lifted dcpo" uri="https://www.jonmsterling.com/jms-001N/" display-uri="jms-001N" type="local">definedness coincides with positivity</fr:link> in lifted dcpos, we have <fr:tex display="inline"><![CDATA[\phi  = \mathsf {pos}\,u]]></fr:tex>, and so we are done.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0024/</fr:uri>
                    <fr:display-uri>jms-0024</fr:display-uri>
                    <fr:route>/jms-0024/</fr:route>
                    <fr:title text="Lifted dcpos have open positivity predicates">Lifted dcpos have open positivity predicates</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a dcpo; then the lifting <fr:tex display="inline"><![CDATA[\mathsf {L}{A}]]></fr:tex> has an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>It <fr:link href="/jms-0027/" title="Positively generated dcpos have open positivity predicates" uri="https://www.jonmsterling.com/jms-0027/" display-uri="jms-0027" type="local">suffices</fr:link> to recall that a <fr:link href="/jms-0025/" title="Lifted dcpos are positively generated" uri="https://www.jonmsterling.com/jms-0025/" display-uri="jms-0025" type="local">lifted dcpo is positively generated</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:contributor>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:contributor>
                      <fr:contributor>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:contributor>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002L/</fr:uri>
                    <fr:display-uri>jms-002L</fr:display-uri>
                    <fr:route>/jms-002L/</fr:route>
                    <fr:title text="When is a continuous pointed dcpo positively generated?">When is a continuous pointed dcpo positively generated?</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We describe some light conditions under which a continuous dcpo is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                          </fr:author>
                          <fr:author>
                            <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                          </fr:author>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>16</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0026/</fr:uri>
                        <fr:display-uri>jms-0026</fr:display-uri>
                        <fr:route>/jms-0026/</fr:route>
                        <fr:title text="Non-negatively generated basis yields positive generation">Non-negatively generated basis yields positive generation</fr:title>
                        <fr:taxon>Lemma</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> continuous dcpo presented by a basis <fr:tex display="inline"><![CDATA[B\subseteq  A]]></fr:tex> such that each element of <fr:tex display="inline"><![CDATA[B]]></fr:tex> is <fr:link href="/jms-002J/" title="Non-negatively generated elements" uri="https://www.jonmsterling.com/jms-002J/" display-uri="jms-002J" type="local">non-negatively generated</fr:link> in <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link></fr:author><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We must show that for any <fr:tex display="inline"><![CDATA[a\in  A]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[a \sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[B_a]]></fr:tex> be the subset <fr:tex display="inline"><![CDATA[{\mathopen {}\left \{b \in  B \mid  b\ll  a\right \}\mathclose {}}]]></fr:tex>. By assumption, it suffices to check that <fr:tex display="inline"><![CDATA[\bigsqcup  B_a \sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>. Fixing <fr:tex display="inline"><![CDATA[b\in  B_a]]></fr:tex>, we must check that <fr:tex display="inline"><![CDATA[b\sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>.</html:p>

  <html:p>As <fr:tex display="inline"><![CDATA[b]]></fr:tex> is assumed to be <fr:link href="/jms-002J/" title="Non-negatively generated elements" uri="https://www.jonmsterling.com/jms-002J/" display-uri="jms-002J" type="local">non-negatively generated</fr:link>, we have <fr:tex display="inline"><![CDATA[b=\bigsqcup _{p:\lnot {\mathopen {}\left (b=\bot \right )\mathclose {}}}b]]></fr:tex> so to check <fr:tex display="inline"><![CDATA[b\sqsubseteq \bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex> it suffices to check that <fr:tex display="inline"><![CDATA[\lnot {\mathopen {}\left (b=\bot \right )\mathclose {}}]]></fr:tex> implies that <fr:tex display="inline"><![CDATA[a]]></fr:tex> is positive. We fix semidirected <fr:tex display="inline"><![CDATA[J\subseteq  A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup {J} = \bigsqcup {\mathopen {}\left ({\mathopen {}\left \{\bot \right \}\mathclose {}}\cup  J\right )\mathclose {}}]]></fr:tex> to check that <fr:tex display="inline"><![CDATA[J]]></fr:tex> is inhabited. We recall that <fr:tex display="inline"><![CDATA[b\ll  a]]></fr:tex> and <fr:tex display="inline"><![CDATA[a\sqsubseteq  \bigsqcup {\mathopen {}\left ({\mathopen {}\left \{\bot \right \}\mathclose {}}\cup  J\right )\mathclose {}}]]></fr:tex>, so it follows by the definition of the <fr:link href="/jms-002V/" title="The way-below relation" uri="https://www.jonmsterling.com/jms-002V/" display-uri="jms-002V" type="local">way-below relation</fr:link> that either <fr:tex display="inline"><![CDATA[b\sqsubseteq  \bot ]]></fr:tex> or there exists <fr:tex display="inline"><![CDATA[j\in  J]]></fr:tex> such that <fr:tex display="inline"><![CDATA[b\sqsubseteq  j]]></fr:tex>. The first case is contradictory by our assumption that <fr:tex display="inline"><![CDATA[\lnot {\mathopen {}\left (b=\bot \right )\mathclose {}}]]></fr:tex>, and the second case verifies that <fr:tex display="inline"><![CDATA[J]]></fr:tex> is inhabited, so <fr:tex display="inline"><![CDATA[a]]></fr:tex> is positive.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>16</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002K/</fr:uri>
                        <fr:display-uri>jms-002K</fr:display-uri>
                        <fr:route>/jms-002K/</fr:route>
                        <fr:title text="Basis with decidable bottomhood yields positive generation">Basis with decidable bottomhood yields positive generation</fr:title>
                        <fr:taxon>Corollary</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a pointed continuous dcpo presented by a basis <fr:tex display="inline"><![CDATA[B\subseteq  A]]></fr:tex> for each element <fr:tex display="inline"><![CDATA[b\in  B]]></fr:tex> it is decidable whether <fr:tex display="inline"><![CDATA[b=\bot ]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We observe that <fr:link href="/jms-002I/" title="Bottom and non-bottom elements are non-negatively generated" uri="https://www.jonmsterling.com/jms-002I/" display-uri="jms-002I" type="local">every element of <fr:tex display="inline"><![CDATA[B]]></fr:tex> is non-negatively generated</fr:link>, so we <fr:link href="/jms-0026/" title="Non-negatively generated basis yields positive generation" uri="https://www.jonmsterling.com/jms-0026/" display-uri="jms-0026" type="local">may conclude</fr:link> that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>2</fr:month>
                          <fr:day>16</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-002M/</fr:uri>
                        <fr:display-uri>jms-002M</fr:display-uri>
                        <fr:route>/jms-002M/</fr:route>
                        <fr:title text="Positively generated basis yields positive generation">Positively generated basis yields positive generation</fr:title>
                        <fr:taxon>Corollary</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a pointed continuous dcpo presented by a basis <fr:tex display="inline"><![CDATA[B\subseteq  A]]></fr:tex> whose elements are all <fr:link href="/jms-002F/" title="Positively generated elements" uri="https://www.jonmsterling.com/jms-002F/" display-uri="jms-002F" type="local">positively generated</fr:link> in <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>As <fr:link href="/jms-002N/" title="Positively generated elements are non-negatively generated" uri="https://www.jonmsterling.com/jms-002N/" display-uri="jms-002N" type="local">positive generation implies non-negative generation</fr:link> for an element of a pointed dcpo, we <fr:link href="/jms-0026/" title="Non-negatively generated basis yields positive generation" uri="https://www.jonmsterling.com/jms-0026/" display-uri="jms-0026" type="local">may conclude</fr:link> that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is positively generated.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>I am not sure how useful the <fr:link href="/jms-002G/" title="The positively generated core of a dcpo" uri="https://www.jonmsterling.com/jms-002G/" display-uri="jms-002G" type="local">following construction</fr:link> is. On the other hand, maybe it has a universal property at the level of posets.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002G/</fr:uri>
                    <fr:display-uri>jms-002G</fr:display-uri>
                    <fr:route>/jms-002G/</fr:route>
                    <fr:title text="The positively generated core of a dcpo">The positively generated core of a dcpo</fr:title>
                    <fr:taxon>Construction</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a pointed dcpo; the subposet <fr:tex display="inline"><![CDATA[A^{\mathit {pg}}\subseteq {A}]]></fr:tex> spanned by <fr:link href="/jms-002F/" title="Positively generated elements" uri="https://www.jonmsterling.com/jms-002F/" display-uri="jms-002F" type="local">positively generated elements</fr:link> is closed under directed suprema, and thus gives rise to a subdcpo that we shall refer to as the <html:em>positively generated core</html:em> of <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>Let <fr:tex display="inline"><![CDATA[I\subseteq  A]]></fr:tex> be a directed subset whose elements are all <fr:link href="/jms-002F/" title="Positively generated elements" uri="https://www.jonmsterling.com/jms-002F/" display-uri="jms-002F" type="local">positively generated</fr:link>. We must check that the supremum <fr:tex display="inline"><![CDATA[\bigsqcup {I}]]></fr:tex> is positively generated, i.e. <fr:tex display="inline"><![CDATA[\bigsqcup {I} \sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,\bigsqcup {I}}\bigsqcup {I}]]></fr:tex>. Fixing <fr:tex display="inline"><![CDATA[i\in  I]]></fr:tex>, we must check that <fr:tex display="inline"><![CDATA[i\sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,{\bigsqcup {I}}}\bigsqcup {I}]]></fr:tex>. As <fr:tex display="inline"><![CDATA[i]]></fr:tex> is positively generated, we have <fr:tex display="inline"><![CDATA[i\sqsubseteq \bigsqcup _{p:\mathsf {pos}\,{i}}i]]></fr:tex>. As <fr:link href="/jms-0029/" title="Positivity is upward-closed" uri="https://www.jonmsterling.com/jms-0029/" display-uri="jms-0029" type="local">positivity is upward-closed</fr:link>, we have <fr:tex display="inline"><![CDATA[\mathsf {pos}\,{i}\sqsubseteq \mathsf {pos}\,\bigsqcup {I}]]></fr:tex>. Therefore, we deduce <fr:tex display="inline"><![CDATA[i\sqsubseteq  \bigsqcup _{p:\mathsf {pos}\,i}i \sqsubseteq   \bigsqcup _{p:\mathsf {pos}\,{\bigsqcup {I}}}\bigsqcup {I}]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                  <fr:contributor>
                    <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                  </fr:contributor>
                  <fr:contributor>
                    <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                  </fr:contributor>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>2</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-001Z/</fr:uri>
                <fr:display-uri>jms-001Z</fr:display-uri>
                <fr:route>/jms-001Z/</fr:route>
                <fr:title text="Characterizing freeness in terms of positivity">Characterizing freeness in terms of positivity</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In classical mathematics, every <fr:tex display="inline"><![CDATA[\mathbb {L}]]></fr:tex>-algebra is free; this does not appear to be asserted by constructive mathematics, but in this section we verify that freeness can be characterized in terms of positivity. The <fr:link href="/jms-002B/" title="Liftedness = positive generation" uri="https://www.jonmsterling.com/jms-002B/" display-uri="jms-002B" type="local">main result</fr:link> is that a pointed dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link> if and only the evident map <fr:tex display="inline"><![CDATA[{\mathsf {L}{A^+}}\xrightarrow {{}}{A}]]></fr:tex> is an isomorphism.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0021/</fr:uri>
                    <fr:display-uri>jms-0021</fr:display-uri>
                    <fr:route>/jms-0021/</fr:route>
                    <fr:title text="The “purification” map">The “purification” map</fr:title>
                    <fr:taxon>Construction</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo with an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link>; we define the “purification” map <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{\mathsf {purify}_A}}{\mathsf {L}{A^+}}]]></fr:tex> into the lift of the <fr:link href="/jms-001P/" title="The subdcpo spanned by positive elements" uri="https://www.jonmsterling.com/jms-001P/" display-uri="jms-001P" type="local">subdcpo of positive elements</fr:link> to send <fr:tex display="inline"><![CDATA[a\in  A]]></fr:tex> to the partial element <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {pos}\,{a},\lambda  p. a\right )\mathclose {}}]]></fr:tex>; we note:</html:p>
                    <fr:tex display="block"><![CDATA[ \mathsf {purify}_Aa = {\mathopen {}\left (\mathsf {pos}\,{a},\lambda  p. a\right )\mathclose {}} = \bigsqcup _{p:\mathsf {pos}\,a}\eta _Aa]]></fr:tex>
                    <html:p>The mapping defined above  is continuous because we have assumed that <fr:tex display="inline"><![CDATA[A]]></fr:tex> has an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link>, so its domain of definition defines a Scott-open subdcpo of <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0020/</fr:uri>
                    <fr:display-uri>jms-0020</fr:display-uri>
                    <fr:route>/jms-0020/</fr:route>
                    <fr:title text="Pointed dcpos with open positivity predicates are almost free">Pointed dcpos with open positivity predicates are almost free</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo with an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link>; then the <fr:link href="/jms-0021/" title="The “purification” map" uri="https://www.jonmsterling.com/jms-0021/" display-uri="jms-0021" type="local">purification map</fr:link> <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{\mathsf {purify}_A}}{\mathsf {L}{A^+}}]]></fr:tex> is the projection part of an embedding-projection pair <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {L}{\iota ^+};\alpha _A\right )\mathclose {}}\dashv  \mathsf {purify}_A]]></fr:tex>.</html:p>
 
  
  <html:figure><fr:resource hash="5df958f6003a31c2a0eae7def6a479ed"><fr:resource-content><html:img src="/5df958f6003a31c2a0eae7def6a479ed.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \node  (nw) {$\mathsf {L}{A^+}$};
    \node [right = 2.5cm of nw] (ne) {$A$};
    \node [below = of ne] (se) {$\mathsf {L}{A^+}$};
    \draw [>->] (nw) to node[above] {$\mathsf {L}{\iota ^+};\alpha _A$} (ne);
    \draw [->>] (ne) to node[right] {$\mathsf {purify}_A$} (se);
    \draw [double] (nw) to node[sloped,below] {$1_{\mathsf {L}{A^+}}$} (se);
  \end {tikzpicture}
  \qquad 
  \begin {tikzpicture}[diagram]
    \node  (nw) {$A$};
    \node [below = of nw] (sw) {$\mathsf {L}{A^+}$};
    \node [right = 2.5cm of sw] (se) {$A$};
    \draw [->>] (nw) to node[left] {$\mathsf {purify}_A$} (sw);
    \draw [>->] (sw) to node[below] {$\mathsf {L}{\iota ^+};\alpha _A$} (se);
    \draw [double] (nw) to node[sloped,above] (idn) {$1_{A}$} (se);
    \node [between = sw and idn] {$\sqsubseteq $};
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 

 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link></fr:author><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>14</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>We fix <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\phi ,a^+\right )\mathclose {}}: \mathsf {L}{A^+}]]></fr:tex> and compute explicitly using the fact that <fr:tex display="inline"><![CDATA[\mathsf {purify}_A]]></fr:tex> preserves the bottom element and therefore preserves semidirected subsets:</html:p>

  <fr:tex display="block"><![CDATA[\begin {aligned}
    \mathsf {purify}_A{\mathopen {}\left (\alpha _A{\mathopen {}\left (\mathsf {L}{\iota ^+}{\mathopen {}\left (\phi ,a^+\right )\mathclose {}}\right )\mathclose {}}\right )\mathclose {}} & =
    \mathsf {purify}_A{\mathopen {}\left (\alpha _A{\mathopen {}\left (\phi ,a^+\right )\mathclose {}}\right )\mathclose {}}
    \\
                                                              & = \mathsf {purify}_A\bigsqcup _{p:\phi } a^+p
    \\
                                                              & = \bigsqcup _{p:\phi } \mathsf {purify}_A{\mathopen {}\left (a^+p\right )\mathclose {}}
    \\
                                                              & = \bigsqcup _{p:\phi } \bigsqcup _{q:\mathsf {pos}{\mathopen {}\left (a^+p\right )\mathclose {}}} a^+p
    \\
                                                              & =
    \bigsqcup _{p:\phi } a^+p
    \\
                                                              & =
    {\mathopen {}\left (\phi ,a^+\right )\mathclose {}}
  \end {aligned}
  ]]></fr:tex>


  <html:p>For the deflation, we fix <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> and observe that
  <fr:tex display="inline"><![CDATA[
  \alpha _A{\mathopen {}\left (\mathsf {L}{\iota ^+}{\mathopen {}\left (\mathsf {purify}_A a\right )\mathclose {}}\right )\mathclose {}} =
  \bigsqcup _{p:\mathsf {pos}\,a} a
  ]]></fr:tex> which is evidently below <fr:tex display="inline"><![CDATA[a]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002A/</fr:uri>
                    <fr:display-uri>jms-002A</fr:display-uri>
                    <fr:route>/jms-002A/</fr:route>
                    <fr:title text="Positively generated pointed dcpos are free">Positively generated pointed dcpos are free</fr:title>
                    <fr:taxon>Lemma</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link> <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo; then <fr:tex display="inline"><![CDATA[A]]></fr:tex> is canonically <html:em>free</html:em> on its <fr:link href="/jms-001P/" title="The subdcpo spanned by positive elements" uri="https://www.jonmsterling.com/jms-001P/" display-uri="jms-001P" type="local">subdcpo of positive elements</fr:link> <fr:tex display="inline"><![CDATA[A^+]]></fr:tex>. More specifically, the embedding-projection pair <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {L}{\iota ^+};\alpha _A\right )\mathclose {}}\dashv {A}\xrightarrow {{\mathsf {purify}_A}}{\mathsf {L}{A^+}}]]></fr:tex> <fr:link href="/jms-0020/" title="Pointed dcpos with open positivity predicates are almost free" uri="https://www.jonmsterling.com/jms-0020/" display-uri="jms-0020" type="local">given by</fr:link> the <fr:link href="/jms-0021/" title="The “purification” map" uri="https://www.jonmsterling.com/jms-0021/" display-uri="jms-0021" type="local">purification map</fr:link> is an isomorphism of dcpos.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link></fr:author><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>First, we recall that the embedding-projection pair <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {L}{\iota ^+};\alpha _A\right )\mathclose {}}\dashv \mathsf {purify}_A]]></fr:tex> <fr:link href="/jms-0020/" title="Pointed dcpos with open positivity predicates are almost free" uri="https://www.jonmsterling.com/jms-0020/" display-uri="jms-0020" type="local">exists</fr:link> because <fr:tex display="inline"><![CDATA[A]]></fr:tex> has an <fr:link href="/jms-0022/" title="Open positivity predicate" uri="https://www.jonmsterling.com/jms-0022/" display-uri="jms-0022" type="local">open positivity predicate</fr:link> by <fr:link href="/jms-0027/" title="Positively generated dcpos have open positivity predicates" uri="https://www.jonmsterling.com/jms-0027/" display-uri="jms-0027" type="local">virtue of</fr:link> its <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positive generation</fr:link>. Therefore, the statement of this lemma is well-formed.</html:p>

  <html:p>Because <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathsf {L}{\iota ^+};\alpha _A\right )\mathclose {}}\dashv \mathsf {purify}_A]]></fr:tex> is an embedding-projection pair, it remains only to check that <fr:tex display="inline"><![CDATA[\mathsf {purify}_A;\mathsf {L}{\iota ^+};\alpha _A]]></fr:tex> is an <html:em>inflation</html:em>, i.e. for all <fr:tex display="inline"><![CDATA[a:A]]></fr:tex> we must have <fr:tex display="inline"><![CDATA[a \sqsubseteq  \alpha _A{\mathopen {}\left (\mathsf {L}{\iota ^+}{\mathopen {}\left (\mathsf {purify}_Aa\right )\mathclose {}}\right )\mathclose {}}]]></fr:tex>. As the latter is equal to <fr:tex display="inline"><![CDATA[\bigsqcup _{p:\mathsf {pos}\,a}a]]></fr:tex>, the inflation condition follows from our assumption that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-002B/</fr:uri>
                    <fr:display-uri>jms-002B</fr:display-uri>
                    <fr:route>/jms-002B/</fr:route>
                    <fr:title text="Liftedness = positive generation">Liftedness = positive generation</fr:title>
                    <fr:taxon>Corollary</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>A <fr:link href="/jms-001S/" title="Pointed dcpo" uri="https://www.jonmsterling.com/jms-001S/" display-uri="jms-001S" type="local">pointed</fr:link> dcpo <fr:tex display="inline"><![CDATA[A]]></fr:tex> is lifted if and only if it is <fr:link href="/jms-0023/" title="Positively generated dcpos" uri="https://www.jonmsterling.com/jms-0023/" display-uri="jms-0023" type="local">positively generated</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/tomdejong/" title="Tom de Jong" uri="https://www.jonmsterling.com/tomdejong/" display-uri="tomdejong" type="local">Tom de Jong</fr:link></fr:author><fr:author><fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>This follows from two existing lemmas:</html:p>

  <html:ol><html:li><fr:link href="/jms-0025/" title="Lifted dcpos are positively generated" uri="https://www.jonmsterling.com/jms-0025/" display-uri="jms-0025" type="local">Lifted dcpos (free algebras) are positively generated</fr:link>.</html:li>
    <html:li><fr:link href="/jms-002A/" title="Positively generated pointed dcpos are free" uri="https://www.jonmsterling.com/jms-002A/" display-uri="jms-002A" type="local">Positively generated pointed dcpos are free</fr:link>.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
            <fr:display-uri>jms-0061</fr:display-uri>
            <fr:route>/jms-0061/</fr:route>
            <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
            <fr:taxon>Fellowship</fr:taxon>
            <fr:meta name="doi">10.3030/101065303</fr:meta>
            <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/harper-2021-topos-institute/</fr:uri>
            <fr:display-uri>harper-2021-topos-institute</fr:display-uri>
            <fr:route>/harper-2021-topos-institute/</fr:route>
            <fr:title text="Phase distinctions in type theory">Phase distinctions in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="video">https://www.youtube.com/watch?v=7DYkyB1Rm3I</fr:meta>
            <fr:meta name="venue"><fr:link href="/toposinstitute/" title="Topos Institute" uri="https://www.jonmsterling.com/toposinstitute/" display-uri="toposinstitute" type="local">Topos Institute</fr:link> Colloquium</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>(Joint work with <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> and <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>)</html:p>
            <html:p>The informal phase distinction between compile-time and run-time in programming languages is formally manifested by the distinction between kinds, which classify types, and types, which classify code. The distinction underpins standard programming methodology whereby code is first type-checked for consistency before being compiled for execution. When used effectively, types help eliminate bugs before they occur.</html:p>
            <html:p>Program modules, in even the most rudimentary form, threaten the distinction, comprising as they do both types and programs in a single unit. Matters worsen when considerating “open” modules, with free module variables standing for its imports. To maintain the separation in their presence it is necessary to limit the dependency of types, the static parts of a module, to their imported types. Such restrictions are fundamental for using dependent types to express modular structure, as originally suggested by MacQueen.</html:p>
            <html:p>To address this question <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">Moggi</fr:link> gave an “analytic” formulation of program modules in which modules are explicitly separated into their static and dynamic components using tools from category theory. Recent work by Dreyer, Rossberg, and Russo develops this approach fully in their account of ML-like module systems. In this talk we consider instead a “synthetic” formulation using a proposition to segregate the static from the dynamic, in particular to define static equivalence to manage type sharing and type dependency.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/stephaniebalzer/" title="Stephanie Balzer" uri="https://www.jonmsterling.com/stephaniebalzer/" display-uri="stephaniebalzer" type="local">Stephanie Balzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-006C/</fr:uri>
            <fr:display-uri>jms-006C</fr:display-uri>
            <fr:route>/jms-006C/</fr:route>
            <fr:title text="Session types and phase distinctions for noninterference">Session types and phase distinctions for noninterference</fr:title>
            <fr:taxon>Grant</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/afosr/" title="United States Air Force Office of Scientific Research" uri="https://www.jonmsterling.com/afosr/" display-uri="afosr" type="local">United States Air Force Office of Scientific Research</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>PIs</html:strong>:</html:td>

  <html:td><fr:link href="/stephaniebalzer/" title="Stephanie Balzer" uri="https://www.jonmsterling.com/stephaniebalzer/" display-uri="stephaniebalzer" type="local">Stephanie Balzer</fr:link> and <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Unfunded</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funding Agency</html:strong>:</html:td>

  <html:td><fr:link href="/afosr/" title="United States Air Force Office of Scientific Research" uri="https://www.jonmsterling.com/afosr/" display-uri="afosr" type="local">United States Air Force Office of Scientific Research</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Program Officer</html:strong>:</html:td>

  <html:td><fr:link href="/tristannguyen/" title="Tristan Nguyen" uri="https://www.jonmsterling.com/tristannguyen/" display-uri="tristannguyen" type="local">Dr. Tristan Nguyen</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award No.</html:strong>:</html:td>

  <html:td>FA9550-21-1-0385</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2021-2022</html:td>
</html:tr>

  
</html:table>
<html:p>The purpose of this research is to investigate the development of programming language techniques to express and enforce constraints on the flow of information in a program.</html:p><html:p>Type systems are the most widely applicable tool for enforcing such restrictions within and among programs.  The aim of the project is to investigate the development of suitable type systems for information flow security in two settings, and to understand their inter-relationship.  In each case the goal is to state and prove <html:em>non-interference properties</html:em> of programs that ensure the independence of non-sensitive outputs on sensitive inputs to a system.  Both methods draw on the method of <html:em>logical relations</html:em> to establish these properties.</html:p><html:p>The first setting is that of <html:em>session types</html:em> for communicating programs.  In their most basic form session types express the protocols for interaction among programs that interact along data-carrying communication channels.  A key characteristic of session types is that they are able to track changes of state in a computation using methods drawn from substructural logic.  The intent of the investigation is to extend session types to track information flow in a composite program using refinement types that encode security levels of data.</html:p><html:p>The second setting is that of <html:em>program modules</html:em> which govern the construction of programs from separable, reusable components.  Type systems for modularity are primarily concerned with the interfaces between components, which ensure that the effects of changes to a module implementation on other modules in a system can be tightly controlled.  The project will investigate the extension of module type systems to express information flow dependencies among components using a generalization of the <html:em>phase distinction</html:em> between static and dynamic aspects of a program to account for a richer hierarchy of security levels.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/jms-0064/</fr:uri>
            <fr:display-uri>jms-0064</fr:display-uri>
            <fr:route>/jms-0064/</fr:route>
            <fr:title text="Works of Jon Sterling">Works of <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:title>
            <fr:taxon>Bibliography</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Accepted papers">Accepted papers</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>8</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/slattery-sterling-2025/</fr:uri>
                    <fr:display-uri>slattery-sterling-2025</fr:display-uri>
                    <fr:route>/slattery-sterling-2025/</fr:route>
                    <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.48550/arXiv.2504.09520</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit construction to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey presented</fr:link> an elegant functorial analysis of this construction in terms of the <html:em>categorical nerve</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, the categorical nerve’s functorial action on the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting. Inspired by <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey’s analysis</fr:link>, we define a relative version of Hofmann–Streicher lifting in terms of the right pseudo-adjoint to the functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> given by postcomposition with a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi></mml:mrow></mml:math></html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>31</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>6</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/pugh-sterling-2025/</fr:uri>
                    <fr:display-uri>pugh-sterling-2025</fr:display-uri>
                    <fr:route>/pugh-sterling-2025/</fr:route>
                    <fr:title text="When is the partial map classifier a Sierpiński cone?">When is the partial map classifier a Sierpiński cone?</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
                    </fr:meta>
                    <fr:meta name="doi">10.48550/arXiv.2504.06789</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We study the relationship between partial map classifiers, Sierpiński cones, and axioms for synthetic higher categories and domains within <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. In particular, we show that synthetic ∞-categories are closed under partial map classifiers assuming Phoa's principle, and we isolate a new reflective subuniverse of types within which the Sierpiński cone (a lax colimit) can be computed as a partial map classifier by strengthening the Segal condition.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
                          </fr:author>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>1</fr:month>
                          <fr:day>31</fr:day>
                        </fr:date>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>4</fr:month>
                          <fr:day>9</fr:day>
                        </fr:date>
                        <fr:date>
                          <fr:year>2025</fr:year>
                          <fr:month>5</fr:month>
                          <fr:day>6</fr:day>
                        </fr:date>
                        <fr:title text="Errata">Errata</fr:title>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>The paper currently states that the alternative type theoretic computation of the scone uses the flattening lemma, but this is incorrect. In fact, we need only the fact the dependent sum functor preserves colimits (being left adjoint to base change). This will be corrected in the final version of the paper.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>26</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2024-lifting/</fr:uri>
                    <fr:display-uri>sterling-2024-lifting</fr:display-uri>
                    <fr:route>/sterling-2024-lifting/</fr:route>
                    <fr:title text="Tensorial structure of the lifting doctrine in constructive domain theory">Tensorial structure of the lifting doctrine in constructive domain theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">Proceedings of <fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link></fr:meta>
                    <fr:meta name="doi">10.48550/arXiv.2312.17023</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present a survey of the two-dimensional and tensorial structure of the <html:em>lifting doctrine</html:em> in constructive domain theory, i.e. in the theory of directed-complete partial orders (dcpos) over an arbitrary elementary topos. We establish the universal property of lifting of dcpos as the Sierpiński cone, from which we deduce (1) that lifting forms a Kock–Zöberlein doctrine, (2) that lifting algebras, pointed dcpos, and inductive partial orders form canonically equivalent locally posetal 2-categories, and (3) that the category of lifting algebras is cocomplete, with connected colimits created by the forgetful functor to dcpos. Finally we deduce the symmetric monoidal closure of the Eilenberg–Moore resolution of the lifting 2-monad by means of smash products; these are shown to classify both bilinear maps and strict maps, which we prove to coincide in the constructive setting. We provide several concrete computations of the smash product as dcpo coequalisers and lifting algebra coequalisers, and compare these with the more abstract results of Seal. Although all these results are well-known classically, the existing proofs do not apply in a constructive setting; indeed, the classical analysis of the Eilenberg–Moore category of the lifting monad relies on the fact that all lifting algebras are free, a condition that is not known to hold constructively.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Refereed papers">Refereed papers</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>13</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri>
                    <fr:display-uri>sterling-2025-grothendieck</fr:display-uri>
                    <fr:route>/sterling-2025-grothendieck/</fr:route>
                    <fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta>
                    <fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p>
                    <html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>29</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/niu-sterling-harper-2024/</fr:uri>
                    <fr:display-uri>niu-sterling-harper-2024</fr:display-uri>
                    <fr:route>/niu-sterling-harper-2024/</fr:route>
                    <fr:title text="Cost-sensitive computational adequacy of higher-order recursion in synthetic domain theory">Cost-sensitive computational adequacy of higher-order recursion in synthetic domain theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.46298/entics.14732</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/mfps-2024/" title="MFPS ’24: 40th International Conference on Mathematical Foundations of Programming Semantics" uri="https://www.jonmsterling.com/mfps-2024/" display-uri="mfps-2024" type="local"><html:em>MFPS ’24</html:em>: 40th International Conference on Mathematical Foundations of Programming Semantics</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We study a cost-aware programming language for higher-order recursion dubbed <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> in the setting of <html:em><fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link></html:em> (SDT). Our main contribution relates the denotational cost semantics of <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> to its <html:em>computational cost semantics</html:em>, a new kind of dynamic semantics for program execution that serves as a mathematically natural alternative to operational semantics in SDT. In particular we prove an internal, cost-sensitive version of Plotkin’s computational adequacy theorem, giving a precise correspondence between the denotational and computational semantics for complete programs at base type. The constructions and proofs of this paper take place in the internal dependent type theory of an SDT topos extended by a <html:em>phase distinction</html:em> in the sense of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>. By controlling the interpretation of cost structure via the phase distinction in the denotational semantics, we show that <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> programs also evince a noninterference property of cost and behavior. We verify the axioms of the type theory by means of a model construction based on relative sheaf models of SDT.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri>
                    <fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri>
                    <fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route>
                    <fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link>
                    </fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri>
                    <fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri>
                    <fr:route>/grodin-niu-sterling-harper-2024/</fr:route>
                    <fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link>
                    </fr:meta>
                    <fr:meta name="doi">10.1145/3632852</fr:meta>
                    <fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p>
                    <html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2024</fr:year>
                          <fr:month>10</fr:month>
                          <fr:day>3</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri>
                        <fr:display-uri>jms-012Q</fr:display-uri>
                        <fr:route>/jms-012Q/</fr:route>
                        <fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title>
                        <fr:taxon>Erratum</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/filipsieczkowski/" title="Filip Sieczkowski" uri="https://www.jonmsterling.com/filipsieczkowski/" display-uri="filipsieczkowski" type="local">Filip Sieczkowski</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/sergeistepanenko/" title="Sergei Stepanenko" uri="https://www.jonmsterling.com/sergeistepanenko/" display-uri="sergeistepanenko" type="local">Sergei Stepanenko</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>5</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:uri>
                    <fr:display-uri>sieczkowski-stepanenko-sterling-birkedal-2024</fr:display-uri>
                    <fr:route>/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:route>
                    <fr:title text="The essence of generalized algebraic data types">The essence of generalized algebraic data types</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link>
                    </fr:meta>
                    <fr:meta name="doi">10.1145/3632866</fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@article{sieczkowski-stepanenko-sterling-birkedal-2024,
  author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
  title = {The Essence of Generalized Algebraic Data Types},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632866},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {24},
  numpages = {29},
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>This paper considers direct encodings of generalized algebraic data types (GADTs) in a minimal suitable lambda-calculus. To this end, we develop an extension of System F<html:sub>ω</html:sub> with recursive types and internalized type equalities with injective constant type constructors. We show how GADTs and associated pattern-matching constructs can be directly expressed in the calculus, thus showing that it may be treated as a highly idealized modern functional programming language. We prove that the internalized type equalities in conjunction with injectivity rules increase the expressive power of the calculus by establishing a non-macro-expressibility result in F<html:sub>ω</html:sub>, and prove the system type-sound via a syntactic argument. Finally, we build two relational models of our calculus: a simple, unary model that illustrates a novel, two-stage interpretation technique, necessary to account for the equational constraints; and a more sophisticated, binary model that relaxes the construction to allow, for the first time, formal reasoning about data-abstraction in a calculus equipped with GADTs.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri>
                    <fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri>
                    <fr:route>/aagaard-sterling-birkedal-2023/</fr:route>
                    <fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.46298/entics.12232</fr:meta>
                    <fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>25</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-generic/</fr:uri>
                    <fr:display-uri>sterling-2023-generic</fr:display-uri>
                    <fr:route>/sterling-2023-generic/</fr:route>
                    <fr:title text="What should a generic object be?">What should a generic object be?</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@article{sterling-2023-generic,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2023},
  doi = {10.1017/S0960129523000117},
  journaltitle = {Mathematical Structures in Computer Science},
  pages = {1--22},
  title = {What should a generic object be?},
}]]></fr:meta>
                    <fr:meta name="doi">10.1017/S0960129523000117</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> has proposed definitions for (weak, strong, split) generic objects for a fibered category; building on his definition of (split) generic objects, <fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> develops a menagerie of important fibrational structures with applications to categorical logic and computer science, including higher order fibrations, polymorphic fibrations, 𝜆2-fibrations, triposes, and others. We observe that a split generic object need not in particular be a generic object under the given definitions, and that the definitions of polymorphic fibrations, triposes, etc. are strict enough to rule out some fundamental examples: for instance, the fibered preorder induced by a partial combinatory algebra in realizability is not a tripos in this sense. We propose a new alignment of terminology that emphasizes the forms of generic object appearing most commonly in nature, i.e. in the study of internal categories, triposes, and the denotational semantics of polymorphism. In addition, we propose a new class of acyclic generic objects inspired by recent developments in higher category theory and the semantics of homotopy type theory, generalizing the realignment property of universes to the setting of an arbitrary fibration.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/danielepalombi/" title="Daniele Palombi" uri="https://www.jonmsterling.com/danielepalombi/" display-uri="danielepalombi" type="local">Daniele Palombi</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/palombi-sterling-2023/</fr:uri>
                    <fr:display-uri>palombi-sterling-2023</fr:display-uri>
                    <fr:route>/palombi-sterling-2023/</fr:route>
                    <fr:title text="Classifying topoi in synthetic guarded domain theory: the universal property of multi-clock guarded recursion">Classifying topoi in synthetic guarded domain theory: the universal property of multi-clock guarded recursion</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@inproceedings{palombi-sterling-2023,
  author = {Palombi, Daniele and Sterling, Jonathan},
  booktitle = {Proceedings 38th Conference on Mathematical Foundations of Programming Semantics, {MFPS} 2022},
  year = {2023},
  month = feb,
  title = {Classifying topoi in synthetic guarded domain theory},
  doi = {10.46298/entics.10323},
}]]></fr:meta>
                    <fr:meta name="doi">10.46298/entics.10323</fr:meta>
                    <fr:meta name="venue">38th International Conference on Mathematical Foundations of Programming Semantics</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Several different topoi have played an important role in the development and applications of <html:em><fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link></html:em> (SGDT), a new kind of synthetic domain theory that abstracts the concept of <html:em>guarded recursion</html:em> frequently employed in the semantics of programming languages. In order to unify the accounts of guarded recursion and coinduction, <fr:link href="/atkey-mcbride-2013/" title="Productive coprogramming with guarded recursion" uri="https://www.jonmsterling.com/atkey-mcbride-2013/" display-uri="atkey-mcbride-2013" type="local">several</fr:link> <fr:link href="/bizjak-mogelberg-2020/" title="Denotational semantics for guarded dependent type theory" uri="https://www.jonmsterling.com/bizjak-mogelberg-2020/" display-uri="bizjak-mogelberg-2020" type="local">authors</fr:link> have enriched SGDT with multiple “clocks” parameterizing different time-streams, leading to more complex and difficult to understand topos models. Until now these topoi have been understood very concretely <html:em>qua</html:em> categories of presheaves, and the logico-geometrical question of what theories these topoi classify has remained open. We show that several important topos models of SGDT classify very simple geometric theories, and that the passage to various forms of multi-clock guarded recursion can be rephrased more compositionally in terms of the lower bagtopos construction of <fr:link href="/vickers-1992/" title="Geometric theories and databases" uri="https://www.jonmsterling.com/vickers-1992/" display-uri="vickers-1992" type="local">Vickers</fr:link> and variations thereon due to <fr:link href="/johnstone-1994/" title="Variations on the bagdomain theme" uri="https://www.jonmsterling.com/johnstone-1994/" display-uri="johnstone-1994" type="local">Johnstone</fr:link>. We contribute to the consolidation of SGDT by isolating the universal property of multi-clock guarded recursion as a modular construction that applies to any topos model of single-clock guarded recursion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2022/</fr:uri>
                    <fr:display-uri>sterling-angiuli-gratzer-2022</fr:display-uri>
                    <fr:route>/sterling-angiuli-gratzer-2022/</fr:route>
                    <fr:title text="A cubical language for Bishop sets">A cubical language for Bishop sets</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@article{sterling-angiuli-gratzer-2022,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  year = {2022},
  month = mar,
  doi = {10.46298/lmcs-18(1:43)2022},
  eprint = {2003.01491},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  issue = {1},
  journal = {Logical Methods in Computer Science},
  title = {{A Cubical Language for Bishop Sets}},
  volume = {18},
}]]></fr:meta>
                    <fr:meta name="doi">10.46298/lmcs-18(1:43)2022</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/lmcs/" title="Logical Methods in Computer Science" uri="https://www.jonmsterling.com/lmcs/" display-uri="lmcs" type="local">Logical Methods in Computer Science</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present XTT, a version of Cartesian cubical type theory specialized for Bishop sets à la <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link>, in which every type enjoys a definitional version of the uniqueness of identity proofs. Using cubical notions, XTT reconstructs many of the ideas underlying Observational Type Theory, a version of intensional type theory that supports function extensionality. We prove the canonicity property of XTT (that every closed boolean is definitionally equal to a constant) by Artin gluing.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/</fr:uri>
                    <fr:display-uri>niu-sterling-grodin-harper-2022</fr:display-uri>
                    <fr:route>/niu-sterling-grodin-harper-2022/</fr:route>
                    <fr:title text="A cost-aware logical framework">A cost-aware logical framework</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 6, Issue POPL</fr:meta>
                    <fr:meta name="doi">10.1145/3498670</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants.</html:p>
                    <html:p>We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist’s method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid’s algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-harper-2022/</fr:uri>
                    <fr:display-uri>sterling-harper-2022</fr:display-uri>
                    <fr:route>/sterling-harper-2022/</fr:route>
                    <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.5</fr:meta>
                    <fr:meta name="venue">7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We propose a new sheaf semantics for secure information flow over a space of abstract behaviors, based on synthetic domain theory: security classes are open/closed partitions, types are sheaves, and redaction of sensitive information corresponds to restricting a sheaf to a closed subspace. Our security-aware computational model satisfies termination-insensitive noninterference automatically, and therefore constitutes an intrinsic alternative to state of the art extrinsic/relational models of noninterference. Our semantics is the latest application of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s recent re-interpretation of phase distinctions and noninterference in programming languages in terms of Artin gluing and topos-theoretic open/closed modalities. Prior applications include <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">parametricity for ML modules</fr:link>, the proof of normalization for cubical type theory by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link>, and the cost-aware logical framework of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu et al</fr:link>. In this paper we employ the phase distinction perspective twice: first to reconstruct the syntax and semantics of secure information flow as a lattice of phase distinctions between “higher” and “lower” security, and second to verify the computational adequacy of our sheaf semantics with respect to a version of Abadi et al.’s dependency core calculus to which we have added a construct for declassifying termination channels.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-005Y/</fr:uri>
                        <fr:display-uri>jms-005Y</fr:display-uri>
                        <fr:route>/jms-005Y/</fr:route>
                        <fr:title text="Minor mistakes in sheaf semantics of noninterference">Minor mistakes in <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                        <fr:taxon>Erratum</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>In the published version of this paper, there were a few mistakes that have been corrected in the local copy hosted here.</html:p>
                        <html:ol><html:li>In the <html:em>Critique of relational semantics for information flow</html:em>, our discussion of the <html:em>Failure of monotonicity</html:em> stated incorrectly that algebras for the sealing monad at a higher security level could not be transformed into algebras for the sealing monad at a lower security level in the semantics of Abadi et al. This is not true, as pointed out to us privately by Carlos Tomé Cortiñas. What we meant to say was that it is not the case that a type whose component at a high security level is trivial shall always remain trivial at a lower security level.</html:li>
  <html:li>The original version of the extended edition of this paper, we claimed that the constructive existence of tensor products on pointed dcpos was obvious; in fact, tensor products do exist, but their construction involves a reflexive coequalizer of pointed dcpos.</html:li></html:ol>
                      </fr:mainmatter>
                    </fr:tree>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>7</fr:month>
                          <fr:day>17</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                        <fr:display-uri>jms-005Z</fr:display-uri>
                        <fr:route>/jms-005Z/</fr:route>
                        <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                        <fr:taxon>Erratum</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-harper-2021/</fr:uri>
                    <fr:display-uri>sterling-harper-2021</fr:display-uri>
                    <fr:route>/sterling-harper-2021/</fr:route>
                    <fr:title text="Logical relations as types: proof-relevant parametricity for program modules">Logical relations as types: proof-relevant parametricity for program modules</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue"><fr:link href="/jacm/" title="Journal of the ACM" uri="https://www.jonmsterling.com/jacm/" display-uri="jacm" type="local">Journal of the ACM</fr:link>, Volume 68, Issue 6</fr:meta>
                    <fr:meta name="doi">10.1145/3474834</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the <html:em>phase distinction</html:em>, <html:em>computational effects</html:em>, and <html:em>type abstraction</html:em>. We contribute a fresh “synthetic” take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a <html:em>lax modality</html:em> that encapsulates computational effects, placing <html:em>projectibility</html:em> of module expressions on a type-theoretic basis.</html:p>
                    <html:p>Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a <html:em>parametricity structure</html:em>. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-<html:em>relevant</html:em> families, where there may be non-trivial evidence witnessing the relatedness of two programs—simplifying the metatheory of strong sums over the collection of types, for although there can be no “relation classifying relations,” one easily accommodates a “family classifying small families.”</html:p>
                    <html:p>Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan <html:em>logical relations as types</html:em>, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic <html:em>Artin gluing</html:em> construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.</html:p>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2021</fr:year>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-0060/</fr:uri>
                        <fr:display-uri>jms-0060</fr:display-uri>
                        <fr:route>/jms-0060/</fr:route>
                        <fr:title text="Minor mistakes in logical relations as types">Minor mistakes in <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">logical relations as types</fr:link></fr:title>
                        <fr:taxon>Erratum</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>After going to press, we have fixed the following mistakes:</html:p>
                        <html:ol><html:li>In the definition of a logos, we mistakenly said that "colimits commute with finite limits" but we meant to say that they are preserved by pullback. We thank <fr:link href="/sarahzrf/" title="Sarah Z. Rovner-Frydman" uri="https://www.jonmsterling.com/sarahzrf/" display-uri="sarahzrf" type="local">Sarah Z. Rovner-Frydman</fr:link> for noticing this mistake.</html:li>
  <html:li>In Remark 5.15, we used the notation for the closed immersion prior to introducing it.</html:li>
  <html:li>We have fixed a few broken links in the bibliography.</html:li></html:ol>
                        <html:p>The local copy hosted here has the corrections implemented</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>7</fr:month>
                      <fr:day>7</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021/</fr:uri>
                    <fr:display-uri>sterling-angiuli-2021</fr:display-uri>
                    <fr:route>/sterling-angiuli-2021/</fr:route>
                    <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)</fr:meta>
                    <fr:meta name="doi">10.1109/LICS52264.2021.9470719</fr:meta>
                    <fr:meta name="external">https://arxiv.org/abs/2101.11479</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. Our normalization result is reduction-free, in the sense of yielding a bijection between equivalence classes of terms in context and a tractable language of <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex>/<fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-normal forms. As corollaries we obtain both decidability of judgmental equality and the injectivity of type constructors.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-bhfs/</fr:uri>
                    <fr:display-uri>sterling-2021-bhfs</fr:display-uri>
                    <fr:route>/sterling-2021-bhfs/</fr:route>
                    <fr:title text="Higher order functions and Brouwer’s Thesis">Higher order functions and Brouwer’s Thesis</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@article{sterling-2021-bhfs,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2021},
  doi = {10.1017/S0956796821000095},
  eprint = {1608.03814},
  eprintclass = {math.LO},
  eprinttype = {arXiv},
  journaltitle = {Journal of Functional Programming},
  note = {\emph{Bob Harper Festschrift Collection}},
  pages = {e11},
  title = {Higher order functions and Brouwer's thesis},
  volume = {31},
}]]></fr:meta>
                    <fr:meta name="artifact">https://www.jonmsterling.com/agda-effectful-forcing/index.html</fr:meta>
                    <fr:meta name="doi">10.1017/S0956796821000095</fr:meta>
                    <fr:meta name="venue"><fr:link href="/jfp/" title="Journal of Functional Programming" uri="https://www.jonmsterling.com/jfp/" display-uri="jfp" type="local">Journal of Functional Programming</fr:link>, <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Bob Harper</fr:link> Festschrift Collection</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Extending <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>’s effectful forcing technique, we give a new proof of a well-known result: Brouwer’s monotone bar theorem holds for any bar that can be realized by a functional of type <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathbb {N}\to \mathbb {N}\right )\mathclose {}}\to \mathbb {N}]]></fr:tex> in Gödel’s System T. Effectful forcing is an elementary alternative to standard sheaf-theoretic forcing arguments, using ideas from programming languages, including computational effects, monads, the algebra interpretation of call-by-name λ-calculus, and logical relations. Our argument proceeds by interpreting System T programs as well-founded dialogue trees whose nodes branch on a query to an oracle of type <fr:tex display="inline"><![CDATA[\mathbb {N}\to \mathbb {N}]]></fr:tex>, lifted to higher type along a call-by-name translation. To connect this interpretation to the bar theorem, we then show that Brouwer’s famous "mental constructions" of barhood constitute an invariant form of these dialogue trees in which queries to the oracle are made maximally and in order.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2019</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019/</fr:uri>
                    <fr:display-uri>sterling-angiuli-gratzer-2019</fr:display-uri>
                    <fr:route>/sterling-angiuli-gratzer-2019/</fr:route>
                    <fr:title text="Cubical syntax for reflection-free extensional equality">Cubical syntax for reflection-free extensional equality</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-angiuli-gratzer-2019,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  editor = {Geuvers, Herman},
  location = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/10538},
  booktitle = {Proceedings of the 4th International Conference on Formal Structures for Computation and Deduction (FSCD 2019)},
  date = {2019},
  doi = {10.4230/LIPIcs.FSCD.2019.31},
  eprint = {1904.08562},
  eprinttype = {arXiv},
  isbn = {978-3-95977-107-8},
  issn = {1868-8969},
  pages = {31:1--31:25},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {Cubical Syntax for Reflection-Free Extensional Equality},
  volume = {131},
}]]></fr:meta>
                    <fr:meta name="slides">/bafkrmicj5w5dosexdar6vzylw5hykvpeqrydvy4cp6llywqf7auioli4fu.pdf</fr:meta>
                    <fr:meta name="doi">10.4230/LIPIcs.FSCD.2019.31</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/fscd-2019/" title="FSCD ’19: International Conference on Formal Structures for Computation and Deduction" uri="https://www.jonmsterling.com/fscd-2019/" display-uri="fscd-2019" type="local"><html:em>FSCD ’19</html:em>: International Conference on Formal Structures for Computation and Deduction</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory [Altenkirch et al., 2007] which extends Martin-Löf's intensional type theory with a dependent equality type that enjoys function extensionality and a judgmental version of the unicity of identity proofs principle (UIP): any two elements of the same equality type are judgmentally equal. Moreover, we conjecture that the typing relation can be decided in a practical way. In this paper, we establish an algebraic canonicity theorem using a novel extension of the logical families or categorical gluing argument inspired by <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> and <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link>: every closed element of boolean type is derivably equal to either true or false.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2019</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/gratzer-sterling-birkedal-2019/</fr:uri>
                    <fr:display-uri>gratzer-sterling-birkedal-2019</fr:display-uri>
                    <fr:route>/gratzer-sterling-birkedal-2019/</fr:route>
                    <fr:title text="Implementing a modal dependent type theory">Implementing a modal dependent type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@article{gratzer-sterling-birkedal-2019,
  author = {Gratzer, Daniel and Sterling, Jonathan and Birkedal, Lars},
  location = {New York, NY, USA},
  publisher = {ACM},
  date = {2019-07},
  doi = {10.1145/3341711},
  issn = {2475-1421},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  keywords = {Modal types,dependent types,normalization by evaluation,type-checking},
  number = {ICFP},
  pages = {107:1--107:29},
  title = {Implementing a Modal Dependent Type Theory},
  volume = {3},
}]]></fr:meta>
                    <fr:meta name="doi">10.1145/3341711</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/icfp-2019/" title="ICFP ’19: The 24th ACM SIGPLAN International Conference on Functional Programming" uri="https://www.jonmsterling.com/icfp-2019/" display-uri="icfp-2019" type="local"><html:em>ICFP ’19</html:em>: The 24th ACM SIGPLAN International Conference on Functional Programming</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Modalities are everywhere in programming and mathematics! Despite this, however, there are still significant technical challenges in formulating a core dependent type theory with modalities. We present a dependent type theory MLTT🔒 supporting the connectives of standard Martin-Löf Type Theory as well as an S4-style necessity operator. MLTT🔒 supports a smooth interaction between modal and dependent types and provides a common basis for the use of modalities in programming and in synthetic mathematics. We design and prove the soundness and completeness of a type checking algorithm for MLTT🔒, using a novel extension of normalization by evaluation. We have also implemented our algorithm in a prototype proof assistant for MLTT🔒, demonstrating the ease of applying our techniques.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2018</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-harper-2018/</fr:uri>
                    <fr:display-uri>sterling-harper-2018</fr:display-uri>
                    <fr:route>/sterling-harper-2018/</fr:route>
                    <fr:title text="Guarded computational type theory">Guarded computational type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-harper-2018,
 author = {Sterling, Jonathan and Harper, Robert},
 title = {Guarded Computational Type Theory},
 booktitle = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
 series = {LICS '18},
 year = {2018},
 isbn = {978-1-4503-5583-4},
 location = {Oxford, United Kingdom},
 pages = {879--888},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3209108.3209153},
 doi = {10.1145/3209108.3209153},
 acmid = {3209153},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {clocks, dependent types, guarded recursion, operational semantics, type theory},
}]]></fr:meta>
                    <fr:meta name="slides">/bafkrmie3t5ai2zxuejiwtnjln2d2aixnjqhqqifmu63oz4leeikydgbghu.pdf</fr:meta>
                    <fr:meta name="doi">10.1145/3209108.3209153</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/lics-2018/" title="LICS ’18: 33rd Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2018/" display-uri="lics-2018" type="local"><html:em>LICS ’18</html:em>: 33rd Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/nakano-2000/" title="A modality for recursion" uri="https://www.jonmsterling.com/nakano-2000/" display-uri="nakano-2000" type="local">Nakano</fr:link>’s later modality can be used to specify and define recursive functions which are causal or synchronous; in concert with a notion of clock variable, it is possible to also capture the broader class of productive (co)programs. Until now, it has been difficult to combine these constructs with dependent types in a way that preserves the operational meaning of type theory and admits a hierarchy of universes. We present an operational account of guarded dependent type theory with clocks called Guarded Computational Type Theory, featuring a novel clock intersection connective that enjoys the clock irrelevance principle, as well as a predicative hierarchy of universes which does not require any indexing in clock contexts. Guarded Computational Type Theory is simultaneously a programming language with a rich specification logic, as well as a computational metalanguage that can be used to develop semantics of other languages and logics.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>Rebecca Valentine</fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2016</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/valentine-sterling-2016/</fr:uri>
                    <fr:display-uri>valentine-sterling-2016</fr:display-uri>
                    <fr:route>/valentine-sterling-2016/</fr:route>
                    <fr:title text="Dependent types for pragmatics">Dependent types for pragmatics</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@inbook{valentine-sterling-2016,
  author={Valentine, Rebecca and Sterling, Jonathan},
  editor={Redmond, Juan and Pombo Martins, Olga and Nepomuceno Fern{\'a}ndez, {\'A}ngel},
  title={Dependent Types for Pragmatics},
  booktitle={Epistemology, Knowledge and the Impact of Interaction},
  year={2016},
  publisher={Springer International Publishing},
  address={Cham},
  pages={123--139},
  isbn={978-3-319-26506-3},
  doi={10.1007/978-3-319-26506-3_4},
}]]></fr:meta>
                    <fr:meta name="doi">10.1007/978-3-319-26506-3_4</fr:meta>
                    <fr:meta name="venue">In: Redmond J., Pombo Martins O., Nepomuceno Fernández Á. (eds) Epistemology, Knowledge and the Impact of Interaction. Logic, Epistemology, and the Unity of Science, vol 38. Springer, Cham.</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In this paper, we present an extension to Martin-Löf’s Intuitionistic Type Theory which gives natural solutions to problems in pragmatics, such as pronominal reference and presupposition. Our approach also gives a simple account of donkey anaphora without resorting to exotic scope extension of the sort used in Discourse Representation Theory and Dynamic Semantics, thanks to the proof-relevant nature of type theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Manuscripts">Manuscripts</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/lingyuanye/" title="Lingyuan Ye" uri="https://www.jonmsterling.com/lingyuanye/" display-uri="lingyuanye" type="local">Lingyuan Ye</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-ye-2025/</fr:uri>
                    <fr:display-uri>sterling-ye-2025</fr:display-uri>
                    <fr:route>/sterling-ye-2025/</fr:route>
                    <fr:title text="Domains and Classifying Topoi">Domains and Classifying Topoi</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.48550/arXiv.2505.13096</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We explore a new connection between synthetic domain theory and Grothendieck topoi related to the distributive lattice classifier. In particular, all the axioms of synthetic domain theory (including the inductive fixed point object and the chain completeness of the dominance) emanate from a countable version of the synthetic quasi-coherence principle that has emerged as a central feature in the unification of <fr:link href="/cherubini-coquand-hutzler-2024/" title="A foundation for synthetic algebraic geometry" uri="https://www.jonmsterling.com/cherubini-coquand-hutzler-2024/" display-uri="cherubini-coquand-hutzler-2024" type="local">synthetic algebraic geometry</fr:link>, <fr:link href="/cherubini-coquand-geerligs-moeneclaey-2024/" title="A Foundation for Synthetic Stone Duality" uri="https://www.jonmsterling.com/cherubini-coquand-geerligs-moeneclaey-2024/" display-uri="cherubini-coquand-geerligs-moeneclaey-2024" type="local">synthetic Stone duality</fr:link>, and <fr:link href="/gratzer-weinberger-buchholtz-2025/" title="The Yoneda embedding in simplicial type theory" uri="https://www.jonmsterling.com/gratzer-weinberger-buchholtz-2025/" display-uri="gratzer-weinberger-buchholtz-2025" type="local">synthetic category theory</fr:link>. The duality between quasi-coherent algebras and affine spaces in a topos with a distributive lattice object provides a new set of techniques for reasoning synthetically about domain-like structures, and reveals a broad class of (higher) sheaf models for synthetic domain theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>24</fr:day>
                    </fr:date>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>16</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2024-universes/</fr:uri>
                    <fr:display-uri>gratzer-shulman-sterling-2024-universes</fr:display-uri>
                    <fr:route>/gratzer-shulman-sterling-2024-universes/</fr:route>
                    <fr:title text="Strict universes for Grothendieck topoi">Strict universes for Grothendieck topoi</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2024-universes,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2024},
  month = may,
  doi = {10.48550/arXiv.2202.12012},
  eprint = {2202.12012},
  eprintclass = {math.CT},
  eprinttype = {arXiv},
  note = {Unpublished manuscript},
  title = {Strict universes for Grothendieck topoi},
}]]></fr:meta>
                    <fr:meta name="doi">10.48550/arXiv.2202.12012</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> famously showed how to lift Grothendieck universes into presheaf topoi, and <fr:link href="/streicher-2005/" title="Universes in toposes" uri="https://www.jonmsterling.com/streicher-2005/" display-uri="streicher-2005" type="local">Streicher</fr:link> has extended their result to the case of sheaf topoi by
sheafification. In parallel, <fr:link href="/van-den-berg-moerdijk-2012/" title="Aspects of predicative algebraic set theory III: sheaves" uri="https://www.jonmsterling.com/van-den-berg-moerdijk-2012/" display-uri="van-den-berg-moerdijk-2012" type="local">van den Berg and Moerdijk</fr:link> have shown in the context of algebraic set theory that similar constructions continue to apply even in weaker metatheories. Unfortunately, sheafification seems not to preserve an important <html:em>realignment</html:em> property enjoyed by presheaf universes that plays a critical role in models of univalent type theory as well as <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link>. When <html:em>multiple</html:em> universes are present, realignment also implies a coherent interpretation of connectives across all universes that justifies the cumulativity laws present in popular formulations of Martin-Löf type theory.</html:p>
                    <html:p>We observe that a slight adjustment to an argument of <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link> constructs a cumulative universe hierarchy satisfying the realignment property at every level in any Grothendieck topos. Hence one has direct-style interpretations of Martin-Löf type theory with cumulative universes into all Grothendieck topoi. A further implication is to extend the reach of recent synthetic methods in the semantics of cubical type theory and the syntactic metatheory of type theory and programming languages to all Grothendieck topoi.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>3</fr:month>
                      <fr:day>30</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2024-lenses/</fr:uri>
                    <fr:display-uri>sterling-2024-lenses</fr:display-uri>
                    <fr:route>/sterling-2024-lenses/</fr:route>
                    <fr:title text="Reflexive graph lenses in univalent foundations">Reflexive graph lenses in univalent foundations</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.48550/arXiv.2404.07854</fr:meta>
                    <fr:meta name="external">https://arxiv.org/abs/2404.07854</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/permartinl%C3%B6f/" title="Per Martin-Löf" uri="https://www.jonmsterling.com/permartinlöf/" display-uri="permartinlöf" type="local">Martin-Löf</fr:link>’s identity types provide a generic (albeit opaque) notion of identification or “equality” between any two elements of the same type, embodied in a canonical reflexive graph structure <fr:tex display="inline"><![CDATA[(=_A, \mathbf {refl})]]></fr:tex> on any type <fr:tex display="inline"><![CDATA[A]]></fr:tex>. The miracle of <fr:link href="/vladimirvoevodsky/" title="Vladimir Voevodsky" uri="https://www.jonmsterling.com/vladimirvoevodsky/" display-uri="vladimirvoevodsky" type="local">Voevodsky</fr:link>’s <html:em>univalence principle</html:em> is that it ensures, for essentially any naturally occuring structure in mathematics, that this the resultant notion of identification is equivalent to the type of <html:em>isomorphisms</html:em> in the category of such structures. Characterisations of this kind are not automatic and must be established one-by-one; to this end, several authors have employed <html:em>reflexive graphs</html:em> and <html:em>displayed reflexive graphs</html:em> to organise the characterisation of identity types. We contribute <html:strong>reflexive graph lenses</html:strong>, a new family of intermediate abstractions lying between families of reflexive graphs and displayed reflexive graphs that simplifies the characterisation of identity types for complex structures. Every reflexive graph lens gives rise to a (more complicated) displayed reflexive graph, and our experience suggests that many naturally occuring displayed reflexive graphs arise in this way. Evidence for the utility of reflexive graph lenses is given by means of several case studies, including the theory of reflexive graphs itself as well as that of polynomial type operators. Finally, we exhibit an equivalance between the type of reflexive graph fibrations and the type of <html:em>univalent</html:em> reflexive graph lenses.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>10</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri>
                    <fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri>
                    <fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route>
                    <fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>6</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri>
                    <fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri>
                    <fr:route>/sterling-gratzer-birkedal-2022/</fr:route>
                    <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-existentials/</fr:uri>
                    <fr:display-uri>sterling-2022-existentials</fr:display-uri>
                    <fr:route>/sterling-2022-existentials/</fr:route>
                    <fr:title text="Reflections on existential types">Reflections on existential types</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@article{sterling-2022-existentials,
  doi = {10.48550/ARXIV.2210.00758},
  author = {Sterling, Jonathan},
  title = {Reflections on existential types},
  publisher = {arXiv},
  year = {2022},
  note = {Unpublished manuscript},
}]]></fr:meta>
                    <fr:meta name="doi">10.48550/arXiv.2210.00758</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Existential types are reconstructed in terms of <html:em>small reflective subuniverses</html:em> and dependent sums. The folklore decomposition detailed here gives rise to a particularly simple account of first class modules as a mode of use of traditional second class modules in connection with the modal operator induced by a reflective subuniverse, leading to a semantic justification for the rules of first-class modules in languages like OCaml and MoscowML.   Additionally, we expose several constructions that give rise to semantic models of ML-style programming languages with both first-class modules and realistic computational effects, culminating in a model that accommodates higher-order first class recursive modules <html:em>and</html:em> higher-order store.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>6</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri>
                    <fr:display-uri>sterling-2022-naive</fr:display-uri>
                    <fr:route>/sterling-2022-naive/</fr:route>
                    <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta>
                    <fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Dissertation">Dissertation</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>9</fr:month>
                      <fr:day>13</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-thesis/</fr:uri>
                    <fr:display-uri>sterling-2021-thesis</fr:display-uri>
                    <fr:route>/sterling-2021-thesis/</fr:route>
                    <fr:title text="First steps in synthetic Tait computability: the objective metatheory of cubical type theory">First steps in synthetic Tait computability: the objective metatheory of cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">Doctoral dissertation, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta>
                    <fr:meta name="bibtex"><![CDATA[@phdthesis{sterling-2021-thesis,
  author = {Sterling, Jonathan},
  school = {Carnegie Mellon University},
  year = {2021},
  doi = {10.5281/zenodo.6990769},
  note = {Version 1.1, revised May 2022},
  number = {CMU-CS-21-142},
  title = {First Steps in Synthetic {Tait} Computability: The Objective Metatheory of Cubical Type Theory},
}]]></fr:meta>
                    <fr:meta name="doi">10.5281/zenodo.6990769</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The implementation and semantics of dependent type theories can be studied in a syntax-independent way: the objective metatheory of dependent type theories exploits the universal properties of their syntactic categories to endow them with computational content, mathematical meaning, and practical implementation (normalization, type checking, elaboration). The semantic methods of the objective metatheory inform the design and implementation of correct-by-construction elaboration algorithms, promising a principled interface between real proof assistants and ideal mathematics.</html:p>
                    <html:p>In this dissertation, I add synthetic Tait computability to the arsenal of the objective metatheorist. Synthetic Tait computability is a mathematical machine to reduce difficult problems of type theory and programming languages to trivial theorems of topos theory. First employed by <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link> to reconstruct the theory of program modules and their phase separated parametricity, synthetic Tait computability is deployed here to resolve the last major open question in the syntactic metatheory of cubical type theory: normalization of open terms.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Presentations">Presentations</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>27</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-catmi/</fr:uri>
                    <fr:display-uri>sterling-2023-catmi</fr:display-uri>
                    <fr:route>/sterling-2023-catmi/</fr:route>
                    <fr:title text="Naïve denotational semantics: synthetic domains in the 21st century">Naïve denotational semantics: synthetic domains in the 21st century</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="external">http://www.catmi.no/</fr:meta>
                    <fr:meta name="slides">/bafkrmielsxg42lagb5fu2zymlfcvlvyqpvclrzc3kre6dszhwpgvdxuum4.pdf</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>It is easy to teach a student how to give a naïve denotational semantics to a language like System T, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p>
                    <html:p>The dream of the 1990s was to find a category that behaves like <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this <html:strong>synthetic domain theory</html:strong> is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including simple denotational semantics for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p>
                    <html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri>
                    <fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri>
                    <fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route>
                    <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta>
                    <fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>14</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-pujet-workshop/</fr:uri>
                    <fr:display-uri>sterling-2022-pujet-workshop</fr:display-uri>
                    <fr:route>/sterling-2022-pujet-workshop/</fr:route>
                    <fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiajrzaq3g6iptivu37xqg6kfcxs32gvwnwqzrrzpp5g5cnvyhsfgy.pdf</fr:meta>
                    <fr:meta name="venue">Workshop on Dependent Type Theory (to celebrate the Defense of <fr:link href="/lo%C3%AFcpujet/" title="Loïc Pujet" uri="https://www.jonmsterling.com/loïcpujet/" display-uri="loïcpujet" type="local">Loïc Pujet</fr:link>)</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We present a novel mechanism for <fr:link href="/gratzer-sterling-angiuli-coquand-birkedal-2022/" title="Controlling unfolding in type theory" uri="https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/" display-uri="gratzer-sterling-angiuli-coquand-birkedal-2022" type="local">controlling the unfolding of definitions in dependent type theory</fr:link>. Traditionally, proof assistants let users specify whether each definition can or cannot be unfolded in the remainder of a development; unfolding definitions is often necessary in order to reason about them, but an excess of unfolding can result in brittle proofs and intractably large proof goals. In our system, definitions are by default not unfolded, but users can selectively unfold them in a local manner. We justify our mechanism by means of elaboration to a core type theory with <html:em>extension types</html:em>, a connective first introduced in the context of homotopy type theory.  We prove a normalization theorem for our core calculus and have implemented our system in the cooltt proof assistant, providing both theoretical and practical evidence for it.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>30</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-muri/</fr:uri>
                    <fr:display-uri>sterling-2022-muri</fr:display-uri>
                    <fr:route>/sterling-2022-muri/</fr:route>
                    <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@misc{sterling-harper-2022-muri,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {\route-asset{assets/slides/sterling:2022:muri.pdf}},
  year = {2022},
  month = jun,
  note = {Talk given at the 2022 MURI Team Meeting},
  title = {Sheaf semantics of termination-insensitive noninterference},
}]]></fr:meta>
                    <fr:meta name="slides">/bafkrmidn65xp7ewox6ka5uijltbkg5ikkuuuj5zid7viz5dbu35fx44qoq.pdf</fr:meta>
                    <fr:meta name="venue">MURI Team Meeting 2022</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <fr:tree show-metadata="false">
                      <fr:frontmatter>
                        <fr:authors>
                          <fr:author>
                            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                          </fr:author>
                        </fr:authors>
                        <fr:date>
                          <fr:year>2023</fr:year>
                          <fr:month>7</fr:month>
                          <fr:day>17</fr:day>
                        </fr:date>
                        <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                        <fr:display-uri>jms-005Z</fr:display-uri>
                        <fr:route>/jms-005Z/</fr:route>
                        <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                        <fr:taxon>Erratum</fr:taxon>
                      </fr:frontmatter>
                      <fr:mainmatter>
                        <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
                      </fr:mainmatter>
                    </fr:tree>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>5</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-wg6/</fr:uri>
                    <fr:display-uri>sterling-2022-wg6</fr:display-uri>
                    <fr:route>/sterling-2022-wg6/</fr:route>
                    <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@misc{sterling-2022-wg6,
  author = {Sterling, Jonathan},
  year = {2022},
  month = may,
  note = {WG6 kick-off meeting: Syntax and Semantics of Type Theories (Invited Talk)},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta>
                    <fr:meta name="venue">WG6 kick-off meeting: Syntax and Semantics of Type Theories</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>22</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-wits/</fr:uri>
                    <fr:display-uri>sterling-2022-wits</fr:display-uri>
                    <fr:route>/sterling-2022-wits/</fr:route>
                    <fr:title text="Make three to throw away: frontiers in homotopical proof assistants">Make three to throw away: frontiers in homotopical proof assistants</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmifpq7uvabz7ktijuq24pfirediv7taikklozbeuqknhw3evm25pje.pdf</fr:meta>
                    <fr:meta name="video">https://www.youtube.com/watch?v=lqBFq7aRReY</fr:meta>
                    <fr:meta name="venue">Workshop on the Implementation of Type Systems (keynote)</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>For six years, I have served as the founder and technical leader of the RedPRL Development Team which has produced three interactive proof assistants for variants of cubical type theory: RedPRL, redtt, and cooltt. I will share several lessons that we have learned about the design and implementation of homotopical proof assistants along this journey. This talk discusses joint work with <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>, <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>, <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Favonia</fr:link>, and Reed Mullanix.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-muri/</fr:uri>
                    <fr:display-uri>sterling-2021-muri</fr:display-uri>
                    <fr:route>/sterling-2021-muri/</fr:route>
                    <fr:title text="Normalization for (Cartesian) cubical type theory">Normalization for (Cartesian) cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmigc53m5m72p66jxbd7oxkvrl7irbrfxdjsatj2igngbm44a6g5cnq.pdf</fr:meta>
                    <fr:meta name="venue">MURI Team Meeting 2021</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-harper-2021-mlw/</fr:uri>
                    <fr:display-uri>sterling-harper-2021-mlw</fr:display-uri>
                    <fr:route>/sterling-harper-2021-mlw/</fr:route>
                    <fr:title text="A metalanguage for multi-phase modularity">A metalanguage for multi-phase modularity</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-harper-2021-mlw,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {https://icfp21.sigplan.org/details/mlfamilyworkshop-2021-papers/5/A-metalanguage-for-multi-phase-modularity},
  year = {2021},
  month = aug,
  note = {ML 2021 abstract and talk},
  title = {A metalanguage for multi-phase modularity},
}]]></fr:meta>
                    <fr:meta name="slides">/bafkrmigp2ekztc4xgmcxoxv7mxawb33zro6apew2m54hmctdosmregbpha.pdf</fr:meta>
                    <fr:meta name="video">https://www.youtube.com/watch?v=5kWS-umBA7k</fr:meta>
                    <fr:meta name="venue">ML Family Workshop</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Type abstraction, the phase distinction, and computational effects all play an important role in the design and implementation of ML-style module systems. We propose a simple type theoretic metalanguage <html:strong>φML</html:strong> for multi-phase modularity in which these concepts are treated individually, supporting the definition of high-level modular constructs such as generative and applicative functors, as well as all extant forms of structure sharing.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-ct/</fr:uri>
                    <fr:display-uri>sterling-angiuli-2021-ct</fr:display-uri>
                    <fr:route>/sterling-angiuli-2021-ct/</fr:route>
                    <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmie6j57qqrx6av73q6ropesavo76e57fcttaxm6t7qyhzpsyhjazjm.pdf</fr:meta>
                    <fr:meta name="video">https://www.youtube.com/watch?v=AhivFjnBakE</fr:meta>
                    <fr:meta name="venue">Category Theory 2021</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2020</fr:year>
                      <fr:month>3</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2020-muri/</fr:uri>
                    <fr:display-uri>sterling-2020-muri</fr:display-uri>
                    <fr:route>/sterling-2020-muri/</fr:route>
                    <fr:title text="(cubical) computability structures">(cubical) computability structures</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmigerogwvkxuabfo24lqf5fnbd7mebab6vh3citv7bvcgc7cqyqpmy.pdf</fr:meta>
                    <fr:meta name="venue">MURI Team Meeting 2020</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2019</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-hott/</fr:uri>
                    <fr:display-uri>sterling-angiuli-gratzer-2019-hott</fr:display-uri>
                    <fr:route>/sterling-angiuli-gratzer-2019-hott/</fr:route>
                    <fr:title text="Cubical exact equality and categorical gluing">Cubical exact equality and categorical gluing</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmih2orgei2hellqbaqzwubjlulc2osk46d4s7dpkazlxzgt3oe77n4.pdf</fr:meta>
                    <fr:meta name="venue">International Conference on Homotopy Type Theory, 2019</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory which extends intensional type theory with a dependent equality type that enjoys function extensionality and judgmental unicity of identity proofs. XTT employs a variant of the Cartesian cubical Kan operations satisfying regularity (i.e., transport in constant type families is judgmentally constant), allowing its equality type to model Martin-Lof’s identity type judgmentally. We prove canonicity for the initial model of XTT (i.e., any closed term of boolean type is equal to either true or false) using a novel cubical extension (independently proposed by <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Awodey</fr:link>) of the categorical gluing technique inspired by <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link> and <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Shulman</fr:link>, in which we glue the fundamental fibration of a category of augmented Cartesian cubical sets along a cubical nerve. We conjecture that our methods will extend to open terms, allowing us to establish normalization and decidability of the typing relation.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2019</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-types/</fr:uri>
                    <fr:display-uri>sterling-angiuli-gratzer-2019-types</fr:display-uri>
                    <fr:route>/sterling-angiuli-gratzer-2019-types/</fr:route>
                    <fr:title text="XTT: cubical syntax for extensional equality (without equality reflection)">XTT: cubical syntax for extensional equality (without equality reflection)</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmifuhsbmtkvovprpvqpzzeg63w6bp46g73yb6nz53l2wnslrumnkaa.pdf</fr:meta>
                    <fr:meta name="venue">TYPES 2019</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Kuen-Bang Hou (Favonia)</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/andersm%C3%B6rtberg/" title="Anders Mörtberg" uri="https://www.jonmsterling.com/andersmörtberg/" display-uri="andersmörtberg" type="local">Anders Mörtberg</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2018</fr:year>
                      <fr:month>8</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/redtt-2018-dagstuhl/</fr:uri>
                    <fr:display-uri>redtt-2018-dagstuhl</fr:display-uri>
                    <fr:route>/redtt-2018-dagstuhl/</fr:route>
                    <fr:title text=" redtt: implementing cartesian cubical type theory"><![CDATA[ redtt]]>: implementing cartesian cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmidvxp7uolkpqxsifdgktfy5filu7kgxdh5bohnldrwtcqaqxcaggi.pdf</fr:meta>
                    <fr:meta name="venue">Dagstuhl Seminar 18341: Formalization of Mathematics in Type Theory</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Kuen-Bang Hou (Favonia)</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2018</fr:year>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/redprl-2018-lfmtp/</fr:uri>
                    <fr:display-uri>redprl-2018-lfmtp</fr:display-uri>
                    <fr:route>/redprl-2018-lfmtp/</fr:route>
                    <fr:title text="The RedPRL proof assistant">The RedPRL proof assistant</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="bibtex"><![CDATA[@inproceedings{redprl-2018-lfmtp,
  author = {Angiuli, Carlo and Cavallo, Evan and {Hou (Favonia)}, Kuen-Bang and Harper, Robert and Sterling, Jonathan},
  editor = {Blanqui, Fr\'{e}d\'{e}ric and Reis, Giselle},
  publisher = {Open Publishing Association},
  booktitle = {Proceedings of the 13th International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice, LFMTP@FSCD 2018, Oxford, UK, 7th July 2018.},
  date = {2018},
  doi = {10.4204/EPTCS.274.1},
  pages = {1--10},
  title = {{The \textsf{\textcolor[rgb]{.91,.31,.27}{Red}PRL} Proof Assistant (Invited Paper)}},
}]]></fr:meta>
                    <fr:meta name="doi">10.4204/EPTCS.274.1</fr:meta>
                    <fr:meta name="venue">International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP), 2018</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>RedPRL is an experimental proof assistant based on Cartesian cubical computational type theory, a new type theory for higher-dimensional constructions inspired by homotopy type theory. In the style of Nuprl, RedPRL users employ tactics to establish behavioral properties of cubical functional programs embodying the constructive content of proofs. Notably, RedPRL implements a two-level type theory, allowing an extensional, proof-irrelevant notion of exact equality to coexist with a higher-dimensional proof-relevant notion of paths.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:title text="Seminar talks">Seminar talks</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:contributor>
                        <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
                      </fr:contributor>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>23</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2025-yamcats-37/</fr:uri>
                    <fr:display-uri>sterling-2025-yamcats-37</fr:display-uri>
                    <fr:route>/sterling-2025-yamcats-37/</fr:route>
                    <fr:title text="When is the partial map classifier a Sierpiński cone?">When is the partial map classifier a Sierpiński cone?</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/yamcats-37/" title="Yorkshire and Midlands Category Theory Seminar 37" uri="https://www.jonmsterling.com/yamcats-37/" display-uri="yamcats-37" type="local">Yorkshire and Midlands Category Theory Seminar 37</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The idea of synthetic domain theory is to work in the internal language of a topos containing an interval object that forms a <html:em>dominance</html:em> and satisfies a few other axioms, such as Phoa’s principle. Then, not all objects deserve to be called “predomains”, but the ones that do invariably arise within full internal reflective subcategories defined by simple orthogonality laws stated in terms of the interval’s geometry. It so happens that some of these orthogonality laws are also of use in defining synthetic ∞-categories à la <fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl and Shulman</fr:link>.</html:p>
                    <html:p>I will outline some recent results in synthetic (higher) domain theory obtained with my former Masters student <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link> concerning partial map classifiers, including (1) the closure of synthetic ∞-categories under partial map classifiers, and (2) the discovery of a strengthening of the Segal completeness law that, amongst synthetic partial orders, causes the partial map classifier to coincide with the Sierpiński cone.</html:p>
                    <html:p>(See our joint paper <fr:link href="/pugh-sterling-2025/" title="When is the partial map classifier a Sierpiński cone?" uri="https://www.jonmsterling.com/pugh-sterling-2025/" display-uri="pugh-sterling-2025" type="local">When is the partial map classifier a Sierpiński cone?</fr:link>, to appear in <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>.)</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:contributor>
                        <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
                      </fr:contributor>
                      <fr:contributor>
                        <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
                      </fr:contributor>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2024</fr:year>
                      <fr:month>9</fr:month>
                      <fr:day>4</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2024-cmu-hott/</fr:uri>
                    <fr:display-uri>sterling-2024-cmu-hott</fr:display-uri>
                    <fr:route>/sterling-2024-cmu-hott/</fr:route>
                    <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit technique to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> presented an elegant functorial analysis of this construction in terms of the <html:em>‘categorical nerve’</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, applying the categorical nerve to the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting.</html:p>
                    <html:p>Although <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> has investigated Hofmann–Streicher lifting in terms of a 1-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐏𝐫</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math>, his analysis can be extended to a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that is observed by <fr:link href="/weber-2007/" title="Yoneda structures from 2-toposes" uri="https://www.jonmsterling.com/weber-2007/" display-uri="weber-2007" type="local">Weber</fr:link> to be right 2-adjoint to the 2-functor that takes a fibred category to its total category (i.e. the oplax colimit of the corresponding diagram of categories under straightening). A generalised form of Hofmann–Streicher lifting that can be applied to categories other than universes is then obtained by conjugating this right 2-adjoint with duality involutions.</html:p>
                    <html:p>In joint work with <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> and <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>, we have constructed a <html:em>relative</html:em> version of the 2-functorial Hofmann–Streicher lifting: given a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>, we have a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Δ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> which is <html:em>not</html:em> base change but rather (we conjecture) right <html:em>pseudo</html:em>-adjoint to the 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Σ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that sends a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi></mml:mrow></mml:math> to the composite fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">∘</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi></mml:mrow><mml:mo lspace=".2em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>. A relative version of Hofmann–Streicher lifting could give a more regular theory to the practice of computing <html:em>internal</html:em> liftings of lifted universes.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>10</fr:month>
                      <fr:day>25</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-00AQ/</fr:uri>
                    <fr:display-uri>jms-00AQ</fr:display-uri>
                    <fr:route>/jms-00AQ/</fr:route>
                    <fr:title text="An invitation to univalent foundations of mathematics">An invitation to univalent foundations of mathematics</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/jms-00AS/" title="Wednesday Seminar" uri="https://www.jonmsterling.com/jms-00AS/" display-uri="jms-00AS" type="local">Wednesday Seminar</fr:link>
                    </fr:meta>
                    <fr:meta name="external">https://www.cst.cam.ac.uk/seminars/list/205306</fr:meta>
                    <fr:meta name="slides">/bafkrmihpq5iekuipuikmy5me72grhju3p6o4hl3bmaf5iw4il33tveah5e.pdf</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p><fr:link href="/vladimirvoevodsky/" title="Vladimir Voevodsky" uri="https://www.jonmsterling.com/vladimirvoevodsky/" display-uri="vladimirvoevodsky" type="local">Voevodsky</fr:link>’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local"><html:em>univalent foundations</html:em> and <html:em>homotopy type theory</html:em></fr:link> comprise a new and radical approach to the foundations of mathematics in which the structural properties of <html:em>equality</html:em> are extended to every possible form of equivalence and symmetry, leading to an expanded universe of discourse in which ordinary sets and algebraic structures exist harmoniously alongside infinite-dimensional spaces. In this talk, I will expose the basic grammar and vocabulary of the new univalent foundations — and explain how they shed light on basic problems in theoretical computer science and the specification of computer programs.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>9</fr:month>
                      <fr:day>28</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-topos-colloquium/</fr:uri>
                    <fr:display-uri>sterling-2023-topos-colloquium</fr:display-uri>
                    <fr:route>/sterling-2023-topos-colloquium/</fr:route>
                    <fr:title text="Synthetic domains in the 21st century">Synthetic domains in the 21st century</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="external">https://topos.site/topos-colloquium/</fr:meta>
                    <fr:meta name="venue"><fr:link href="/toposinstitute/" title="Topos Institute" uri="https://www.jonmsterling.com/toposinstitute/" display-uri="toposinstitute" type="local">Topos Institute</fr:link> Colloquium</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>It is easy to teach a student how to give a naïve denotational semantics to a typed lambda calculus without recursion, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p>
                    <html:p>The dream of the 1990s was to find a category that behaves like SET in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this synthetic domain theory is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">simple denotational semantics</fr:link> for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p>
                    <html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>17</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-logsem/</fr:uri>
                    <fr:display-uri>sterling-2023-logsem</fr:display-uri>
                    <fr:route>/sterling-2023-logsem/</fr:route>
                    <fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiczxyoaqvsobp544cpqfjrr5tisnm36cmkyb2pykcw5owku7hzoai.pdf</fr:meta>
                    <fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines guarded recursion (the "later" modality) with impredicative polymorphism (universal and existential types). It turns out that these two features are sufficient to define a very simple denotational semantics for System F with recursive types and higher-order store. We believe that the expressivity of iGDTT brings us one step closer to a general metalanguage for realistic denotational semantics, and provides a compelling strategy to elude the burden of operational semantics. As a further benefit, we are now able to justify the extension of full dependent type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-cambridge/</fr:uri>
                    <fr:display-uri>sterling-2023-cambridge</fr:display-uri>
                    <fr:route>/sterling-2023-cambridge/</fr:route>
                    <fr:title text="Crossing boundaries in program semantics">Crossing boundaries in program semantics</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiaqido7bsry3bs2tnh5rtwa3ozf4wpm3zui46pneusslkxoh46nza.pdf</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The great semanticist John Reynolds famously wrote in 1983 that “type structure is a syntactic
discipline for enforcing levels of abstraction”. If the last twenty years of programming language
semantics and verification have taught us anything, it is that we also need a syntactic discipline
for breaking abstraction — in other words, a way to glue together programs and verifications that
cut across abstraction barriers.</html:p>
                    <html:p>In programming language semantics and verification, the problem of combining multiple levels of
abstraction arises when choosing a “level of detail” at which to view program execution:
for instance, one could look at program execution as a detailed operational process of
discrete steps evincing the cost or complexity of an algorithm, or one could think of
it more abstractly as a black box that only sends inputs to outputs. The difficulty is
that in practice, verifications tend to cut across this barrier between complexity
and functional correctness: for instance, complexity bounds often depend on the
functional correctness of subroutines, and the existence of such a bound implies
termination (a correctness property).</html:p>
                    <html:p>For this reason, it is crucial to develop integrated logical foundations for <html:strong>soundly</html:strong> reasoning
using multiple models of execution at the same time, even when they expose different facets of
a program's meaning. For the past three years, my research program has been to uncover and
exploit the basic “laws of motion” governing all such abstraction barriers, which has led
to the solution of a few significant open problems in homotopy type theory and modal type
theory, as well as some preliminary applications to security and cost analysis.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>2</fr:month>
                      <fr:day>2</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2023-birmingham/</fr:uri>
                    <fr:display-uri>sterling-2023-birmingham</fr:display-uri>
                    <fr:route>/sterling-2023-birmingham/</fr:route>
                    <fr:title text="New spaces for denotational semantics">New spaces for denotational semantics</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmihzmtwc65afir3o7ttpmckh5xakkorwpwjj6x5eg4hascotp456ke.pdf</fr:meta>
                    <fr:meta name="venue">University of Birmingham</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>8</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-itu/</fr:uri>
                    <fr:display-uri>sterling-2022-itu</fr:display-uri>
                    <fr:route>/sterling-2022-itu/</fr:route>
                    <fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmigiix5np3fp4npmgxvmx7kl7nb52ieyiazbwdxh6amdbfxdhnp2fy.pdf</fr:meta>
                    <fr:meta name="venue">Programming, Logic and Semantics, ITU Copenhagen</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines
<html:em>guarded recursion</html:em> (the "later" modality) with <html:em>impredicative polymorphism</html:em> (universal and existential types).
It turns out that these two features are sufficient to define a very simple denotational semantics for
System F with recursive types and higher-order store. We believe that the expressivity of iGDTT
brings us one step closer to a general metalanguage for realistic denotational semantics,
and provides a compelling strategy to elude the burden of operational semantics.
As a further benefit, we are now able to justify the extension of full dependent
type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>6</fr:month>
                      <fr:day>9</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-pps/</fr:uri>
                    <fr:display-uri>sterling-2022-pps</fr:display-uri>
                    <fr:route>/sterling-2022-pps/</fr:route>
                    <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">Proofs, Programs and Systems seminar (IRIF PPS)</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2022</fr:year>
                      <fr:month>4</fr:month>
                      <fr:day>26</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2022-bu-popv/</fr:uri>
                    <fr:display-uri>sterling-2022-bu-popv</fr:display-uri>
                    <fr:route>/sterling-2022-bu-popv/</fr:route>
                    <fr:title text="Intrinsic semantics of termination-insensitive noninterference">Intrinsic semantics of termination-insensitive noninterference</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiakx5dlx7mjxgf2e3qfga4xmjbru46crc6ds52thmiktqyjri46n4.pdf</fr:meta>
                    <fr:meta name="venue">Boston University POPV Seminar</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Security-typed programming languages aim to control the flow of high-security information to low security clients. Starting with Abadi et al.'s dependency core calculus, the denotational semantics of such languages has been dominated by an <html:strong>extrinsic</html:strong> approach in which an existing insecure model of computation (e.g. ordinary domains) is restricted by a logical relation of "indistinguishability" to prevent low-security outputs from depending on high-security inputs (noninterference). Thus in the extrinsic approach, security properties are bolted onto an insecure model by brute force, as it were. A more refined information flow policy called termination-insensitive noninterference allows high-security bits to be leaked through termination channels but not through return values; unfortunately, the adaptation of the extrinsic/relational semantics to this more relaxed policy is incompatible with the transitivity of the logical relation, contradicting the intuition of "indistinguishability".</html:p>
                    <html:p>In contrast, an <html:strong>intrinsic</html:strong> semantics of security typing would involve a new computational model that evinces secure information flow and noninterference properties directly without any post hoc restriction by a logical relation. We contribute the first such intrinsic semantics of security typing in this sense by considering sheaves of dcpos on a space of abstract behaviors on which security classes arise as open/closed partitions; the security monads then arise as the <html:em>closed modalities</html:em> of topos theory that restrict a sheaf to its component over a closed subspace.</html:p>
                    <html:p>An advantage of our intrinsic semantics is that termination-insensitive noninterference arises automatically from our computational model, namely the fact that the Sierpiński domain is not a constant sheaf; a further advantage is that our semantics is an instance of standard domain theoretic denotational semantics, albeit over a richer category of domains.</html:p>
                    <html:p>(j.w.w. <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">R. Harper</fr:link>)</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-ccl/</fr:uri>
                    <fr:display-uri>sterling-2021-ccl</fr:display-uri>
                    <fr:route>/sterling-2021-ccl/</fr:route>
                    <fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmig65yyrnooa2ki3usvufg3gmrp24zw3u634erewg2pwgjpthnlksq.pdf</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The purpose of this talk is to pose the question, “What are the Euclid’s postulates for syntactic metatheory?”</html:p>
                    <html:p>In the fourth century B.C.E., the Greek mathematician Euclid set down his famous postulates for plane geometry, explaining geometric shapes in terms of rules that govern their construction and incidence. The dialectical relationship between theories (axioms) and their models (coordinate systems) has been the driving force in the last two millennia of geometrical investigation.</html:p>
                    <html:p>In logic and computer science, workers in the “syntactic metatheory” investigate questions that lie on the fringe between a theory and its models — definability, normalization, decidability, conservativity, computational adequacy, parametricity, type safety, etc. Dominant methods attack these questions by means of explicit computations (e.g. Kripke logical relations) which practitioners have found to be both reliable and somewhat opaque. In this talk, I introduce <html:em>Synthetic Tait computability</html:em> — a new system of axioms that transforms these explicit computations into synthetic manipulations; classical Kripke logical relations can be seen as models or “coordinate systems” for the new geometry of syntax that is beginning to unfold.</html:p>
                    <html:p>Synthetic Tait computability has already been employed to positively resolve the normalization and decidability conjectures for cubical type theory, as well as a number of other recent results.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>11</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-logsem/</fr:uri>
                    <fr:display-uri>sterling-2021-logsem</fr:display-uri>
                    <fr:route>/sterling-2021-logsem/</fr:route>
                    <fr:title text="Between abstraction and composition...">Between abstraction and composition...</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmibvdmy674htuxiv72zuvqwhdzjsygbcvw3zcishgnlucuoc3q35iq.pdf</fr:meta>
                    <fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The fundamental contradiction of programming and program verification can be located in the tension between abstraction and composition. We make programs more abstract in order to prevent bad interactions between components; on the other side of the coin, we impede the composition of components when we abstract them. Modern programming practice evinces many distinct levels of abstraction that must be considered at the same time — for instance, compilers break module boundaries during linking, complexity analysis breaks the abstraction of extensional equivalence, and logical relations proofs break the abstraction of closure under substitution. What is needed to meet this challenge is linguistic tools that smoothly interpolate between these different levels of abstraction. Building on <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral dissertation</fr:link> and <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">joint work with Bob Harper</fr:link>, I introduce a new plan for modal programming languages and logics that treat the transition between different abstraction levels as a first-class notion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>24</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-ss/</fr:uri>
                    <fr:display-uri>sterling-2021-cmu-ss</fr:display-uri>
                    <fr:route>/sterling-2021-cmu-ss/</fr:route>
                    <fr:title text="Abstraction, composition, and the phase distinction">Abstraction, composition, and the phase distinction</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiauzlnmczowkvzdsbt3hw2hzxc35xoyii4qvpkg2cykqba7bu5pya.pdf</fr:meta>
                    <fr:meta name="venue">CMU Speakers Club</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Programmers use abstraction to hide representation details from ourselves: either to avoid mistakes (e.g. confusing a list index with a length) or to exploit representation invariants (e.g. two implementations of the QUEUE interface are indistinguishable). These abstraction boundaries can unfortunately impede the linking of smaller program units into efficient composite programs, because compilers must exploit representation details in order to produce efficient code.  Sometimes seen as the "waterloo of separate compilation", the need to break abstraction is answered by whole-program analysis techniques that break all abstractions (as in the MLton compiler for Standard ML). Separate compilation, however, has a number of advantages including speed, parallelization, and elegance.</html:p>
                    <html:p>We present an alternative type theoretic account of abstraction-breaking during compilation based on the famous phase distinction of ML languages; rather than distinguishing between compiletime and runtime, we focus on separating "devtime" from compiletime. Our framework allows the programmer to selectively reveal representation details to the compiler without giving up the representation independence properties guaranteed by "devtime" type correctness.  We also describe an application to the problem of printf-debugging, which is ordinarily obstructed by abstraction.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>5</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-padova/</fr:uri>
                    <fr:display-uri>sterling-angiuli-2021-padova</fr:display-uri>
                    <fr:route>/sterling-angiuli-2021-padova/</fr:route>
                    <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">Padova Logic Seminar</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application <html:code>(p @ i)</html:code> ceases to be neutral within its “locus of instability” <html:code>∂(i)</html:code> and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables <html:code>x : A</html:code> and dimensions <html:code>i : 𝕀</html:code>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>4</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-au-ccs/</fr:uri>
                    <fr:display-uri>sterling-2021-au-ccs</fr:display-uri>
                    <fr:route>/sterling-2021-au-ccs/</fr:route>
                    <fr:title text="Logical relations as types">Logical relations as types</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmiafb2gihhkx6w3wjzpfzs5bvjxmjospi4wuhgnszcmuq3j6w4lyue.pdf</fr:meta>
                    <fr:meta name="video">https://www.youtube.com/watch?v=AEthjg2k718</fr:meta>
                    <fr:meta name="venue">CCS Colloquium, Augusta University</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>
                      <html:em>This is joint work with <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:em>
                    </html:p>
                    <html:p>How do you prove that two implementations of an abstract type behave the same in all configurations? Reynolds famously employed logical relations to establish such results; roughly, a logical relation is a structure-respecting relation between two interpretations of a theory that evinces, in the base case, a desirable invariant.</html:p>
                    <html:p>We present a synthetic way to understand and interact with logical relations, related to classical logical relations in the same way that Euclidean geometry relates to point-sets. Previously a logical relation was defined in terms of the (complicated) details of how it is constructed as a certain kind of relation over syntax. We instead take the simpler view that everything in sight is a logical relation, and then use modalities to isolate those logical relations that are degenerate in either the syntactic or the semantic direction.</html:p>
                    <html:p>Our “logical relations as types” principle has led to a new account of modules and representation independence <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">(S., Harper)</fr:link>, as well as the first proofs of normalization for cubical type theory <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">(S., Angiuli)</fr:link> and general multi-modal dependent type theory <fr:link href="/gratzer-2022/" title="Normalization for multimodal type theory" uri="https://www.jonmsterling.com/gratzer-2022/" display-uri="gratzer-2022" type="local">(Gratzer)</fr:link>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2021</fr:year>
                      <fr:month>2</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-hott/</fr:uri>
                    <fr:display-uri>sterling-2021-cmu-hott</fr:display-uri>
                    <fr:route>/sterling-2021-cmu-hott/</fr:route>
                    <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">Pittsburgh's HoTT Seminar</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application p(i) ceases to be neutral within its “locus of instability” ∂(i) and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables x : A and dimensions i : 𝕀.</html:p>
                    <html:p>(j.w.w. <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>.)</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2020</fr:year>
                      <fr:month>6</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2020-epa/</fr:uri>
                    <fr:display-uri>sterling-2020-epa</fr:display-uri>
                    <fr:route>/sterling-2020-epa/</fr:route>
                    <fr:title text=" redtt and the future of Cartesian cubical type theory"><![CDATA[ redtt]]> and the future of Cartesian cubical type theory</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="video">https://vimeo.com/425917591</fr:meta>
                    <fr:meta name="venue">Every Proof Assistant</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>redtt is an interactive proof assistant for Cartesian cubical type theory, a version of Martin-Löf type theory featuring computational versions of function extensionality, higher inductive types, and univalence. Building on ideas from Epigram, Agda, and Idris, redtt introduces a new cubical take on interactive proof development with holes. We will first introduce the basics of cubical type theory and then dive into an interactive demonstration of redtt’s features and its mathematical library.</html:p>
                    <html:p>After this we will catch a first public glimpse of the future of redtt, a new prototype that our team is building currently code-named "cooltt": cooltt introduces syntax to split on disjunctions of cofibrations in arbitrary positions, implementing the full definitional eta law for disjunction. While cooltt is still in the early stages, it already has full support for univalence and cubical interactive proof development.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2020</fr:year>
                      <fr:month>3</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2020-hottest/</fr:uri>
                    <fr:display-uri>sterling-2020-hottest</fr:display-uri>
                    <fr:route>/sterling-2020-hottest/</fr:route>
                    <fr:title text="Objective metatheory of dependent type theories">Objective metatheory of dependent type theories</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="slides">/bafkrmih22ghxxcrk6747rxh5o3lwiua6ioweqt5dtxsuegz6c2u2roco5u.pdf</fr:meta>
                    <fr:meta name="video">https://www.youtube.com/watch?v=cyBn-lkvXTc</fr:meta>
                    <fr:meta name="venue">Homotopy Type Theory Electronic Seminar Talks</fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>What type theorists and other researchers in type theory have in common is that they study theorems that hold of the initial model of type theory; but type theorists especially emphasize the theorems whose statements are sufficiently non-type-theoretic that they need not be preserved by homomorphisms of models. These theorems, sometimes called "metatheorems" or "admissibilities", are the means by which we conceive and justify computerized implementations of type theory, including canonicity, normalization, and decidability of type checking and judgmental equality.</html:p>
                    <html:p>The main tool for proving such theorems is Tait's method of computability, which has in the past several years been subject to a rapid campaign of rectification using the categorical language of Artin gluing. I will give an overview of this brave new "objective computability", emphasizing my recent joint work with Angiuli and Gratzer on a general gluing theorem for models of MLTT along flat functors into Grothendieck topoi, with an application to cubical type theory.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                      <fr:author>
                        <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2020</fr:year>
                      <fr:month>1</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2020/</fr:uri>
                    <fr:display-uri>sterling-angiuli-2020</fr:display-uri>
                    <fr:route>/sterling-angiuli-2020/</fr:route>
                    <fr:title text="Gluing models of type theory along flat functors">Gluing models of type theory along flat functors</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="external">/bafkrmiccwetsrjk6rbtoexh7up6djbemy2zvujsqohyzj7nllau5vceydq.pdf</fr:meta>
                    <fr:meta name="venue">
                      <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>We extend the theory of Artin gluing to strict dependent type theory: given a flat functor F : C → E from the category of contexts a model of Martin-Löf type theory into a Grothendieck topos E, we may construct the F-computability families model of type theory. Our theorem extends to MLTT with a (strict, weak) universe à la Tarski if E may be equipped with a (strict, weak) universe à la Tarski.</html:p>
                    <html:p>We introduce a more tractable approach to gluing models of type theory, working primarily within a suitably enlarged category of computability families which are not all tracked by syntactical entities, but which is densely generated by the subcategory of such computability families.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2019</fr:year>
                      <fr:month>4</fr:month>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/sterling-2019-cmu-hott/</fr:uri>
                    <fr:display-uri>sterling-2019-cmu-hott</fr:display-uri>
                    <fr:route>/sterling-2019-cmu-hott/</fr:route>
                    <fr:title text="Algebraic type theory and the gluing construction">Algebraic type theory and the gluing construction</fr:title>
                    <fr:taxon>Reference</fr:taxon>
                    <fr:meta name="venue">
                      <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
                    </fr:meta>
                  </fr:frontmatter>
                  <fr:mainmatter />
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>21</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00K0/</fr:uri>
            <fr:display-uri>jms-00K0</fr:display-uri>
            <fr:route>/jms-00K0/</fr:route>
            <fr:title text="Lectures on discrete mathematics › Authorship statement"><fr:link href="/jms-00JB/" title="Lectures on discrete mathematics" uri="https://www.jonmsterling.com/jms-00JB/" display-uri="jms-00JB" type="local">Lectures on discrete mathematics</fr:link> › Authorship statement</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>These lecture notes were prepared by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> using <fr:link href="/marcelofiore/" title="Marcelo Fiore" uri="https://www.jonmsterling.com/marcelofiore/" display-uri="marcelofiore" type="local">Marcelo Fiore</fr:link>’s lectures as source material. Any mistakes were introduced by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
            <fr:display-uri>jms-0061</fr:display-uri>
            <fr:route>/jms-0061/</fr:route>
            <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
            <fr:taxon>Fellowship</fr:taxon>
            <fr:meta name="doi">10.3030/101065303</fr:meta>
            <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jms-00GC/</fr:uri>
            <fr:display-uri>jms-00GC</fr:display-uri>
            <fr:route>/jms-00GC/</fr:route>
            <fr:title text="Aarhus University">Aarhus University</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="external">https://www.au.dk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/camcl/</fr:uri>
            <fr:display-uri>camcl</fr:display-uri>
            <fr:route>/camcl/</fr:route>
            <fr:title text="Cambridge Computer Laboratory">Cambridge Computer Laboratory</fr:title>
            <fr:taxon>Department</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/ucam/" title="University of Cambridge" uri="https://www.jonmsterling.com/ucam/" display-uri="ucam" type="local">University of Cambridge</fr:link>
            </fr:meta>
            <fr:meta name="external">https://www.cst.cam.ac.uk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jms-00GP/</fr:uri>
            <fr:display-uri>jms-00GP</fr:display-uri>
            <fr:route>/jms-00GP/</fr:route>
            <fr:title text="Clare College">Clare College</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="institution">
              <fr:link href="/ucam/" title="University of Cambridge" uri="https://www.jonmsterling.com/ucam/" display-uri="ucam" type="local">University of Cambridge</fr:link>
            </fr:meta>
            <fr:meta name="position">Constituent College</fr:meta>
            <fr:meta name="external">https://www.clare.cam.ac.uk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/larsbirkedal/</fr:uri>
            <fr:display-uri>larsbirkedal</fr:display-uri>
            <fr:route>/larsbirkedal/</fr:route>
            <fr:title text="Lars Birkedal">Lars Birkedal</fr:title>
            <fr:taxon>Person</fr:taxon>
            <fr:meta name="external">https://cs.au.dk/~birke/</fr:meta>
            <fr:meta name="institution">
              <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>
            </fr:meta>
            <fr:meta name="position">Professor</fr:meta>
            <fr:meta name="orcid">0000-0003-1320-0098</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Villum Investigator; Head of Logic and Semantics Group.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/robertharper/</fr:uri>
            <fr:display-uri>robertharper</fr:display-uri>
            <fr:route>/robertharper/</fr:route>
            <fr:title text="Robert Harper">Robert Harper</fr:title>
            <fr:taxon>Person</fr:taxon>
            <fr:meta name="institution">
              <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link>
            </fr:meta>
            <fr:meta name="position">Professor</fr:meta>
            <fr:meta name="orcid">0000-0002-9400-2941</fr:meta>
            <fr:meta name="external">http://www.cs.cmu.edu/~rwh</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/lingyuanye/" title="Lingyuan Ye" uri="https://www.jonmsterling.com/lingyuanye/" display-uri="lingyuanye" type="local">Lingyuan Ye</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>5</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-ye-2025/</fr:uri>
            <fr:display-uri>sterling-ye-2025</fr:display-uri>
            <fr:route>/sterling-ye-2025/</fr:route>
            <fr:title text="Domains and Classifying Topoi">Domains and Classifying Topoi</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2505.13096</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We explore a new connection between synthetic domain theory and Grothendieck topoi related to the distributive lattice classifier. In particular, all the axioms of synthetic domain theory (including the inductive fixed point object and the chain completeness of the dominance) emanate from a countable version of the synthetic quasi-coherence principle that has emerged as a central feature in the unification of <fr:link href="/cherubini-coquand-hutzler-2024/" title="A foundation for synthetic algebraic geometry" uri="https://www.jonmsterling.com/cherubini-coquand-hutzler-2024/" display-uri="cherubini-coquand-hutzler-2024" type="local">synthetic algebraic geometry</fr:link>, <fr:link href="/cherubini-coquand-geerligs-moeneclaey-2024/" title="A Foundation for Synthetic Stone Duality" uri="https://www.jonmsterling.com/cherubini-coquand-geerligs-moeneclaey-2024/" display-uri="cherubini-coquand-geerligs-moeneclaey-2024" type="local">synthetic Stone duality</fr:link>, and <fr:link href="/gratzer-weinberger-buchholtz-2025/" title="The Yoneda embedding in simplicial type theory" uri="https://www.jonmsterling.com/gratzer-weinberger-buchholtz-2025/" display-uri="gratzer-weinberger-buchholtz-2025" type="local">synthetic category theory</fr:link>. The duality between quasi-coherent algebras and affine spaces in a topos with a distributive lattice object provides a new set of techniques for reasoning synthetically about domain-like structures, and reveals a broad class of (higher) sheaf models for synthetic domain theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>3</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>5</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/slattery-sterling-2025/</fr:uri>
            <fr:display-uri>slattery-sterling-2025</fr:display-uri>
            <fr:route>/slattery-sterling-2025/</fr:route>
            <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2504.09520</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit construction to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey presented</fr:link> an elegant functorial analysis of this construction in terms of the <html:em>categorical nerve</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, the categorical nerve’s functorial action on the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting. Inspired by <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey’s analysis</fr:link>, we define a relative version of Hofmann–Streicher lifting in terms of the right pseudo-adjoint to the functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> given by postcomposition with a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">B</mml:mi></mml:mrow></mml:math></html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>1</fr:month>
              <fr:day>31</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>5</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/pugh-sterling-2025/</fr:uri>
            <fr:display-uri>pugh-sterling-2025</fr:display-uri>
            <fr:route>/pugh-sterling-2025/</fr:route>
            <fr:title text="When is the partial map classifier a Sierpiński cone?">When is the partial map classifier a Sierpiński cone?</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
            </fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2504.06789</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We study the relationship between partial map classifiers, Sierpiński cones, and axioms for synthetic higher categories and domains within <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. In particular, we show that synthetic ∞-categories are closed under partial map classifiers assuming Phoa's principle, and we isolate a new reflective subuniverse of types within which the Sierpiński cone (a lax colimit) can be computed as a partial map classifier by strengthening the Segal condition.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
                  </fr:author>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>4</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>5</fr:month>
                  <fr:day>6</fr:day>
                </fr:date>
                <fr:title text="Errata">Errata</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The paper currently states that the alternative type theoretic computation of the scone uses the flattening lemma, but this is incorrect. In fact, we need only the fact the dependent sum functor preserves colimits (being left adjoint to base change). This will be corrected in the final version of the paper.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2025-yamcats-37/</fr:uri>
            <fr:display-uri>sterling-2025-yamcats-37</fr:display-uri>
            <fr:route>/sterling-2025-yamcats-37/</fr:route>
            <fr:title text="When is the partial map classifier a Sierpiński cone?">When is the partial map classifier a Sierpiński cone?</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/yamcats-37/" title="Yorkshire and Midlands Category Theory Seminar 37" uri="https://www.jonmsterling.com/yamcats-37/" display-uri="yamcats-37" type="local">Yorkshire and Midlands Category Theory Seminar 37</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The idea of synthetic domain theory is to work in the internal language of a topos containing an interval object that forms a <html:em>dominance</html:em> and satisfies a few other axioms, such as Phoa’s principle. Then, not all objects deserve to be called “predomains”, but the ones that do invariably arise within full internal reflective subcategories defined by simple orthogonality laws stated in terms of the interval’s geometry. It so happens that some of these orthogonality laws are also of use in defining synthetic ∞-categories à la <fr:link href="/riehl-shulman-2017/" title="A type theory for synthetic ∞-categories" uri="https://www.jonmsterling.com/riehl-shulman-2017/" display-uri="riehl-shulman-2017" type="local">Riehl and Shulman</fr:link>.</html:p>
            <html:p>I will outline some recent results in synthetic (higher) domain theory obtained with my former Masters student <fr:link href="/leonipugh/" title="Leoni Pugh" uri="https://www.jonmsterling.com/leonipugh/" display-uri="leonipugh" type="local">Leoni Pugh</fr:link> concerning partial map classifiers, including (1) the closure of synthetic ∞-categories under partial map classifiers, and (2) the discovery of a strengthening of the Segal completeness law that, amongst synthetic partial orders, causes the partial map classifier to coincide with the Sierpiński cone.</html:p>
            <html:p>(See our joint paper <fr:link href="/pugh-sterling-2025/" title="When is the partial map classifier a Sierpiński cone?" uri="https://www.jonmsterling.com/pugh-sterling-2025/" display-uri="pugh-sterling-2025" type="local">When is the partial map classifier a Sierpiński cone?</fr:link>, to appear in <fr:link href="/lics-2025/" title="LICS ’25: 40th Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2025/" display-uri="lics-2025" type="local"><html:em>LICS ’25</html:em>: 40th Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>.)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:contributor>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:contributor>
              <fr:contributor>
                <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>9</fr:month>
              <fr:day>4</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2024-cmu-hott/</fr:uri>
            <fr:display-uri>sterling-2024-cmu-hott</fr:display-uri>
            <fr:route>/sterling-2024-cmu-hott/</fr:route>
            <fr:title text="Hofmann–Streicher lifting of fibred categories">Hofmann–Streicher lifting of fibred categories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In 1997, <fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> introduced an explicit technique to lift a Grothendieck universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math> from <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math> into the category of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐒𝐞𝐭</mml:mi></mml:math>-valued presheaves on a <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small category <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:math>. More recently, <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> presented an elegant functorial analysis of this construction in terms of the <html:em>‘categorical nerve’</html:em>, the right adjoint to the functor that takes a presheaf to its category of elements; in particular, applying the categorical nerve to the universal <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>-small discrete fibration gives the generic family of <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓤</mml:mi></mml:math>’s Hofmann–Streicher lifting.</html:p>
            <html:p>Although <fr:link href="/awodey-2024-universes/" title="On Hofmann–Streicher universes" uri="https://www.jonmsterling.com/awodey-2024-universes/" display-uri="awodey-2024-universes" type="local">Awodey</fr:link> has investigated Hofmann–Streicher lifting in terms of a 1-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐏𝐫</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math>, his analysis can be extended to a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐂𝐚𝐭</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that is observed by <fr:link href="/weber-2007/" title="Yoneda structures from 2-toposes" uri="https://www.jonmsterling.com/weber-2007/" display-uri="weber-2007" type="local">Weber</fr:link> to be right 2-adjoint to the 2-functor that takes a fibred category to its total category (i.e. the oplax colimit of the corresponding diagram of categories under straightening). A generalised form of Hofmann–Streicher lifting that can be applied to categories other than universes is then obtained by conjugating this right 2-adjoint with duality involutions.</html:p>
            <html:p>In joint work with <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link> and <fr:link href="/andrewslattery/" title="Andrew Slattery" uri="https://www.jonmsterling.com/andrewslattery/" display-uri="andrewslattery" type="local">Andrew Slattery</fr:link>, we have constructed a <html:em>relative</html:em> version of the 2-functorial Hofmann–Streicher lifting: given a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>, we have a 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Δ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> which is <html:em>not</html:em> base change but rather (we conjecture) right <html:em>pseudo</html:em>-adjoint to the 2-functor <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:msub xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">Σ</mml:mi><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi></mml:msub> <mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝐅𝐢𝐛</mml:mi>
  <mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML">
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[(]]></mml:mo>
   <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi>
   <mml:mo fence="true" xmlns:mml="http://www.w3.org/1998/Math/MathML"><![CDATA[)]]></mml:mo>
  </mml:mrow>
 </mml:mrow></mml:mrow></mml:math> that sends a fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi><mml:mo lspace=".1em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓐</mml:mi></mml:mrow></mml:math> to the composite fibration <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">p</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">∘</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">q</mml:mi></mml:mrow><mml:mo lspace=".2em" rspace=".2em" xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo> <mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓔</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">𝓑</mml:mi></mml:mrow></mml:math>. A relative version of Hofmann–Streicher lifting could give a more regular theory to the practice of computing <html:em>internal</html:em> liftings of lifted universes.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>8</fr:month>
              <fr:day>13</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri>
            <fr:display-uri>sterling-2025-grothendieck</fr:display-uri>
            <fr:route>/sterling-2025-grothendieck/</fr:route>
            <fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta>
            <fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p>
            <html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>24</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>5</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2024-universes/</fr:uri>
            <fr:display-uri>gratzer-shulman-sterling-2024-universes</fr:display-uri>
            <fr:route>/gratzer-shulman-sterling-2024-universes/</fr:route>
            <fr:title text="Strict universes for Grothendieck topoi">Strict universes for Grothendieck topoi</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2024-universes,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2024},
  month = may,
  doi = {10.48550/arXiv.2202.12012},
  eprint = {2202.12012},
  eprintclass = {math.CT},
  eprinttype = {arXiv},
  note = {Unpublished manuscript},
  title = {Strict universes for Grothendieck topoi},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.12012</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/hofmann-streicher-1997/" title="Lifting Grothendieck universes" uri="https://www.jonmsterling.com/hofmann-streicher-1997/" display-uri="hofmann-streicher-1997" type="local">Hofmann and Streicher</fr:link> famously showed how to lift Grothendieck universes into presheaf topoi, and <fr:link href="/streicher-2005/" title="Universes in toposes" uri="https://www.jonmsterling.com/streicher-2005/" display-uri="streicher-2005" type="local">Streicher</fr:link> has extended their result to the case of sheaf topoi by
sheafification. In parallel, <fr:link href="/van-den-berg-moerdijk-2012/" title="Aspects of predicative algebraic set theory III: sheaves" uri="https://www.jonmsterling.com/van-den-berg-moerdijk-2012/" display-uri="van-den-berg-moerdijk-2012" type="local">van den Berg and Moerdijk</fr:link> have shown in the context of algebraic set theory that similar constructions continue to apply even in weaker metatheories. Unfortunately, sheafification seems not to preserve an important <html:em>realignment</html:em> property enjoyed by presheaf universes that plays a critical role in models of univalent type theory as well as <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link>. When <html:em>multiple</html:em> universes are present, realignment also implies a coherent interpretation of connectives across all universes that justifies the cumulativity laws present in popular formulations of Martin-Löf type theory.</html:p>
            <html:p>We observe that a slight adjustment to an argument of <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link> constructs a cumulative universe hierarchy satisfying the realignment property at every level in any Grothendieck topos. Hence one has direct-style interpretations of Martin-Löf type theory with cumulative universes into all Grothendieck topoi. A further implication is to extend the reach of recent synthetic methods in the semantics of cubical type theory and the syntactic metatheory of type theory and programming languages to all Grothendieck topoi.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>12</fr:month>
              <fr:day>27</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>4</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2024-lifting/</fr:uri>
            <fr:display-uri>sterling-2024-lifting</fr:display-uri>
            <fr:route>/sterling-2024-lifting/</fr:route>
            <fr:title text="Tensorial structure of the lifting doctrine in constructive domain theory">Tensorial structure of the lifting doctrine in constructive domain theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Proceedings of <fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2312.17023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present a survey of the two-dimensional and tensorial structure of the <html:em>lifting doctrine</html:em> in constructive domain theory, i.e. in the theory of directed-complete partial orders (dcpos) over an arbitrary elementary topos. We establish the universal property of lifting of dcpos as the Sierpiński cone, from which we deduce (1) that lifting forms a Kock–Zöberlein doctrine, (2) that lifting algebras, pointed dcpos, and inductive partial orders form canonically equivalent locally posetal 2-categories, and (3) that the category of lifting algebras is cocomplete, with connected colimits created by the forgetful functor to dcpos. Finally we deduce the symmetric monoidal closure of the Eilenberg–Moore resolution of the lifting 2-monad by means of smash products; these are shown to classify both bilinear maps and strict maps, which we prove to coincide in the constructive setting. We provide several concrete computations of the smash product as dcpo coequalisers and lifting algebra coequalisers, and compare these with the more abstract results of Seal. Although all these results are well-known classically, the existing proofs do not apply in a constructive setting; indeed, the classical analysis of the Eilenberg–Moore category of the lifting monad relies on the fact that all lifting algebras are free, a condition that is not known to hold constructively.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>30</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2024-lenses/</fr:uri>
            <fr:display-uri>sterling-2024-lenses</fr:display-uri>
            <fr:route>/sterling-2024-lenses/</fr:route>
            <fr:title text="Reflexive graph lenses in univalent foundations">Reflexive graph lenses in univalent foundations</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2404.07854</fr:meta>
            <fr:meta name="external">https://arxiv.org/abs/2404.07854</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/permartinl%C3%B6f/" title="Per Martin-Löf" uri="https://www.jonmsterling.com/permartinlöf/" display-uri="permartinlöf" type="local">Martin-Löf</fr:link>’s identity types provide a generic (albeit opaque) notion of identification or “equality” between any two elements of the same type, embodied in a canonical reflexive graph structure <fr:tex display="inline"><![CDATA[(=_A, \mathbf {refl})]]></fr:tex> on any type <fr:tex display="inline"><![CDATA[A]]></fr:tex>. The miracle of <fr:link href="/vladimirvoevodsky/" title="Vladimir Voevodsky" uri="https://www.jonmsterling.com/vladimirvoevodsky/" display-uri="vladimirvoevodsky" type="local">Voevodsky</fr:link>’s <html:em>univalence principle</html:em> is that it ensures, for essentially any naturally occuring structure in mathematics, that this the resultant notion of identification is equivalent to the type of <html:em>isomorphisms</html:em> in the category of such structures. Characterisations of this kind are not automatic and must be established one-by-one; to this end, several authors have employed <html:em>reflexive graphs</html:em> and <html:em>displayed reflexive graphs</html:em> to organise the characterisation of identity types. We contribute <html:strong>reflexive graph lenses</html:strong>, a new family of intermediate abstractions lying between families of reflexive graphs and displayed reflexive graphs that simplifies the characterisation of identity types for complex structures. Every reflexive graph lens gives rise to a (more complicated) displayed reflexive graph, and our experience suggests that many naturally occuring displayed reflexive graphs arise in this way. Evidence for the utility of reflexive graph lenses is given by means of several case studies, including the theory of reflexive graphs itself as well as that of polynomial type operators. Finally, we exhibit an equivalance between the type of reflexive graph fibrations and the type of <html:em>univalent</html:em> reflexive graph lenses.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>3</fr:month>
              <fr:day>29</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/niu-sterling-harper-2024/</fr:uri>
            <fr:display-uri>niu-sterling-harper-2024</fr:display-uri>
            <fr:route>/niu-sterling-harper-2024/</fr:route>
            <fr:title text="Cost-sensitive computational adequacy of higher-order recursion in synthetic domain theory">Cost-sensitive computational adequacy of higher-order recursion in synthetic domain theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.46298/entics.14732</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/mfps-2024/" title="MFPS ’24: 40th International Conference on Mathematical Foundations of Programming Semantics" uri="https://www.jonmsterling.com/mfps-2024/" display-uri="mfps-2024" type="local"><html:em>MFPS ’24</html:em>: 40th International Conference on Mathematical Foundations of Programming Semantics</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We study a cost-aware programming language for higher-order recursion dubbed <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> in the setting of <html:em><fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link></html:em> (SDT). Our main contribution relates the denotational cost semantics of <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> to its <html:em>computational cost semantics</html:em>, a new kind of dynamic semantics for program execution that serves as a mathematically natural alternative to operational semantics in SDT. In particular we prove an internal, cost-sensitive version of Plotkin’s computational adequacy theorem, giving a precise correspondence between the denotational and computational semantics for complete programs at base type. The constructions and proofs of this paper take place in the internal dependent type theory of an SDT topos extended by a <html:em>phase distinction</html:em> in the sense of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>. By controlling the interpretation of cost structure via the phase distinction in the denotational semantics, we show that <html:strong>PCF</html:strong><html:sub><html:strong>cost</html:strong></html:sub> programs also evince a noninterference property of cost and behavior. We verify the axioms of the type theory by means of a model construction based on relative sheaf models of SDT.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>2</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route>
            <fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link>
            </fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri>
            <fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri>
            <fr:route>/grodin-niu-sterling-harper-2024/</fr:route>
            <fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link>
            </fr:meta>
            <fr:meta name="doi">10.1145/3632852</fr:meta>
            <fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p>
            <html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2024</fr:year>
                  <fr:month>10</fr:month>
                  <fr:day>3</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri>
                <fr:display-uri>jms-012Q</fr:display-uri>
                <fr:route>/jms-012Q/</fr:route>
                <fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/filipsieczkowski/" title="Filip Sieczkowski" uri="https://www.jonmsterling.com/filipsieczkowski/" display-uri="filipsieczkowski" type="local">Filip Sieczkowski</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/sergeistepanenko/" title="Sergei Stepanenko" uri="https://www.jonmsterling.com/sergeistepanenko/" display-uri="sergeistepanenko" type="local">Sergei Stepanenko</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2024</fr:year>
              <fr:month>1</fr:month>
              <fr:day>5</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:uri>
            <fr:display-uri>sieczkowski-stepanenko-sterling-birkedal-2024</fr:display-uri>
            <fr:route>/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:route>
            <fr:title text="The essence of generalized algebraic data types">The essence of generalized algebraic data types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link>
            </fr:meta>
            <fr:meta name="doi">10.1145/3632866</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{sieczkowski-stepanenko-sterling-birkedal-2024,
  author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
  title = {The Essence of Generalized Algebraic Data Types},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632866},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {24},
  numpages = {29},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This paper considers direct encodings of generalized algebraic data types (GADTs) in a minimal suitable lambda-calculus. To this end, we develop an extension of System F<html:sub>ω</html:sub> with recursive types and internalized type equalities with injective constant type constructors. We show how GADTs and associated pattern-matching constructs can be directly expressed in the calculus, thus showing that it may be treated as a highly idealized modern functional programming language. We prove that the internalized type equalities in conjunction with injectivity rules increase the expressive power of the calculus by establishing a non-macro-expressibility result in F<html:sub>ω</html:sub>, and prove the system type-sound via a syntactic argument. Finally, we build two relational models of our calculus: a simple, unary model that illustrates a novel, two-stage interpretation technique, necessary to account for the equational constraints; and a more sophisticated, binary model that relaxes the construction to allow, for the first time, formal reasoning about data-abstraction in a calculus equipped with GADTs.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>11</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri>
            <fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri>
            <fr:route>/aagaard-sterling-birkedal-2023/</fr:route>
            <fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.46298/entics.12232</fr:meta>
            <fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00AQ/</fr:uri>
            <fr:display-uri>jms-00AQ</fr:display-uri>
            <fr:route>/jms-00AQ/</fr:route>
            <fr:title text="An invitation to univalent foundations of mathematics">An invitation to univalent foundations of mathematics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/jms-00AS/" title="Wednesday Seminar" uri="https://www.jonmsterling.com/jms-00AS/" display-uri="jms-00AS" type="local">Wednesday Seminar</fr:link>
            </fr:meta>
            <fr:meta name="external">https://www.cst.cam.ac.uk/seminars/list/205306</fr:meta>
            <fr:meta name="slides">/bafkrmihpq5iekuipuikmy5me72grhju3p6o4hl3bmaf5iw4il33tveah5e.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/vladimirvoevodsky/" title="Vladimir Voevodsky" uri="https://www.jonmsterling.com/vladimirvoevodsky/" display-uri="vladimirvoevodsky" type="local">Voevodsky</fr:link>’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local"><html:em>univalent foundations</html:em> and <html:em>homotopy type theory</html:em></fr:link> comprise a new and radical approach to the foundations of mathematics in which the structural properties of <html:em>equality</html:em> are extended to every possible form of equivalence and symmetry, leading to an expanded universe of discourse in which ordinary sets and algebraic structures exist harmoniously alongside infinite-dimensional spaces. In this talk, I will expose the basic grammar and vocabulary of the new univalent foundations — and explain how they shed light on basic problems in theoretical computer science and the specification of computer programs.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>28</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-topos-colloquium/</fr:uri>
            <fr:display-uri>sterling-2023-topos-colloquium</fr:display-uri>
            <fr:route>/sterling-2023-topos-colloquium/</fr:route>
            <fr:title text="Synthetic domains in the 21st century">Synthetic domains in the 21st century</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">https://topos.site/topos-colloquium/</fr:meta>
            <fr:meta name="venue"><fr:link href="/toposinstitute/" title="Topos Institute" uri="https://www.jonmsterling.com/toposinstitute/" display-uri="toposinstitute" type="local">Topos Institute</fr:link> Colloquium</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It is easy to teach a student how to give a naïve denotational semantics to a typed lambda calculus without recursion, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p>
            <html:p>The dream of the 1990s was to find a category that behaves like SET in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this synthetic domain theory is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">simple denotational semantics</fr:link> for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p>
            <html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>6</fr:month>
              <fr:day>27</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-catmi/</fr:uri>
            <fr:display-uri>sterling-2023-catmi</fr:display-uri>
            <fr:route>/sterling-2023-catmi/</fr:route>
            <fr:title text="Naïve denotational semantics: synthetic domains in the 21st century">Naïve denotational semantics: synthetic domains in the 21st century</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">http://www.catmi.no/</fr:meta>
            <fr:meta name="slides">/bafkrmielsxg42lagb5fu2zymlfcvlvyqpvclrzc3kre6dszhwpgvdxuum4.pdf</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It is easy to teach a student how to give a naïve denotational semantics to a language like System T, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p>
            <html:p>The dream of the 1990s was to find a category that behaves like <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this <html:strong>synthetic domain theory</html:strong> is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including simple denotational semantics for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p>
            <html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>4</fr:month>
              <fr:day>25</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-generic/</fr:uri>
            <fr:display-uri>sterling-2023-generic</fr:display-uri>
            <fr:route>/sterling-2023-generic/</fr:route>
            <fr:title text="What should a generic object be?">What should a generic object be?</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{sterling-2023-generic,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2023},
  doi = {10.1017/S0960129523000117},
  journaltitle = {Mathematical Structures in Computer Science},
  pages = {1--22},
  title = {What should a generic object be?},
}]]></fr:meta>
            <fr:meta name="doi">10.1017/S0960129523000117</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> has proposed definitions for (weak, strong, split) generic objects for a fibered category; building on his definition of (split) generic objects, <fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> develops a menagerie of important fibrational structures with applications to categorical logic and computer science, including higher order fibrations, polymorphic fibrations, 𝜆2-fibrations, triposes, and others. We observe that a split generic object need not in particular be a generic object under the given definitions, and that the definitions of polymorphic fibrations, triposes, etc. are strict enough to rule out some fundamental examples: for instance, the fibered preorder induced by a partial combinatory algebra in realizability is not a tripos in this sense. We propose a new alignment of terminology that emphasizes the forms of generic object appearing most commonly in nature, i.e. in the study of internal categories, triposes, and the denotational semantics of polymorphism. In addition, we propose a new class of acyclic generic objects inspired by recent developments in higher category theory and the semantics of homotopy type theory, generalizing the realignment property of universes to the setting of an arbitrary fibration.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>4</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-logsem/</fr:uri>
            <fr:display-uri>sterling-2023-logsem</fr:display-uri>
            <fr:route>/sterling-2023-logsem/</fr:route>
            <fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiczxyoaqvsobp544cpqfjrr5tisnm36cmkyb2pykcw5owku7hzoai.pdf</fr:meta>
            <fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines guarded recursion (the "later" modality) with impredicative polymorphism (universal and existential types). It turns out that these two features are sufficient to define a very simple denotational semantics for System F with recursive types and higher-order store. We believe that the expressivity of iGDTT brings us one step closer to a general metalanguage for realistic denotational semantics, and provides a compelling strategy to elude the burden of operational semantics. As a further benefit, we are now able to justify the extension of full dependent type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielepalombi/" title="Daniele Palombi" uri="https://www.jonmsterling.com/danielepalombi/" display-uri="danielepalombi" type="local">Daniele Palombi</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/palombi-sterling-2023/</fr:uri>
            <fr:display-uri>palombi-sterling-2023</fr:display-uri>
            <fr:route>/palombi-sterling-2023/</fr:route>
            <fr:title text="Classifying topoi in synthetic guarded domain theory: the universal property of multi-clock guarded recursion">Classifying topoi in synthetic guarded domain theory: the universal property of multi-clock guarded recursion</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{palombi-sterling-2023,
  author = {Palombi, Daniele and Sterling, Jonathan},
  booktitle = {Proceedings 38th Conference on Mathematical Foundations of Programming Semantics, {MFPS} 2022},
  year = {2023},
  month = feb,
  title = {Classifying topoi in synthetic guarded domain theory},
  doi = {10.46298/entics.10323},
}]]></fr:meta>
            <fr:meta name="doi">10.46298/entics.10323</fr:meta>
            <fr:meta name="venue">38th International Conference on Mathematical Foundations of Programming Semantics</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Several different topoi have played an important role in the development and applications of <html:em><fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link></html:em> (SGDT), a new kind of synthetic domain theory that abstracts the concept of <html:em>guarded recursion</html:em> frequently employed in the semantics of programming languages. In order to unify the accounts of guarded recursion and coinduction, <fr:link href="/atkey-mcbride-2013/" title="Productive coprogramming with guarded recursion" uri="https://www.jonmsterling.com/atkey-mcbride-2013/" display-uri="atkey-mcbride-2013" type="local">several</fr:link> <fr:link href="/bizjak-mogelberg-2020/" title="Denotational semantics for guarded dependent type theory" uri="https://www.jonmsterling.com/bizjak-mogelberg-2020/" display-uri="bizjak-mogelberg-2020" type="local">authors</fr:link> have enriched SGDT with multiple “clocks” parameterizing different time-streams, leading to more complex and difficult to understand topos models. Until now these topoi have been understood very concretely <html:em>qua</html:em> categories of presheaves, and the logico-geometrical question of what theories these topoi classify has remained open. We show that several important topos models of SGDT classify very simple geometric theories, and that the passage to various forms of multi-clock guarded recursion can be rephrased more compositionally in terms of the lower bagtopos construction of <fr:link href="/vickers-1992/" title="Geometric theories and databases" uri="https://www.jonmsterling.com/vickers-1992/" display-uri="vickers-1992" type="local">Vickers</fr:link> and variations thereon due to <fr:link href="/johnstone-1994/" title="Variations on the bagdomain theme" uri="https://www.jonmsterling.com/johnstone-1994/" display-uri="johnstone-1994" type="local">Johnstone</fr:link>. We contribute to the consolidation of SGDT by isolating the universal property of multi-clock guarded recursion as a modular construction that applies to any topos model of single-clock guarded recursion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route>
            <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta>
            <fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-cambridge/</fr:uri>
            <fr:display-uri>sterling-2023-cambridge</fr:display-uri>
            <fr:route>/sterling-2023-cambridge/</fr:route>
            <fr:title text="Crossing boundaries in program semantics">Crossing boundaries in program semantics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiaqido7bsry3bs2tnh5rtwa3ozf4wpm3zui46pneusslkxoh46nza.pdf</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The great semanticist John Reynolds famously wrote in 1983 that “type structure is a syntactic
discipline for enforcing levels of abstraction”. If the last twenty years of programming language
semantics and verification have taught us anything, it is that we also need a syntactic discipline
for breaking abstraction — in other words, a way to glue together programs and verifications that
cut across abstraction barriers.</html:p>
            <html:p>In programming language semantics and verification, the problem of combining multiple levels of
abstraction arises when choosing a “level of detail” at which to view program execution:
for instance, one could look at program execution as a detailed operational process of
discrete steps evincing the cost or complexity of an algorithm, or one could think of
it more abstractly as a black box that only sends inputs to outputs. The difficulty is
that in practice, verifications tend to cut across this barrier between complexity
and functional correctness: for instance, complexity bounds often depend on the
functional correctness of subroutines, and the existence of such a bound implies
termination (a correctness property).</html:p>
            <html:p>For this reason, it is crucial to develop integrated logical foundations for <html:strong>soundly</html:strong> reasoning
using multiple models of execution at the same time, even when they expose different facets of
a program's meaning. For the past three years, my research program has been to uncover and
exploit the basic “laws of motion” governing all such abstraction barriers, which has led
to the solution of a few significant open problems in homotopy type theory and modal type
theory, as well as some preliminary applications to security and cost analysis.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>2</fr:month>
              <fr:day>2</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2023-birmingham/</fr:uri>
            <fr:display-uri>sterling-2023-birmingham</fr:display-uri>
            <fr:route>/sterling-2023-birmingham/</fr:route>
            <fr:title text="New spaces for denotational semantics">New spaces for denotational semantics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmihzmtwc65afir3o7ttpmckh5xakkorwpwjj6x5eg4hascotp456ke.pdf</fr:meta>
            <fr:meta name="venue">University of Birmingham</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>12</fr:month>
              <fr:day>14</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-pujet-workshop/</fr:uri>
            <fr:display-uri>sterling-2022-pujet-workshop</fr:display-uri>
            <fr:route>/sterling-2022-pujet-workshop/</fr:route>
            <fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiajrzaq3g6iptivu37xqg6kfcxs32gvwnwqzrrzpp5g5cnvyhsfgy.pdf</fr:meta>
            <fr:meta name="venue">Workshop on Dependent Type Theory (to celebrate the Defense of <fr:link href="/lo%C3%AFcpujet/" title="Loïc Pujet" uri="https://www.jonmsterling.com/loïcpujet/" display-uri="loïcpujet" type="local">Loïc Pujet</fr:link>)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present a novel mechanism for <fr:link href="/gratzer-sterling-angiuli-coquand-birkedal-2022/" title="Controlling unfolding in type theory" uri="https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/" display-uri="gratzer-sterling-angiuli-coquand-birkedal-2022" type="local">controlling the unfolding of definitions in dependent type theory</fr:link>. Traditionally, proof assistants let users specify whether each definition can or cannot be unfolded in the remainder of a development; unfolding definitions is often necessary in order to reason about them, but an excess of unfolding can result in brittle proofs and intractably large proof goals. In our system, definitions are by default not unfolded, but users can selectively unfold them in a local manner. We justify our mechanism by means of elaboration to a core type theory with <html:em>extension types</html:em>, a connective first introduced in the context of homotopy type theory.  We prove a normalization theorem for our core calculus and have implemented our system in the cooltt proof assistant, providing both theoretical and practical evidence for it.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>11</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-itu/</fr:uri>
            <fr:display-uri>sterling-2022-itu</fr:display-uri>
            <fr:route>/sterling-2022-itu/</fr:route>
            <fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmigiix5np3fp4npmgxvmx7kl7nb52ieyiazbwdxh6amdbfxdhnp2fy.pdf</fr:meta>
            <fr:meta name="venue">Programming, Logic and Semantics, ITU Copenhagen</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines
<html:em>guarded recursion</html:em> (the "later" modality) with <html:em>impredicative polymorphism</html:em> (universal and existential types).
It turns out that these two features are sufficient to define a very simple denotational semantics for
System F with recursive types and higher-order store. We believe that the expressivity of iGDTT
brings us one step closer to a general metalanguage for realistic denotational semantics,
and provides a compelling strategy to elude the burden of operational semantics.
As a further benefit, we are now able to justify the extension of full dependent
type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>14</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-lr-tutorial/</fr:uri>
            <fr:display-uri>sterling-2022-lr-tutorial</fr:display-uri>
            <fr:route>/sterling-2022-lr-tutorial/</fr:route>
            <fr:title text="Practical semantics">Practical semantics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">/bafkrmiamyme2hydnyire7qbm4inkryyzvmdq24ahlfbvf3as4ulmgpbi4q.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri>
            <fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri>
            <fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route>
            <fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri>
            <fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri>
            <fr:route>/sterling-gratzer-birkedal-2022/</fr:route>
            <fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>10</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-existentials/</fr:uri>
            <fr:display-uri>sterling-2022-existentials</fr:display-uri>
            <fr:route>/sterling-2022-existentials/</fr:route>
            <fr:title text="Reflections on existential types">Reflections on existential types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{sterling-2022-existentials,
  doi = {10.48550/ARXIV.2210.00758},
  author = {Sterling, Jonathan},
  title = {Reflections on existential types},
  publisher = {arXiv},
  year = {2022},
  note = {Unpublished manuscript},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2210.00758</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Existential types are reconstructed in terms of <html:em>small reflective subuniverses</html:em> and dependent sums. The folklore decomposition detailed here gives rise to a particularly simple account of first class modules as a mode of use of traditional second class modules in connection with the modal operator induced by a reflective subuniverse, leading to a semantic justification for the rules of first-class modules in languages like OCaml and MoscowML.   Additionally, we expose several constructions that give rise to semantic models of ML-style programming languages with both first-class modules and realistic computational effects, culminating in a model that accommodates higher-order first class recursive modules <html:em>and</html:em> higher-order store.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>8</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-hottest-colloqium/</fr:uri>
            <fr:display-uri>sterling-2022-hottest-colloqium</fr:display-uri>
            <fr:route>/sterling-2022-hottest-colloqium/</fr:route>
            <fr:title text="How to code your own type theory">How to code your own type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="video">https://www.youtube.com/watch?v=DEj-_k2Nx6o</fr:meta>
            <fr:meta name="venue">Colloquium, HoTTEST Summer School 2022</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>There is a considerable distance between the formal rules of type theory and the code that you must write in order to animate them as a running program. In this colloquium, you will learn the basic techniques of type theoretic implementation in the OCaml programming language, including the representation of syntax as well as type-directed conversion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>6</fr:month>
              <fr:day>30</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-muri/</fr:uri>
            <fr:display-uri>sterling-2022-muri</fr:display-uri>
            <fr:route>/sterling-2022-muri/</fr:route>
            <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@misc{sterling-harper-2022-muri,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {\route-asset{assets/slides/sterling:2022:muri.pdf}},
  year = {2022},
  month = jun,
  note = {Talk given at the 2022 MURI Team Meeting},
  title = {Sheaf semantics of termination-insensitive noninterference},
}]]></fr:meta>
            <fr:meta name="slides">/bafkrmidn65xp7ewox6ka5uijltbkg5ikkuuuj5zid7viz5dbu35fx44qoq.pdf</fr:meta>
            <fr:meta name="venue">MURI Team Meeting 2022</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                <fr:display-uri>jms-005Z</fr:display-uri>
                <fr:route>/jms-005Z/</fr:route>
                <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>6</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-pps/</fr:uri>
            <fr:display-uri>sterling-2022-pps</fr:display-uri>
            <fr:route>/sterling-2022-pps/</fr:route>
            <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Proofs, Programs and Systems seminar (IRIF PPS)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>6</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri>
            <fr:display-uri>sterling-2022-naive</fr:display-uri>
            <fr:route>/sterling-2022-naive/</fr:route>
            <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta>
            <fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>5</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-wg6/</fr:uri>
            <fr:display-uri>sterling-2022-wg6</fr:display-uri>
            <fr:route>/sterling-2022-wg6/</fr:route>
            <fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@misc{sterling-2022-wg6,
  author = {Sterling, Jonathan},
  year = {2022},
  month = may,
  note = {WG6 kick-off meeting: Syntax and Semantics of Type Theories (Invited Talk)},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta>
            <fr:meta name="venue">WG6 kick-off meeting: Syntax and Semantics of Type Theories</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>4</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-bu-popv/</fr:uri>
            <fr:display-uri>sterling-2022-bu-popv</fr:display-uri>
            <fr:route>/sterling-2022-bu-popv/</fr:route>
            <fr:title text="Intrinsic semantics of termination-insensitive noninterference">Intrinsic semantics of termination-insensitive noninterference</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiakx5dlx7mjxgf2e3qfga4xmjbru46crc6ds52thmiktqyjri46n4.pdf</fr:meta>
            <fr:meta name="venue">Boston University POPV Seminar</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Security-typed programming languages aim to control the flow of high-security information to low security clients. Starting with Abadi et al.'s dependency core calculus, the denotational semantics of such languages has been dominated by an <html:strong>extrinsic</html:strong> approach in which an existing insecure model of computation (e.g. ordinary domains) is restricted by a logical relation of "indistinguishability" to prevent low-security outputs from depending on high-security inputs (noninterference). Thus in the extrinsic approach, security properties are bolted onto an insecure model by brute force, as it were. A more refined information flow policy called termination-insensitive noninterference allows high-security bits to be leaked through termination channels but not through return values; unfortunately, the adaptation of the extrinsic/relational semantics to this more relaxed policy is incompatible with the transitivity of the logical relation, contradicting the intuition of "indistinguishability".</html:p>
            <html:p>In contrast, an <html:strong>intrinsic</html:strong> semantics of security typing would involve a new computational model that evinces secure information flow and noninterference properties directly without any post hoc restriction by a logical relation. We contribute the first such intrinsic semantics of security typing in this sense by considering sheaves of dcpos on a space of abstract behaviors on which security classes arise as open/closed partitions; the security monads then arise as the <html:em>closed modalities</html:em> of topos theory that restrict a sheaf to its component over a closed subspace.</html:p>
            <html:p>An advantage of our intrinsic semantics is that termination-insensitive noninterference arises automatically from our computational model, namely the fact that the Sierpiński domain is not a constant sheaf; a further advantage is that our semantics is an instance of standard domain theoretic denotational semantics, albeit over a richer category of domains.</html:p>
            <html:p>(j.w.w. <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">R. Harper</fr:link>)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-bilimits/</fr:uri>
            <fr:display-uri>sterling-2022-bilimits</fr:display-uri>
            <fr:route>/sterling-2022-bilimits/</fr:route>
            <fr:title text="Bilimits in categories of partial maps">Bilimits in categories of partial maps</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-bilimits,
  author = {Sterling, Jonathan},
  year = {2022},
  month = feb,
  doi = {10.48550/arXiv.2202.08657},
  eprint = {2202.08657},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {Bilimits in categories of partial maps},
}]]></fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.08657</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The closure of chains of embedding-projection pairs (<html:em>ep-pairs</html:em>) under bilimits in some categories of predomains and domains is standard and well-known. For instance, Scott's D∞ construction is well-known to produce directed bilimits of ep-pairs in the category of directed-complete partial orders, and de Jong and Escardó have formalized this result in the constructive domain theory of a topos.  The explicit construction of bilimits for categories of predomains and <html:em>partial</html:em> maps is considerably murkier as far as constructivity is concerned; most expositions employ the constructive taboo that every lift-algebra is free, reducing the problem to the construction of bilimits in a category of pointed domains and strict maps. An explicit construction of the bilimit is proposed in the dissertation of Claire Jones, but no proof is given so it remained unclear if the category of dcpos and partial maps was closed under directed bilimits of ep-pairs in a topos. We provide a (Grothendieck)-topos-valid proof that the category of dcpos and partial maps between them is closed under bilimits; then we describe some applications toward models of axiomatic and synthetic domain theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-shulman-sterling-2022-plump/</fr:uri>
            <fr:display-uri>gratzer-shulman-sterling-2022-plump</fr:display-uri>
            <fr:route>/gratzer-shulman-sterling-2022-plump/</fr:route>
            <fr:title text="The directed plump ordering">The directed plump ordering</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-shulman-sterling-2022-plump,
  author = {Gratzer, Daniel and Shulman, Michael and Sterling, Jonathan},
  year = {2022},
  doi = {10.48550/arXiv.2202.07329},
  eprint = {2202.07329},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {The directed plump ordering},
}]]></fr:meta>
            <fr:meta name="artifact">https://www.jonmsterling.com/agda-directed-plump-ordering/</fr:meta>
            <fr:meta name="doi">10.48550/arXiv.2202.07329</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Based on Taylor's hereditarily directed plump ordinals, we define the <html:em>directed plump ordering</html:em> on W-types in Martin-Löf type theory. This ordering is similar to the plump ordering but comes equipped with non-empty finite joins in additional to the usual properties of the plump ordering.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>2</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2022/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2022</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2022/</fr:route>
            <fr:title text="A cubical language for Bishop sets">A cubical language for Bishop sets</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{sterling-angiuli-gratzer-2022,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  year = {2022},
  month = mar,
  doi = {10.46298/lmcs-18(1:43)2022},
  eprint = {2003.01491},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  issue = {1},
  journal = {Logical Methods in Computer Science},
  title = {{A Cubical Language for Bishop Sets}},
  volume = {18},
}]]></fr:meta>
            <fr:meta name="doi">10.46298/lmcs-18(1:43)2022</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/lmcs/" title="Logical Methods in Computer Science" uri="https://www.jonmsterling.com/lmcs/" display-uri="lmcs" type="local">Logical Methods in Computer Science</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present XTT, a version of Cartesian cubical type theory specialized for Bishop sets à la <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link>, in which every type enjoys a definitional version of the uniqueness of identity proofs. Using cubical notions, XTT reconstructs many of the ideas underlying Observational Type Theory, a version of intensional type theory that supports function extensionality. We prove the canonicity property of XTT (that every closed boolean is definitionally equal to a constant) by Artin gluing.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>1</fr:month>
              <fr:day>22</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2022-wits/</fr:uri>
            <fr:display-uri>sterling-2022-wits</fr:display-uri>
            <fr:route>/sterling-2022-wits/</fr:route>
            <fr:title text="Make three to throw away: frontiers in homotopical proof assistants">Make three to throw away: frontiers in homotopical proof assistants</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmifpq7uvabz7ktijuq24pfirediv7taikklozbeuqknhw3evm25pje.pdf</fr:meta>
            <fr:meta name="video">https://www.youtube.com/watch?v=lqBFq7aRReY</fr:meta>
            <fr:meta name="venue">Workshop on the Implementation of Type Systems (keynote)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>For six years, I have served as the founder and technical leader of the RedPRL Development Team which has produced three interactive proof assistants for variants of cubical type theory: RedPRL, redtt, and cooltt. I will share several lessons that we have learned about the design and implementation of homotopical proof assistants along this journey. This talk discusses joint work with <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>, <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>, <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Favonia</fr:link>, and Reed Mullanix.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/</fr:uri>
            <fr:display-uri>niu-sterling-grodin-harper-2022</fr:display-uri>
            <fr:route>/niu-sterling-grodin-harper-2022/</fr:route>
            <fr:title text="A cost-aware logical framework">A cost-aware logical framework</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 6, Issue POPL</fr:meta>
            <fr:meta name="doi">10.1145/3498670</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants.</html:p>
            <html:p>We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist’s method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid’s algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2022/</fr:uri>
            <fr:display-uri>sterling-harper-2022</fr:display-uri>
            <fr:route>/sterling-harper-2022/</fr:route>
            <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.5</fr:meta>
            <fr:meta name="venue">7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We propose a new sheaf semantics for secure information flow over a space of abstract behaviors, based on synthetic domain theory: security classes are open/closed partitions, types are sheaves, and redaction of sensitive information corresponds to restricting a sheaf to a closed subspace. Our security-aware computational model satisfies termination-insensitive noninterference automatically, and therefore constitutes an intrinsic alternative to state of the art extrinsic/relational models of noninterference. Our semantics is the latest application of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s recent re-interpretation of phase distinctions and noninterference in programming languages in terms of Artin gluing and topos-theoretic open/closed modalities. Prior applications include <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">parametricity for ML modules</fr:link>, the proof of normalization for cubical type theory by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link>, and the cost-aware logical framework of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu et al</fr:link>. In this paper we employ the phase distinction perspective twice: first to reconstruct the syntax and semantics of secure information flow as a lattice of phase distinctions between “higher” and “lower” security, and second to verify the computational adequacy of our sheaf semantics with respect to a version of Abadi et al.’s dependency core calculus to which we have added a construct for declassifying termination channels.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Y/</fr:uri>
                <fr:display-uri>jms-005Y</fr:display-uri>
                <fr:route>/jms-005Y/</fr:route>
                <fr:title text="Minor mistakes in sheaf semantics of noninterference">Minor mistakes in <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In the published version of this paper, there were a few mistakes that have been corrected in the local copy hosted here.</html:p>
                <html:ol><html:li>In the <html:em>Critique of relational semantics for information flow</html:em>, our discussion of the <html:em>Failure of monotonicity</html:em> stated incorrectly that algebras for the sealing monad at a higher security level could not be transformed into algebras for the sealing monad at a lower security level in the semantics of Abadi et al. This is not true, as pointed out to us privately by Carlos Tomé Cortiñas. What we meant to say was that it is not the case that a type whose component at a high security level is trivial shall always remain trivial at a lower security level.</html:li>
  <html:li>The original version of the extended edition of this paper, we claimed that the constructive existence of tensor products on pointed dcpos was obvious; in fact, tensor products do exist, but their construction involves a reflexive coequalizer of pointed dcpos.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                <fr:display-uri>jms-005Z</fr:display-uri>
                <fr:route>/jms-005Z/</fr:route>
                <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>12</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2021/</fr:uri>
            <fr:display-uri>sterling-harper-2021</fr:display-uri>
            <fr:route>/sterling-harper-2021/</fr:route>
            <fr:title text="Logical relations as types: proof-relevant parametricity for program modules">Logical relations as types: proof-relevant parametricity for program modules</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><fr:link href="/jacm/" title="Journal of the ACM" uri="https://www.jonmsterling.com/jacm/" display-uri="jacm" type="local">Journal of the ACM</fr:link>, Volume 68, Issue 6</fr:meta>
            <fr:meta name="doi">10.1145/3474834</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the <html:em>phase distinction</html:em>, <html:em>computational effects</html:em>, and <html:em>type abstraction</html:em>. We contribute a fresh “synthetic” take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a <html:em>lax modality</html:em> that encapsulates computational effects, placing <html:em>projectibility</html:em> of module expressions on a type-theoretic basis.</html:p>
            <html:p>Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a <html:em>parametricity structure</html:em>. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-<html:em>relevant</html:em> families, where there may be non-trivial evidence witnessing the relatedness of two programs—simplifying the metatheory of strong sums over the collection of types, for although there can be no “relation classifying relations,” one easily accommodates a “family classifying small families.”</html:p>
            <html:p>Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan <html:em>logical relations as types</html:em>, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic <html:em>Artin gluing</html:em> construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2021</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0060/</fr:uri>
                <fr:display-uri>jms-0060</fr:display-uri>
                <fr:route>/jms-0060/</fr:route>
                <fr:title text="Minor mistakes in logical relations as types">Minor mistakes in <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">logical relations as types</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>After going to press, we have fixed the following mistakes:</html:p>
                <html:ol><html:li>In the definition of a logos, we mistakenly said that "colimits commute with finite limits" but we meant to say that they are preserved by pullback. We thank <fr:link href="/sarahzrf/" title="Sarah Z. Rovner-Frydman" uri="https://www.jonmsterling.com/sarahzrf/" display-uri="sarahzrf" type="local">Sarah Z. Rovner-Frydman</fr:link> for noticing this mistake.</html:li>
  <html:li>In Remark 5.15, we used the notation for the closed immersion prior to introducing it.</html:li>
  <html:li>We have fixed a few broken links in the bibliography.</html:li></html:ol>
                <html:p>The local copy hosted here has the corrections implemented</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>11</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-ccl/</fr:uri>
            <fr:display-uri>sterling-2021-ccl</fr:display-uri>
            <fr:route>/sterling-2021-ccl/</fr:route>
            <fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmig65yyrnooa2ki3usvufg3gmrp24zw3u634erewg2pwgjpthnlksq.pdf</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The purpose of this talk is to pose the question, “What are the Euclid’s postulates for syntactic metatheory?”</html:p>
            <html:p>In the fourth century B.C.E., the Greek mathematician Euclid set down his famous postulates for plane geometry, explaining geometric shapes in terms of rules that govern their construction and incidence. The dialectical relationship between theories (axioms) and their models (coordinate systems) has been the driving force in the last two millennia of geometrical investigation.</html:p>
            <html:p>In logic and computer science, workers in the “syntactic metatheory” investigate questions that lie on the fringe between a theory and its models — definability, normalization, decidability, conservativity, computational adequacy, parametricity, type safety, etc. Dominant methods attack these questions by means of explicit computations (e.g. Kripke logical relations) which practitioners have found to be both reliable and somewhat opaque. In this talk, I introduce <html:em>Synthetic Tait computability</html:em> — a new system of axioms that transforms these explicit computations into synthetic manipulations; classical Kripke logical relations can be seen as models or “coordinate systems” for the new geometry of syntax that is beginning to unfold.</html:p>
            <html:p>Synthetic Tait computability has already been employed to positively resolve the normalization and decidability conjectures for cubical type theory, as well as a number of other recent results.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>11</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-logsem/</fr:uri>
            <fr:display-uri>sterling-2021-logsem</fr:display-uri>
            <fr:route>/sterling-2021-logsem/</fr:route>
            <fr:title text="Between abstraction and composition...">Between abstraction and composition...</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmibvdmy674htuxiv72zuvqwhdzjsygbcvw3zcishgnlucuoc3q35iq.pdf</fr:meta>
            <fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The fundamental contradiction of programming and program verification can be located in the tension between abstraction and composition. We make programs more abstract in order to prevent bad interactions between components; on the other side of the coin, we impede the composition of components when we abstract them. Modern programming practice evinces many distinct levels of abstraction that must be considered at the same time — for instance, compilers break module boundaries during linking, complexity analysis breaks the abstraction of extensional equivalence, and logical relations proofs break the abstraction of closure under substitution. What is needed to meet this challenge is linguistic tools that smoothly interpolate between these different levels of abstraction. Building on <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral dissertation</fr:link> and <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">joint work with Bob Harper</fr:link>, I introduce a new plan for modal programming languages and logics that treat the transition between different abstraction levels as a first-class notion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>10</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-muri/</fr:uri>
            <fr:display-uri>sterling-2021-muri</fr:display-uri>
            <fr:route>/sterling-2021-muri/</fr:route>
            <fr:title text="Normalization for (Cartesian) cubical type theory">Normalization for (Cartesian) cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmigc53m5m72p66jxbd7oxkvrl7irbrfxdjsatj2igngbm44a6g5cnq.pdf</fr:meta>
            <fr:meta name="venue">MURI Team Meeting 2021</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>9</fr:month>
              <fr:day>13</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-thesis/</fr:uri>
            <fr:display-uri>sterling-2021-thesis</fr:display-uri>
            <fr:route>/sterling-2021-thesis/</fr:route>
            <fr:title text="First steps in synthetic Tait computability: the objective metatheory of cubical type theory">First steps in synthetic Tait computability: the objective metatheory of cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Doctoral dissertation, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta>
            <fr:meta name="bibtex"><![CDATA[@phdthesis{sterling-2021-thesis,
  author = {Sterling, Jonathan},
  school = {Carnegie Mellon University},
  year = {2021},
  doi = {10.5281/zenodo.6990769},
  note = {Version 1.1, revised May 2022},
  number = {CMU-CS-21-142},
  title = {First Steps in Synthetic {Tait} Computability: The Objective Metatheory of Cubical Type Theory},
}]]></fr:meta>
            <fr:meta name="doi">10.5281/zenodo.6990769</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The implementation and semantics of dependent type theories can be studied in a syntax-independent way: the objective metatheory of dependent type theories exploits the universal properties of their syntactic categories to endow them with computational content, mathematical meaning, and practical implementation (normalization, type checking, elaboration). The semantic methods of the objective metatheory inform the design and implementation of correct-by-construction elaboration algorithms, promising a principled interface between real proof assistants and ideal mathematics.</html:p>
            <html:p>In this dissertation, I add synthetic Tait computability to the arsenal of the objective metatheorist. Synthetic Tait computability is a mathematical machine to reduce difficult problems of type theory and programming languages to trivial theorems of topos theory. First employed by <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link> to reconstruct the theory of program modules and their phase separated parametricity, synthetic Tait computability is deployed here to resolve the last major open question in the syntactic metatheory of cubical type theory: normalization of open terms.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>8</fr:month>
              <fr:day>24</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-ss/</fr:uri>
            <fr:display-uri>sterling-2021-cmu-ss</fr:display-uri>
            <fr:route>/sterling-2021-cmu-ss/</fr:route>
            <fr:title text="Abstraction, composition, and the phase distinction">Abstraction, composition, and the phase distinction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiauzlnmczowkvzdsbt3hw2hzxc35xoyii4qvpkg2cykqba7bu5pya.pdf</fr:meta>
            <fr:meta name="venue">CMU Speakers Club</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Programmers use abstraction to hide representation details from ourselves: either to avoid mistakes (e.g. confusing a list index with a length) or to exploit representation invariants (e.g. two implementations of the QUEUE interface are indistinguishable). These abstraction boundaries can unfortunately impede the linking of smaller program units into efficient composite programs, because compilers must exploit representation details in order to produce efficient code.  Sometimes seen as the "waterloo of separate compilation", the need to break abstraction is answered by whole-program analysis techniques that break all abstractions (as in the MLton compiler for Standard ML). Separate compilation, however, has a number of advantages including speed, parallelization, and elegance.</html:p>
            <html:p>We present an alternative type theoretic account of abstraction-breaking during compilation based on the famous phase distinction of ML languages; rather than distinguishing between compiletime and runtime, we focus on separating "devtime" from compiletime. Our framework allows the programmer to selectively reveal representation details to the compiler without giving up the representation independence properties guaranteed by "devtime" type correctness.  We also describe an application to the problem of printf-debugging, which is ordinarily obstructed by abstraction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>7</fr:month>
              <fr:day>7</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021/</fr:uri>
            <fr:display-uri>sterling-angiuli-2021</fr:display-uri>
            <fr:route>/sterling-angiuli-2021/</fr:route>
            <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)</fr:meta>
            <fr:meta name="doi">10.1109/LICS52264.2021.9470719</fr:meta>
            <fr:meta name="external">https://arxiv.org/abs/2101.11479</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. Our normalization result is reduction-free, in the sense of yielding a bijection between equivalence classes of terms in context and a tractable language of <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex>/<fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-normal forms. As corollaries we obtain both decidability of judgmental equality and the injectivity of type constructors.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>5</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-bhfs/</fr:uri>
            <fr:display-uri>sterling-2021-bhfs</fr:display-uri>
            <fr:route>/sterling-2021-bhfs/</fr:route>
            <fr:title text="Higher order functions and Brouwer’s Thesis">Higher order functions and Brouwer’s Thesis</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{sterling-2021-bhfs,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2021},
  doi = {10.1017/S0956796821000095},
  eprint = {1608.03814},
  eprintclass = {math.LO},
  eprinttype = {arXiv},
  journaltitle = {Journal of Functional Programming},
  note = {\emph{Bob Harper Festschrift Collection}},
  pages = {e11},
  title = {Higher order functions and Brouwer's thesis},
  volume = {31},
}]]></fr:meta>
            <fr:meta name="artifact">https://www.jonmsterling.com/agda-effectful-forcing/index.html</fr:meta>
            <fr:meta name="doi">10.1017/S0956796821000095</fr:meta>
            <fr:meta name="venue"><fr:link href="/jfp/" title="Journal of Functional Programming" uri="https://www.jonmsterling.com/jfp/" display-uri="jfp" type="local">Journal of Functional Programming</fr:link>, <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Bob Harper</fr:link> Festschrift Collection</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Extending <fr:link href="/martinescardo/" title="Martín Hötzel Escardó" uri="https://www.jonmsterling.com/martinescardo/" display-uri="martinescardo" type="local">Martín Hötzel Escardó</fr:link>’s effectful forcing technique, we give a new proof of a well-known result: Brouwer’s monotone bar theorem holds for any bar that can be realized by a functional of type <fr:tex display="inline"><![CDATA[{\mathopen {}\left (\mathbb {N}\to \mathbb {N}\right )\mathclose {}}\to \mathbb {N}]]></fr:tex> in Gödel’s System T. Effectful forcing is an elementary alternative to standard sheaf-theoretic forcing arguments, using ideas from programming languages, including computational effects, monads, the algebra interpretation of call-by-name λ-calculus, and logical relations. Our argument proceeds by interpreting System T programs as well-founded dialogue trees whose nodes branch on a query to an oracle of type <fr:tex display="inline"><![CDATA[\mathbb {N}\to \mathbb {N}]]></fr:tex>, lifted to higher type along a call-by-name translation. To connect this interpretation to the bar theorem, we then show that Brouwer’s famous "mental constructions" of barhood constitute an invariant form of these dialogue trees in which queries to the oracle are made maximally and in order.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>5</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-padova/</fr:uri>
            <fr:display-uri>sterling-angiuli-2021-padova</fr:display-uri>
            <fr:route>/sterling-angiuli-2021-padova/</fr:route>
            <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Padova Logic Seminar</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application <html:code>(p @ i)</html:code> ceases to be neutral within its “locus of instability” <html:code>∂(i)</html:code> and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables <html:code>x : A</html:code> and dimensions <html:code>i : 𝕀</html:code>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-au-ccs/</fr:uri>
            <fr:display-uri>sterling-2021-au-ccs</fr:display-uri>
            <fr:route>/sterling-2021-au-ccs/</fr:route>
            <fr:title text="Logical relations as types">Logical relations as types</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmiafb2gihhkx6w3wjzpfzs5bvjxmjospi4wuhgnszcmuq3j6w4lyue.pdf</fr:meta>
            <fr:meta name="video">https://www.youtube.com/watch?v=AEthjg2k718</fr:meta>
            <fr:meta name="venue">CCS Colloquium, Augusta University</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
              <html:em>This is joint work with <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:em>
            </html:p>
            <html:p>How do you prove that two implementations of an abstract type behave the same in all configurations? Reynolds famously employed logical relations to establish such results; roughly, a logical relation is a structure-respecting relation between two interpretations of a theory that evinces, in the base case, a desirable invariant.</html:p>
            <html:p>We present a synthetic way to understand and interact with logical relations, related to classical logical relations in the same way that Euclidean geometry relates to point-sets. Previously a logical relation was defined in terms of the (complicated) details of how it is constructed as a certain kind of relation over syntax. We instead take the simpler view that everything in sight is a logical relation, and then use modalities to isolate those logical relations that are degenerate in either the syntactic or the semantic direction.</html:p>
            <html:p>Our “logical relations as types” principle has led to a new account of modules and representation independence <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">(S., Harper)</fr:link>, as well as the first proofs of normalization for cubical type theory <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">(S., Angiuli)</fr:link> and general multi-modal dependent type theory <fr:link href="/gratzer-2022/" title="Normalization for multimodal type theory" uri="https://www.jonmsterling.com/gratzer-2022/" display-uri="gratzer-2022" type="local">(Gratzer)</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>2</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-hott/</fr:uri>
            <fr:display-uri>sterling-2021-cmu-hott</fr:display-uri>
            <fr:route>/sterling-2021-cmu-hott/</fr:route>
            <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Pittsburgh's HoTT Seminar</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application p(i) ceases to be neutral within its “locus of instability” ∂(i) and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables x : A and dimensions i : 𝕀.</html:p>
            <html:p>(j.w.w. <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>.)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2021-mlw/</fr:uri>
            <fr:display-uri>sterling-harper-2021-mlw</fr:display-uri>
            <fr:route>/sterling-harper-2021-mlw/</fr:route>
            <fr:title text="A metalanguage for multi-phase modularity">A metalanguage for multi-phase modularity</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-harper-2021-mlw,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {https://icfp21.sigplan.org/details/mlfamilyworkshop-2021-papers/5/A-metalanguage-for-multi-phase-modularity},
  year = {2021},
  month = aug,
  note = {ML 2021 abstract and talk},
  title = {A metalanguage for multi-phase modularity},
}]]></fr:meta>
            <fr:meta name="slides">/bafkrmigp2ekztc4xgmcxoxv7mxawb33zro6apew2m54hmctdosmregbpha.pdf</fr:meta>
            <fr:meta name="video">https://www.youtube.com/watch?v=5kWS-umBA7k</fr:meta>
            <fr:meta name="venue">ML Family Workshop</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Type abstraction, the phase distinction, and computational effects all play an important role in the design and implementation of ML-style module systems. We propose a simple type theoretic metalanguage <html:strong>φML</html:strong> for multi-phase modularity in which these concepts are treated individually, supporting the definition of high-level modular constructs such as generative and applicative functors, as well as all extant forms of structure sharing.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-ct/</fr:uri>
            <fr:display-uri>sterling-angiuli-2021-ct</fr:display-uri>
            <fr:route>/sterling-angiuli-2021-ct/</fr:route>
            <fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmie6j57qqrx6av73q6ropesavo76e57fcttaxm6t7qyhzpsyhjazjm.pdf</fr:meta>
            <fr:meta name="video">https://www.youtube.com/watch?v=AhivFjnBakE</fr:meta>
            <fr:meta name="venue">Category Theory 2021</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>12</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-2020/</fr:uri>
            <fr:display-uri>gratzer-sterling-2020</fr:display-uri>
            <fr:route>/gratzer-sterling-2020/</fr:route>
            <fr:title text="Syntactic categories for dependent type theory: sketching and adequacy">Syntactic categories for dependent type theory: sketching and adequacy</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-2020,
  author = {Gratzer, Daniel and Sterling, Jonathan},
  year = {2020},
  eprint = {2012.10783},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {Syntactic categories for dependent type theory: sketching and adequacy},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We argue that locally Cartesian closed categories form a suitable doctrine for defining dependent type theories, including non-extensional ones. Using the theory of sketches, one may define syntactic categories for type theories in a style that resembles the use of Martin-Löf's Logical Framework, following the "judgments as types" principle. The concentration of type theories into their locally Cartesian closed categories of judgments is particularly convenient for proving syntactic metatheorems by semantic means (canonicity, normalization, etc.). Perhaps surprisingly, the notion of a context plays no role in the definitions of type theories in this sense, but the structure of a class of display maps can be imposed on a theory post facto wherever needed, as advocated by the Edinburgh school and realized by the <html:code>worlds</html:code> declarations of the Twelf proof assistant.</html:p>
            <html:p>Uemura has proposed representable map categories together with a stratified logical framework for similar purposes. The stratification in Uemura's framework restricts the use of dependent products to be strictly positive, in contrast to the tradition of Martin-Löf's logical framework and Schroeder-Heister's analysis of higher-level deductions. We prove a semantic adequacy result for locally Cartesian closed categories relative to Uemura's representable map categories: if a theory is definable in the framework of Uemura, the locally Cartesian closed category that it generates is a conservative (fully faithful) extension of its syntactic representable map category. On this basis, we argue for the use of locally Cartesian closed categories as a simpler alternative to Uemura's representable map categories.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>6</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2020-epa/</fr:uri>
            <fr:display-uri>sterling-2020-epa</fr:display-uri>
            <fr:route>/sterling-2020-epa/</fr:route>
            <fr:title text=" redtt and the future of Cartesian cubical type theory"><![CDATA[ redtt]]> and the future of Cartesian cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="video">https://vimeo.com/425917591</fr:meta>
            <fr:meta name="venue">Every Proof Assistant</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>redtt is an interactive proof assistant for Cartesian cubical type theory, a version of Martin-Löf type theory featuring computational versions of function extensionality, higher inductive types, and univalence. Building on ideas from Epigram, Agda, and Idris, redtt introduces a new cubical take on interactive proof development with holes. We will first introduce the basics of cubical type theory and then dive into an interactive demonstration of redtt’s features and its mathematical library.</html:p>
            <html:p>After this we will catch a first public glimpse of the future of redtt, a new prototype that our team is building currently code-named "cooltt": cooltt introduces syntax to split on disjunctions of cofibrations in arbitrary positions, implementing the full definitional eta law for disjunction. While cooltt is still in the early stages, it already has full support for univalence and cubical interactive proof development.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>3</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2020-muri/</fr:uri>
            <fr:display-uri>sterling-2020-muri</fr:display-uri>
            <fr:route>/sterling-2020-muri/</fr:route>
            <fr:title text="(cubical) computability structures">(cubical) computability structures</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmigerogwvkxuabfo24lqf5fnbd7mebab6vh3citv7bvcgc7cqyqpmy.pdf</fr:meta>
            <fr:meta name="venue">MURI Team Meeting 2020</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>3</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2020-hottest/</fr:uri>
            <fr:display-uri>sterling-2020-hottest</fr:display-uri>
            <fr:route>/sterling-2020-hottest/</fr:route>
            <fr:title text="Objective metatheory of dependent type theories">Objective metatheory of dependent type theories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmih22ghxxcrk6747rxh5o3lwiua6ioweqt5dtxsuegz6c2u2roco5u.pdf</fr:meta>
            <fr:meta name="video">https://www.youtube.com/watch?v=cyBn-lkvXTc</fr:meta>
            <fr:meta name="venue">Homotopy Type Theory Electronic Seminar Talks</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>What type theorists and other researchers in type theory have in common is that they study theorems that hold of the initial model of type theory; but type theorists especially emphasize the theorems whose statements are sufficiently non-type-theoretic that they need not be preserved by homomorphisms of models. These theorems, sometimes called "metatheorems" or "admissibilities", are the means by which we conceive and justify computerized implementations of type theory, including canonicity, normalization, and decidability of type checking and judgmental equality.</html:p>
            <html:p>The main tool for proving such theorems is Tait's method of computability, which has in the past several years been subject to a rapid campaign of rectification using the categorical language of Artin gluing. I will give an overview of this brave new "objective computability", emphasizing my recent joint work with Angiuli and Gratzer on a general gluing theorem for models of MLTT along flat functors into Grothendieck topoi, with an application to cubical type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2020</fr:year>
              <fr:month>1</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-2020/</fr:uri>
            <fr:display-uri>sterling-angiuli-2020</fr:display-uri>
            <fr:route>/sterling-angiuli-2020/</fr:route>
            <fr:title text="Gluing models of type theory along flat functors">Gluing models of type theory along flat functors</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">/bafkrmiccwetsrjk6rbtoexh7up6djbemy2zvujsqohyzj7nllau5vceydq.pdf</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We extend the theory of Artin gluing to strict dependent type theory: given a flat functor F : C → E from the category of contexts a model of Martin-Löf type theory into a Grothendieck topos E, we may construct the F-computability families model of type theory. Our theorem extends to MLTT with a (strict, weak) universe à la Tarski if E may be equipped with a (strict, weak) universe à la Tarski.</html:p>
            <html:p>We introduce a more tractable approach to gluing models of type theory, working primarily within a suitably enlarged category of computability families which are not all tracked by syntactical entities, but which is densely generated by the subcategory of such computability families.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
              <fr:month>4</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-2019-cmu-hott/</fr:uri>
            <fr:display-uri>sterling-2019-cmu-hott</fr:display-uri>
            <fr:route>/sterling-2019-cmu-hott/</fr:route>
            <fr:title text="Algebraic type theory and the gluing construction">Algebraic type theory and the gluing construction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">
              <fr:link href="/jms-010U/" title="CMU HoTT Seminar" uri="https://www.jonmsterling.com/jms-010U/" display-uri="jms-010U" type="local">CMU HoTT Seminar</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-hott/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019-hott</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019-hott/</fr:route>
            <fr:title text="Cubical exact equality and categorical gluing">Cubical exact equality and categorical gluing</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmih2orgei2hellqbaqzwubjlulc2osk46d4s7dpkazlxzgt3oe77n4.pdf</fr:meta>
            <fr:meta name="venue">International Conference on Homotopy Type Theory, 2019</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory which extends intensional type theory with a dependent equality type that enjoys function extensionality and judgmental unicity of identity proofs. XTT employs a variant of the Cartesian cubical Kan operations satisfying regularity (i.e., transport in constant type families is judgmentally constant), allowing its equality type to model Martin-Lof’s identity type judgmentally. We prove canonicity for the initial model of XTT (i.e., any closed term of boolean type is equal to either true or false) using a novel cubical extension (independently proposed by <fr:link href="/steveawodey/" title="Steve Awodey" uri="https://www.jonmsterling.com/steveawodey/" display-uri="steveawodey" type="local">Awodey</fr:link>) of the categorical gluing technique inspired by <fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Coquand</fr:link> and <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Shulman</fr:link>, in which we glue the fundamental fibration of a category of augmented Cartesian cubical sets along a cubical nerve. We conjecture that our methods will extend to open terms, allowing us to establish normalization and decidability of the typing relation.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019/</fr:route>
            <fr:title text="Cubical syntax for reflection-free extensional equality">Cubical syntax for reflection-free extensional equality</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-angiuli-gratzer-2019,
  author = {Sterling, Jonathan and Angiuli, Carlo and Gratzer, Daniel},
  editor = {Geuvers, Herman},
  location = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  url = {http://drops.dagstuhl.de/opus/volltexte/2019/10538},
  booktitle = {Proceedings of the 4th International Conference on Formal Structures for Computation and Deduction (FSCD 2019)},
  date = {2019},
  doi = {10.4230/LIPIcs.FSCD.2019.31},
  eprint = {1904.08562},
  eprinttype = {arXiv},
  isbn = {978-3-95977-107-8},
  issn = {1868-8969},
  pages = {31:1--31:25},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {Cubical Syntax for Reflection-Free Extensional Equality},
  volume = {131},
}]]></fr:meta>
            <fr:meta name="slides">/bafkrmicj5w5dosexdar6vzylw5hykvpeqrydvy4cp6llywqf7auioli4fu.pdf</fr:meta>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2019.31</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/fscd-2019/" title="FSCD ’19: International Conference on Formal Structures for Computation and Deduction" uri="https://www.jonmsterling.com/fscd-2019/" display-uri="fscd-2019" type="local"><html:em>FSCD ’19</html:em>: International Conference on Formal Structures for Computation and Deduction</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We contribute XTT, a cubical reconstruction of Observational Type Theory [Altenkirch et al., 2007] which extends Martin-Löf's intensional type theory with a dependent equality type that enjoys function extensionality and a judgmental version of the unicity of identity proofs principle (UIP): any two elements of the same equality type are judgmentally equal. Moreover, we conjecture that the typing relation can be decided in a practical way. In this paper, we establish an algebraic canonicity theorem using a novel extension of the logical families or categorical gluing argument inspired by <fr:link href="/coquand-2019/" title="Canonicity and normalization for dependent type theory" uri="https://www.jonmsterling.com/coquand-2019/" display-uri="coquand-2019" type="local">Coquand</fr:link> and <fr:link href="/shulman-2015-elegant/" title="The univalence axiom for elegant Reedy presheaves" uri="https://www.jonmsterling.com/shulman-2015-elegant/" display-uri="shulman-2015-elegant" type="local">Shulman</fr:link>: every closed element of boolean type is derivably equal to either true or false.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/gratzer-sterling-birkedal-2019/</fr:uri>
            <fr:display-uri>gratzer-sterling-birkedal-2019</fr:display-uri>
            <fr:route>/gratzer-sterling-birkedal-2019/</fr:route>
            <fr:title text="Implementing a modal dependent type theory">Implementing a modal dependent type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@article{gratzer-sterling-birkedal-2019,
  author = {Gratzer, Daniel and Sterling, Jonathan and Birkedal, Lars},
  location = {New York, NY, USA},
  publisher = {ACM},
  date = {2019-07},
  doi = {10.1145/3341711},
  issn = {2475-1421},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  keywords = {Modal types,dependent types,normalization by evaluation,type-checking},
  number = {ICFP},
  pages = {107:1--107:29},
  title = {Implementing a Modal Dependent Type Theory},
  volume = {3},
}]]></fr:meta>
            <fr:meta name="doi">10.1145/3341711</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/icfp-2019/" title="ICFP ’19: The 24th ACM SIGPLAN International Conference on Functional Programming" uri="https://www.jonmsterling.com/icfp-2019/" display-uri="icfp-2019" type="local"><html:em>ICFP ’19</html:em>: The 24th ACM SIGPLAN International Conference on Functional Programming</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Modalities are everywhere in programming and mathematics! Despite this, however, there are still significant technical challenges in formulating a core dependent type theory with modalities. We present a dependent type theory MLTT🔒 supporting the connectives of standard Martin-Löf Type Theory as well as an S4-style necessity operator. MLTT🔒 supports a smooth interaction between modal and dependent types and provides a common basis for the use of modalities in programming and in synthetic mathematics. We design and prove the soundness and completeness of a type checking algorithm for MLTT🔒, using a novel extension of normalization by evaluation. We have also implemented our algorithm in a prototype proof assistant for MLTT🔒, demonstrating the ease of applying our techniques.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2019</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-angiuli-gratzer-2019-types/</fr:uri>
            <fr:display-uri>sterling-angiuli-gratzer-2019-types</fr:display-uri>
            <fr:route>/sterling-angiuli-gratzer-2019-types/</fr:route>
            <fr:title text="XTT: cubical syntax for extensional equality (without equality reflection)">XTT: cubical syntax for extensional equality (without equality reflection)</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmifuhsbmtkvovprpvqpzzeg63w6bp46g73yb6nz53l2wnslrumnkaa.pdf</fr:meta>
            <fr:meta name="venue">TYPES 2019</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/basspitters/" title="Bas Spitters" uri="https://www.jonmsterling.com/basspitters/" display-uri="basspitters" type="local">Bas Spitters</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2018</fr:year>
              <fr:month>9</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-spitters-2018/</fr:uri>
            <fr:display-uri>sterling-spitters-2018</fr:display-uri>
            <fr:route>/sterling-spitters-2018/</fr:route>
            <fr:title text="Normalization by gluing for free λ-theories">Normalization by gluing for free λ-theories</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@unpublished{sterling-spitters-2018,
  author = {Sterling, Jonathan and Spitters, Bas},
  year = {2018},
  month = sep,
  eprint = {1809.08646},
  eprintclass = {cs.LO},
  eprinttype = {arXiv},
  title = {Normalization by gluing for free $\lambda$-theories},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Kuen-Bang Hou (Favonia)</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/andersm%C3%B6rtberg/" title="Anders Mörtberg" uri="https://www.jonmsterling.com/andersmörtberg/" display-uri="andersmörtberg" type="local">Anders Mörtberg</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2018</fr:year>
              <fr:month>8</fr:month>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/redtt-2018-dagstuhl/</fr:uri>
            <fr:display-uri>redtt-2018-dagstuhl</fr:display-uri>
            <fr:route>/redtt-2018-dagstuhl/</fr:route>
            <fr:title text=" redtt: implementing cartesian cubical type theory"><![CDATA[ redtt]]>: implementing cartesian cubical type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="slides">/bafkrmidvxp7uolkpqxsifdgktfy5filu7kgxdh5bohnldrwtcqaqxcaggi.pdf</fr:meta>
            <fr:meta name="venue">Dagstuhl Seminar 18341: Formalization of Mathematics in Type Theory</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2018</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2018/</fr:uri>
            <fr:display-uri>sterling-harper-2018</fr:display-uri>
            <fr:route>/sterling-harper-2018/</fr:route>
            <fr:title text="Guarded computational type theory">Guarded computational type theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-harper-2018,
 author = {Sterling, Jonathan and Harper, Robert},
 title = {Guarded Computational Type Theory},
 booktitle = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
 series = {LICS '18},
 year = {2018},
 isbn = {978-1-4503-5583-4},
 location = {Oxford, United Kingdom},
 pages = {879--888},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/3209108.3209153},
 doi = {10.1145/3209108.3209153},
 acmid = {3209153},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {clocks, dependent types, guarded recursion, operational semantics, type theory},
}]]></fr:meta>
            <fr:meta name="slides">/bafkrmie3t5ai2zxuejiwtnjln2d2aixnjqhqqifmu63oz4leeikydgbghu.pdf</fr:meta>
            <fr:meta name="doi">10.1145/3209108.3209153</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/lics-2018/" title="LICS ’18: 33rd Annual ACM/IEEE Symposium on Logic in Computer Science" uri="https://www.jonmsterling.com/lics-2018/" display-uri="lics-2018" type="local"><html:em>LICS ’18</html:em>: 33rd Annual ACM/IEEE Symposium on Logic in Computer Science</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p><fr:link href="/nakano-2000/" title="A modality for recursion" uri="https://www.jonmsterling.com/nakano-2000/" display-uri="nakano-2000" type="local">Nakano</fr:link>’s later modality can be used to specify and define recursive functions which are causal or synchronous; in concert with a notion of clock variable, it is possible to also capture the broader class of productive (co)programs. Until now, it has been difficult to combine these constructs with dependent types in a way that preserves the operational meaning of type theory and admits a hierarchy of universes. We present an operational account of guarded dependent type theory with clocks called Guarded Computational Type Theory, featuring a novel clock intersection connective that enjoys the clock irrelevance principle, as well as a predicative hierarchy of universes which does not require any indexing in clock contexts. Guarded Computational Type Theory is simultaneously a programming language with a rich specification logic, as well as a computational metalanguage that can be used to develop semantics of other languages and logics.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/evancavallo/" title="Evan Cavallo" uri="https://www.jonmsterling.com/evancavallo/" display-uri="evancavallo" type="local">Evan Cavallo</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/favonia/" title="Kuen-Bang Hou (Favonia)" uri="https://www.jonmsterling.com/favonia/" display-uri="favonia" type="local">Kuen-Bang Hou (Favonia)</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2018</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/redprl-2018-lfmtp/</fr:uri>
            <fr:display-uri>redprl-2018-lfmtp</fr:display-uri>
            <fr:route>/redprl-2018-lfmtp/</fr:route>
            <fr:title text="The RedPRL proof assistant">The RedPRL proof assistant</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{redprl-2018-lfmtp,
  author = {Angiuli, Carlo and Cavallo, Evan and {Hou (Favonia)}, Kuen-Bang and Harper, Robert and Sterling, Jonathan},
  editor = {Blanqui, Fr\'{e}d\'{e}ric and Reis, Giselle},
  publisher = {Open Publishing Association},
  booktitle = {Proceedings of the 13th International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice, LFMTP@FSCD 2018, Oxford, UK, 7th July 2018.},
  date = {2018},
  doi = {10.4204/EPTCS.274.1},
  pages = {1--10},
  title = {{The \textsf{\textcolor[rgb]{.91,.31,.27}{Red}PRL} Proof Assistant (Invited Paper)}},
}]]></fr:meta>
            <fr:meta name="doi">10.4204/EPTCS.274.1</fr:meta>
            <fr:meta name="venue">International Workshop on Logical Frameworks and Meta-Languages: Theory and Practice (LFMTP), 2018</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>RedPRL is an experimental proof assistant based on Cartesian cubical computational type theory, a new type theory for higher-dimensional constructions inspired by homotopy type theory. In the style of Nuprl, RedPRL users employ tactics to establish behavioral properties of cubical functional programs embodying the constructive content of proofs. Notably, RedPRL implements a two-level type theory, allowing an extensional, proof-irrelevant notion of exact equality to coexist with a higher-dimensional proof-relevant notion of paths.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>Rebecca Valentine</fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2016</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/valentine-sterling-2016/</fr:uri>
            <fr:display-uri>valentine-sterling-2016</fr:display-uri>
            <fr:route>/valentine-sterling-2016/</fr:route>
            <fr:title text="Dependent types for pragmatics">Dependent types for pragmatics</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@inbook{valentine-sterling-2016,
  author={Valentine, Rebecca and Sterling, Jonathan},
  editor={Redmond, Juan and Pombo Martins, Olga and Nepomuceno Fern{\'a}ndez, {\'A}ngel},
  title={Dependent Types for Pragmatics},
  booktitle={Epistemology, Knowledge and the Impact of Interaction},
  year={2016},
  publisher={Springer International Publishing},
  address={Cham},
  pages={123--139},
  isbn={978-3-319-26506-3},
  doi={10.1007/978-3-319-26506-3_4},
}]]></fr:meta>
            <fr:meta name="doi">10.1007/978-3-319-26506-3_4</fr:meta>
            <fr:meta name="venue">In: Redmond J., Pombo Martins O., Nepomuceno Fernández Á. (eds) Epistemology, Knowledge and the Impact of Interaction. Logic, Epistemology, and the Unity of Science, vol 38. Springer, Cham.</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In this paper, we present an extension to Martin-Löf’s Intuitionistic Type Theory which gives natural solutions to problems in pragmatics, such as pronominal reference and presupposition. Our approach also gives a simple account of donkey anaphora without resorting to exotic scope extension of the sort used in Discourse Representation Theory and Dynamic Semantics, thanks to the proof-relevant nature of type theory.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:backmatter>
</fr:tree>
