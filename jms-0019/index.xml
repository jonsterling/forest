<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2023</fr:year>
      <fr:month>1</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-0019/</fr:uri>
    <fr:display-uri>jms-0019</fr:display-uri>
    <fr:route>/jms-0019/</fr:route>
    <fr:title text="Chapter 8: a plan for PL">Chapter 8: a plan for PL</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>This dissertation has focused almost solely on the development and applications of synthetic Tait computability in the context of pure type theory, but the author originally invented synthetic Tait computability to solve problems in core programming languages, as part of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s re-analysis of the <html:em>phase distinction</html:em> in <fr:link href="/harper-mitchell-moggi-1990/" title="Higher-order modules and the phase distinction" uri="https://www.jonmsterling.com/harper-mitchell-moggi-1990/" display-uri="harper-mitchell-moggi-1990" type="local">ML-style</fr:link> <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">module systems</fr:link> between static (compiletime) and dynamic (runtime) code. The purpose of this chapter is to identify several applications of synthetic Tait computability to core programming languages, and set an agenda for future work — some of which has been executed and published following the completion of this dissertation</html:p>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2023</fr:year>
          <fr:month>1</fr:month>
          <fr:day>19</fr:day>
        </fr:date>
        <fr:uri>https://www.jonmsterling.com/jms-001A/</fr:uri>
        <fr:display-uri>jms-001A</fr:display-uri>
        <fr:route>/jms-001A/</fr:route>
        <fr:title text="§ 8.1: two phase distinctions for program modules">§ 8.1: two phase distinctions for program modules</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>A brief overview is given of the applications of synthetic Tait computability to program modules, material that is published in the <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Journal of the ACM</fr:link>.</html:p>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2023</fr:year>
          <fr:month>1</fr:month>
          <fr:day>19</fr:day>
        </fr:date>
        <fr:uri>https://www.jonmsterling.com/jms-001B/</fr:uri>
        <fr:display-uri>jms-001B</fr:display-uri>
        <fr:route>/jms-001B/</fr:route>
        <fr:title text="§ 8.2: type refinements and program extraction">§ 8.2: type refinements and program extraction</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>The modal language of synthetic Tait computability promises a new and more abstract account of <html:em>refinement types</html:em> and <html:em>program extraction</html:em> via a phase distinction between <html:em>computation</html:em> and <html:em>specification</html:em>. Refinement types are often thought of as a kind of subtype, but there is a fundamental difference: when <fr:tex display="inline"><![CDATA[{\phi }\sqsubset {A}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\psi }\sqsubset {B}]]></fr:tex> are refinements of types <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> respectively, then <fr:tex display="inline"><![CDATA[\phi \to \psi ]]></fr:tex> refines <fr:tex display="inline"><![CDATA[A\to  B]]></fr:tex>. In contrast, subtyping laws for function spaces are contravariant in the domain. The refinements available in synthetic Tait computability are moreover proof-relevant in the sense that specification-level code can contain data in addition to properties. The application to proof-relevant refinement types is employed by <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu, Sterling, Grodin, and Harper</fr:link> to develop a logical framework for simultaneously verifying behavior and complexity of functional programs.</html:p>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2023</fr:year>
          <fr:month>1</fr:month>
          <fr:day>20</fr:day>
        </fr:date>
        <fr:uri>https://www.jonmsterling.com/jms-001C/</fr:uri>
        <fr:display-uri>jms-001C</fr:display-uri>
        <fr:route>/jms-001C/</fr:route>
        <fr:title text="§ 8.3: information-flow and noninterference">§ 8.3: information-flow and noninterference</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>Finally, an application of synthetic Tait computability to <html:em>security</html:em> and <html:em>information flow control</html:em> is identified: a security class is a phase distinction between low and high security. The preliminary results presented in this section have been substantially improved upon by <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">Sterling and Harper</fr:link>, adding support for general recursion and termination-insensitive noninterference by combining synthetic Tait computability with <fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link>.</html:p>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/</fr:uri>
            <fr:display-uri>niu-sterling-grodin-harper-2022</fr:display-uri>
            <fr:route>/niu-sterling-grodin-harper-2022/</fr:route>
            <fr:title text="A cost-aware logical framework">A cost-aware logical framework</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 6, Issue POPL</fr:meta>
            <fr:meta name="doi">10.1145/3498670</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants.</html:p>
            <html:p>We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist’s method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid’s algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2022</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2022/</fr:uri>
            <fr:display-uri>sterling-harper-2022</fr:display-uri>
            <fr:route>/sterling-harper-2022/</fr:route>
            <fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.5</fr:meta>
            <fr:meta name="venue">7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We propose a new sheaf semantics for secure information flow over a space of abstract behaviors, based on synthetic domain theory: security classes are open/closed partitions, types are sheaves, and redaction of sensitive information corresponds to restricting a sheaf to a closed subspace. Our security-aware computational model satisfies termination-insensitive noninterference automatically, and therefore constitutes an intrinsic alternative to state of the art extrinsic/relational models of noninterference. Our semantics is the latest application of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s recent re-interpretation of phase distinctions and noninterference in programming languages in terms of Artin gluing and topos-theoretic open/closed modalities. Prior applications include <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">parametricity for ML modules</fr:link>, the proof of normalization for cubical type theory by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link>, and the cost-aware logical framework of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu et al</fr:link>. In this paper we employ the phase distinction perspective twice: first to reconstruct the syntax and semantics of secure information flow as a lattice of phase distinctions between “higher” and “lower” security, and second to verify the computational adequacy of our sheaf semantics with respect to a version of Abadi et al.’s dependency core calculus to which we have added a construct for declassifying termination channels.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Y/</fr:uri>
                <fr:display-uri>jms-005Y</fr:display-uri>
                <fr:route>/jms-005Y/</fr:route>
                <fr:title text="Minor mistakes in sheaf semantics of noninterference">Minor mistakes in <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In the published version of this paper, there were a few mistakes that have been corrected in the local copy hosted here.</html:p>
                <html:ol><html:li>In the <html:em>Critique of relational semantics for information flow</html:em>, our discussion of the <html:em>Failure of monotonicity</html:em> stated incorrectly that algebras for the sealing monad at a higher security level could not be transformed into algebras for the sealing monad at a lower security level in the semantics of Abadi et al. This is not true, as pointed out to us privately by Carlos Tomé Cortiñas. What we meant to say was that it is not the case that a type whose component at a high security level is trivial shall always remain trivial at a lower security level.</html:li>
  <html:li>The original version of the extended edition of this paper, we claimed that the constructive existence of tensor products on pointed dcpos was obvious; in fact, tensor products do exist, but their construction involves a reflexive coequalizer of pointed dcpos.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>17</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri>
                <fr:display-uri>jms-005Z</fr:display-uri>
                <fr:route>/jms-005Z/</fr:route>
                <fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2021</fr:year>
              <fr:month>12</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/sterling-harper-2021/</fr:uri>
            <fr:display-uri>sterling-harper-2021</fr:display-uri>
            <fr:route>/sterling-harper-2021/</fr:route>
            <fr:title text="Logical relations as types: proof-relevant parametricity for program modules">Logical relations as types: proof-relevant parametricity for program modules</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue"><fr:link href="/jacm/" title="Journal of the ACM" uri="https://www.jonmsterling.com/jacm/" display-uri="jacm" type="local">Journal of the ACM</fr:link>, Volume 68, Issue 6</fr:meta>
            <fr:meta name="doi">10.1145/3474834</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the <html:em>phase distinction</html:em>, <html:em>computational effects</html:em>, and <html:em>type abstraction</html:em>. We contribute a fresh “synthetic” take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a <html:em>lax modality</html:em> that encapsulates computational effects, placing <html:em>projectibility</html:em> of module expressions on a type-theoretic basis.</html:p>
            <html:p>Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a <html:em>parametricity structure</html:em>. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-<html:em>relevant</html:em> families, where there may be non-trivial evidence witnessing the relatedness of two programs—simplifying the metatheory of strong sums over the collection of types, for although there can be no “relation classifying relations,” one easily accommodates a “family classifying small families.”</html:p>
            <html:p>Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan <html:em>logical relations as types</html:em>, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic <html:em>Artin gluing</html:em> construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2021</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0060/</fr:uri>
                <fr:display-uri>jms-0060</fr:display-uri>
                <fr:route>/jms-0060/</fr:route>
                <fr:title text="Minor mistakes in logical relations as types">Minor mistakes in <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">logical relations as types</fr:link></fr:title>
                <fr:taxon>Erratum</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>After going to press, we have fixed the following mistakes:</html:p>
                <html:ol><html:li>In the definition of a logos, we mistakenly said that "colimits commute with finite limits" but we meant to say that they are preserved by pullback. We thank <fr:link href="/sarahzrf/" title="Sarah Z. Rovner-Frydman" uri="https://www.jonmsterling.com/sarahzrf/" display-uri="sarahzrf" type="local">Sarah Z. Rovner-Frydman</fr:link> for noticing this mistake.</html:li>
  <html:li>In Remark 5.15, we used the notation for the closed immersion prior to introducing it.</html:li>
  <html:li>We have fixed a few broken links in the bibliography.</html:li></html:ol>
                <html:p>The local copy hosted here has the corrections implemented</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/martinhyland/" title="Martin Hyland" uri="https://www.jonmsterling.com/martinhyland/" display-uri="martinhyland" type="local">Martin Hyland</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1991</fr:year>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/hyland-1991/</fr:uri>
            <fr:display-uri>hyland-1991</fr:display-uri>
            <fr:route>/hyland-1991/</fr:route>
            <fr:title text="First steps in synthetic domain theory">First steps in synthetic domain theory</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">Category Theory (Como, 1990)</fr:meta>
            <fr:meta name="doi">10.1007/BFb0084217</fr:meta>
            <fr:meta name="bibtex"><![CDATA[@inproceedings{hyland-1991,
  author = {Hyland, J. M. E.},
  editor = {Carboni, Aurelio and Pedicchio, Maria Cristina and Rosolini, Guiseppe},
  address = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  booktitle = {Category Theory},
  year = {1991},
  isbn = {978-3-540-46435-8},
  pages = {131--156},
  title = {First steps in synthetic domain theory},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>
              </fr:author>
              <fr:author>John C. Mitchell</fr:author>
              <fr:author>
                <fr:link href="/eugeniomoggi/" title="Eugenio Moggi" uri="https://www.jonmsterling.com/eugeniomoggi/" display-uri="eugeniomoggi" type="local">Eugenio Moggi</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1989</fr:year>
              <fr:month>12</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/harper-mitchell-moggi-1990/</fr:uri>
            <fr:display-uri>harper-mitchell-moggi-1990</fr:display-uri>
            <fr:route>/harper-mitchell-moggi-1990/</fr:route>
            <fr:title text="Higher-order modules and the phase distinction">Higher-order modules and the phase distinction</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1145/96709.96744</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In earlier work, we used a typed function calculus, XML, with dependent types to analyze several aspects of the Standard ML type system. In this paper, we introduce a refinement of XML with a clear compile-time/run-time phase distinction, and a direct compile-time type checking algorithm. The calculus uses a finer separation of types into universes than XML and enforces the phase distinction using a nonstandard equational theory for module and signature expressions. While unusual from a type-theoretic point of view, the nonstandard equational theory arises naturally from the well-known Grothendieck construction on an indexed category.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/eugeniomoggi/" title="Eugenio Moggi" uri="https://www.jonmsterling.com/eugeniomoggi/" display-uri="eugeniomoggi" type="local">Eugenio Moggi</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1989</fr:year>
              <fr:month>1</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/moggi-1989/</fr:uri>
            <fr:display-uri>moggi-1989</fr:display-uri>
            <fr:route>/moggi-1989/</fr:route>
            <fr:title text="A category-theoretic account of program modules">A category-theoretic account of program modules</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="doi">10.1007/BFb0018347</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The type-theoretic explanation of modules proposed to date (for programming languages like ML) is unsatisfactory, in that it fails to reflect the distinction between compile-time, when type-expressions are evaluated, and run-time, when value-expressions are evaluated. This paper proposes a new explanation based on “programming languages as indexed categories” and illustrates, as an application, how ML should be extended to support higher order modules. The paper also outlines a methodology for a modular approach to programming languages, where programming languages (of a certain kind) are identified with objects in a 2-category and features are viewed as 2-categorical notions.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0018/</fr:uri>
            <fr:display-uri>jms-0018</fr:display-uri>
            <fr:route>/jms-0018/</fr:route>
            <fr:title text="Part V: prospects">Part V: prospects</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>1</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0019/</fr:uri>
                <fr:display-uri>jms-0019</fr:display-uri>
                <fr:route>/jms-0019/</fr:route>
                <fr:title text="Chapter 8: a plan for PL">Chapter 8: a plan for PL</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>This dissertation has focused almost solely on the development and applications of synthetic Tait computability in the context of pure type theory, but the author originally invented synthetic Tait computability to solve problems in core programming languages, as part of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s re-analysis of the <html:em>phase distinction</html:em> in <fr:link href="/harper-mitchell-moggi-1990/" title="Higher-order modules and the phase distinction" uri="https://www.jonmsterling.com/harper-mitchell-moggi-1990/" display-uri="harper-mitchell-moggi-1990" type="local">ML-style</fr:link> <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">module systems</fr:link> between static (compiletime) and dynamic (runtime) code. The purpose of this chapter is to identify several applications of synthetic Tait computability to core programming languages, and set an agenda for future work — some of which has been executed and published following the completion of this dissertation</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001A/</fr:uri>
                    <fr:display-uri>jms-001A</fr:display-uri>
                    <fr:route>/jms-001A/</fr:route>
                    <fr:title text="§ 8.1: two phase distinctions for program modules">§ 8.1: two phase distinctions for program modules</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A brief overview is given of the applications of synthetic Tait computability to program modules, material that is published in the <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Journal of the ACM</fr:link>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>19</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001B/</fr:uri>
                    <fr:display-uri>jms-001B</fr:display-uri>
                    <fr:route>/jms-001B/</fr:route>
                    <fr:title text="§ 8.2: type refinements and program extraction">§ 8.2: type refinements and program extraction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The modal language of synthetic Tait computability promises a new and more abstract account of <html:em>refinement types</html:em> and <html:em>program extraction</html:em> via a phase distinction between <html:em>computation</html:em> and <html:em>specification</html:em>. Refinement types are often thought of as a kind of subtype, but there is a fundamental difference: when <fr:tex display="inline"><![CDATA[{\phi }\sqsubset {A}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\psi }\sqsubset {B}]]></fr:tex> are refinements of types <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> respectively, then <fr:tex display="inline"><![CDATA[\phi \to \psi ]]></fr:tex> refines <fr:tex display="inline"><![CDATA[A\to  B]]></fr:tex>. In contrast, subtyping laws for function spaces are contravariant in the domain. The refinements available in synthetic Tait computability are moreover proof-relevant in the sense that specification-level code can contain data in addition to properties. The application to proof-relevant refinement types is employed by <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu, Sterling, Grodin, and Harper</fr:link> to develop a logical framework for simultaneously verifying behavior and complexity of functional programs.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>1</fr:month>
                      <fr:day>20</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-001C/</fr:uri>
                    <fr:display-uri>jms-001C</fr:display-uri>
                    <fr:route>/jms-001C/</fr:route>
                    <fr:title text="§ 8.3: information-flow and noninterference">§ 8.3: information-flow and noninterference</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Finally, an application of synthetic Tait computability to <html:em>security</html:em> and <html:em>information flow control</html:em> is identified: a security class is a phase distinction between low and high security. The preliminary results presented in this section have been substantially improved upon by <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">Sterling and Harper</fr:link>, adding support for general recursion and termination-insensitive noninterference by combining synthetic Tait computability with <fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
