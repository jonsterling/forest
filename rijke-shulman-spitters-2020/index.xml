<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/egbertrijke/" title="Egbert Rijke" uri="https://www.jonmsterling.com/egbertrijke/" display-uri="egbertrijke" type="local">Egbert Rijke</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/mikeshulman/" title="Mike Shulman" uri="https://www.jonmsterling.com/mikeshulman/" display-uri="mikeshulman" type="local">Mike Shulman</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/basspitters/" title="Bas Spitters" uri="https://www.jonmsterling.com/basspitters/" display-uri="basspitters" type="local">Bas Spitters</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2020</fr:year>
      <fr:month>1</fr:month>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/rijke-shulman-spitters-2020/</fr:uri>
    <fr:display-uri>rijke-shulman-spitters-2020</fr:display-uri>
    <fr:route>/rijke-shulman-spitters-2020/</fr:route>
    <fr:title text="Modalities in homotopy type theory">Modalities in homotopy type theory</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="venue">
      <fr:link href="/lmcs/" title="Logical Methods in Computer Science" uri="https://www.jonmsterling.com/lmcs/" display-uri="lmcs" type="local">Logical Methods in Computer Science</fr:link>
    </fr:meta>
    <fr:meta name="doi">10.23638/LMCS-16(1:2)2020</fr:meta>
    <fr:meta name="bibtex"><![CDATA[@article{rijke-shulman-spitters-2020,
  author = {Rijke, Egbert and Shulman, Michael and Spitters, Bas},
  year = {2020},
  month = jan,
  doi = {10.23638/LMCS-16(1:2)2020},
  issue = {1},
  journal = {Logical Methods in Computer Science},
  title = {Modalities in homotopy type theory},
  volume = {16},
}]]></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>11</fr:month>
              <fr:day>20</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00F1/</fr:uri>
            <fr:display-uri>jms-00F1</fr:display-uri>
            <fr:route>/jms-00F1/</fr:route>
            <fr:title text="Type theoretic structure on natural models">Type theoretic structure on <fr:link href="/jms-00E4/" title="Algebraic description of natural models" uri="https://www.jonmsterling.com/jms-00E4/" display-uri="jms-00E4" type="local">natural models</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <fr:link href="/jms-00E4/" title="Algebraic description of natural models" uri="https://www.jonmsterling.com/jms-00E4/" display-uri="jms-00E4" type="local">natural model</fr:link> consists of (exactly) the judgmental structure of Martin-Löf type theory, without any connectives or basic types or terms. Here we will explore how structure is imposed on a given <fr:link href="/jms-00E4/" title="Algebraic description of natural models" uri="https://www.jonmsterling.com/jms-00E4/" display-uri="jms-00E4" type="local">natural model</fr:link>.</html:p>
            <html:p>In Martin-Löf type theory, a connective is usually described as being specified by (1) a formation rule, (2) introduction rules, (3) elimination rules, (4) computation rules, and (5) uniqueness rules. This schema is deceptively simple, as there are a number of places where additional complexity arises:</html:p>
            <html:ol><html:li>Some types have projection-style eliminators, like those of <fr:tex display="inline"><![CDATA[\Pi ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex> types.</html:li>
  <html:li>Some types have lifting-style eliminators, like that of the booleans.</html:li>
  <html:li>Some lifting-style eliminators are dependent, like that of the booleans.</html:li>
  <html:li>Other lifting-style eliminators are non-dependent, like that of a <fr:link href="/rijke-shulman-spitters-2020/" title="Modalities in homotopy type theory" uri="https://www.jonmsterling.com/rijke-shulman-spitters-2020/" display-uri="rijke-shulman-spitters-2020" type="local">reflective subuniverse that is not <fr:tex display="inline"><![CDATA[\Sigma ]]></fr:tex>-closed</fr:link>, such as the subuniverse of predomains in a model of <fr:link href="/hyland-1991/" title="First steps in synthetic domain theory" uri="https://www.jonmsterling.com/hyland-1991/" display-uri="hyland-1991" type="local">synthetic domain theory</fr:link>.</html:li>
  <html:li>Some lifting-style eliminators draw their motives of elimination from the ambient natural model, and others place more restrictions (as in the case of a reflective subuniverse).</html:li>
  <html:li>Some parameters of a formation rule are held fixed during elimination, and others are not.</html:li>
  <html:li>Some eliminators have judgmental (strict) uniqueness laws, others do not.</html:li></html:ol>
            <html:p>It is our goal to develop a framework that smoothly handles all of these possibilities. As all the possible parameters pertain to elimination and uniqueness laws, it is natural to consider the <html:em>formation and introduction rules</html:em> as the basic data of a type theoretic connective, and then the different ways in which a natural model can be closed under such a connective.</html:p>
            <html:p>In categorical terms, the formation and introduction rules for a connective <fr:tex display="inline"><![CDATA[K]]></fr:tex> can be understood in terms of a single map <fr:tex display="inline"><![CDATA[{I}\xrightarrow {{\pi }}{F}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\operatorname {Pr}{\mathcal {C}}]]></fr:tex>: the base <fr:tex display="inline"><![CDATA[F]]></fr:tex> represents the premises of the formation rule, and the total space <fr:tex display="inline"><![CDATA[I]]></fr:tex> represents the premises of the introduction rule. The projection itself reflects the fact that, in type theoretic terms, an introduction rule for a given connective presupposes that the premises of the formation rule are satisfied.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F3/</fr:uri>
                <fr:display-uri>jms-00F3</fr:display-uri>
                <fr:route>/jms-00F3/</fr:route>
                <fr:title text="The dependent product connective">The dependent product connective</fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The formation rule for dependent products fixes a type <fr:tex display="inline"><![CDATA[\Gamma \vdash  A]]></fr:tex> together with a family of types <fr:tex display="inline"><![CDATA[\Gamma .A\vdash  B]]></fr:tex> indexed in <fr:tex display="inline"><![CDATA[A]]></fr:tex>. The introduction rule further assumes an element <fr:tex display="inline"><![CDATA[\Gamma .A \vdash  b : B]]></fr:tex>. The corresponding <html:em>connective</html:em> can therefore be described as the projection <fr:tex display="inline"><![CDATA[{{\mathopen {}\left \langle p\right \rangle \mathclose {}}E}\xrightarrow {{{\mathopen {}\left \langle p\right \rangle \mathclose {}}p}}{{\mathopen {}\left \langle p\right \rangle \mathclose {}}U}]]></fr:tex> where <fr:tex display="inline"><![CDATA[{\operatorname {Pr}{\mathcal {C}}}\xrightarrow {{{\mathopen {}\left \langle p\right \rangle \mathclose {}}}}{\operatorname {Pr}{\mathcal {C}}}]]></fr:tex> is the polynomial endofunctor <fr:tex display="inline"><![CDATA[U_!\circ  p_*\circ  E^*]]></fr:tex> associated to <fr:tex display="inline"><![CDATA[{E}\xrightarrow {{p}}{U}]]></fr:tex>. In type theoretic language, <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle p\right \rangle \mathclose {}}U]]></fr:tex> classifies <html:em>families of types</html:em>, and <fr:tex display="inline"><![CDATA[{\mathopen {}\left \langle p\right \rangle \mathclose {}}E]]></fr:tex> classifies families of types equipped with a section.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F4/</fr:uri>
                <fr:display-uri>jms-00F4</fr:display-uri>
                <fr:route>/jms-00F4/</fr:route>
                <fr:title text="The boolean connective">The boolean connective</fr:title>
                <fr:taxon>Example</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The formation rule for the boolean type has no premises whatsoever; there are exactly two introduction forms which each have no premises. Therefore, the boolean <html:em>connective</html:em> is described by the map <fr:tex display="inline"><![CDATA[{\mathbf {2}}\xrightarrow {{!}}{\mathbf {1}}]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F7/</fr:uri>
                <fr:display-uri>jms-00F7</fr:display-uri>
                <fr:route>/jms-00F7/</fr:route>
                <fr:title text="Left lifting structures">Left lifting structures</fr:title>
                <fr:taxon>Definition</fr:taxon>
                <fr:meta name="source">
                  <fr:link href="/awodey-2018-mscs/" title="Natural models of homotopy type theory" uri="https://www.jonmsterling.com/awodey-2018-mscs/" display-uri="awodey-2018-mscs" type="local">[awodey-2018-mscs]</fr:link>
                </fr:meta>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[{U}\xrightarrow {{l}}{V}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{r}}{B}]]></fr:tex> be two morphisms in a category <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> with pullbacks, such that <fr:tex display="inline"><![CDATA[U,V]]></fr:tex> are exponentiable. Working in the codomain bifibration of <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex>, we consider the vertical factor of the square <fr:tex display="inline"><![CDATA[{p^V}\xrightarrow {{p^f}}{p^U}]]></fr:tex> as depicted below:</html:p>
 
  
  <html:figure><fr:resource hash="11057bfdd601b5e1777ce2a6946af29f"><fr:resource-content><html:img src="/11057bfdd601b5e1777ce2a6946af29f.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    height = 1.5cm,
    nw = A^V,
    sw = B^V,
    west = p^V,
    ne = A^U,
    se = B^U,
    east = p^U,
    south = B^f,
    north = A^f,
  }
  \qquad 
  \begin {tikzpicture}[diagram,baseline=(sq/sw.base)]
    \SpliceDiagramSquare <sq/>{
      ne = p^U,
      se = B^U,
      sw = A^U,
      nw = {\mathopen {}\left (f^U\right )\mathclose {}}^*p^U,
      south = f^U,
      north = h_{p^f},
      nw/style = pullback,
      west/style = lies over,
      east/style = lies over,
      north/node/style = upright desc,
      width = 2.5cm,
      height = 1.5cm,
    }
    \node [above = of sq/nw] (nw) {$p^V$};
    \draw [->] (nw) to node[sloped,above] {$p^f$} (sq/ne);
    \draw [->,exists] (nw) to node[upright desc] {$v_{p^f}$} (sq/nw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>A <html:em>(weak, strong) left lifting structure</html:em> for <fr:tex display="inline"><![CDATA[{U}\xrightarrow {{l}}{V}]]></fr:tex> against <fr:tex display="inline"><![CDATA[{A}\xrightarrow {{r}}{B}]]></fr:tex> is then defined to be a (section, inverse) to the vertical factor <fr:tex display="inline"><![CDATA[{p^V}\xrightarrow {{v_{p^f}}}{{\mathopen {}\left (f^U\right )\mathclose {}}^*p^U}]]></fr:tex> in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/A^U}]]></fr:tex> depicted above — or equivalently a (section, inverse) to the underlying morphism in <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> of the vertical factor.</html:p></fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F9/</fr:uri>
                <fr:display-uri>jms-00F9</fr:display-uri>
                <fr:route>/jms-00F9/</fr:route>
                <fr:title text="Type theoretic connective">Type theoretic connective</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>A <html:em>type theoretic connective</html:em> is defined to be a pair of maps <fr:tex display="inline"><![CDATA[I\xrightarrow {\pi }F\xrightarrow {\phi }P]]></fr:tex> in which the first factor represents the projection of formation data from introduction data, and the second factor identifies the <html:em>fixed parameters</html:em> of the elimination rule.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F5/</fr:uri>
                <fr:display-uri>jms-00F5</fr:display-uri>
                <fr:route>/jms-00F5/</fr:route>
                <fr:title text="Formation squares for connectives">Formation squares for connectives</fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>An <html:em>formation square</html:em> for a <fr:link href="/jms-00F9/" title="Type theoretic connective" uri="https://www.jonmsterling.com/jms-00F9/" display-uri="jms-00F9" type="local">type theoretic connective</fr:link> <fr:tex display="inline"><![CDATA[I\xrightarrow {\pi }F\xrightarrow {\phi }P]]></fr:tex> in a family <fr:tex display="inline"><![CDATA[{E}\xrightarrow {{p}}{B}]]></fr:tex> is defined to be a commuting square <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{\alpha }}{p}]]></fr:tex> as depicted schematically below:</html:p>
 
  
  <html:figure><fr:resource hash="63a07b7982d0859c25e2780be1da0559"><fr:resource-content><html:img src="/63a07b7982d0859c25e2780be1da0559.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <sq/>{
      nw = I,
      sw = F,
      ne = E,
      se = U,
      east = p,
      west = \pi ,
      south = \alpha _F,
      north = \alpha _I,
      south/style = {exists,->},
      north/style = {exists,->},
      height = 1.5cm,
    }
    \node [below = 1.5cm of sq/sw] (sw) {$P$};
    \draw [->] (sq/sw) to node[left] {$\phi $} (sw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F6/</fr:uri>
                <fr:display-uri>jms-00F6</fr:display-uri>
                <fr:route>/jms-00F6/</fr:route>
                <fr:title text="Eliminators for formation squares">Eliminators for <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation squares</fr:link></fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[{E}\xrightarrow {{p}}{U}]]></fr:tex> be a morphism in a category <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> with pullbacks, and let <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{\alpha }}{p}]]></fr:tex> be a <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> for a <fr:link href="/jms-00F9/" title="Type theoretic connective" uri="https://www.jonmsterling.com/jms-00F9/" display-uri="jms-00F9" type="local">connective</fr:link> <fr:tex display="inline"><![CDATA[I\xrightarrow {\pi }F\xrightarrow {\phi }P]]></fr:tex>. Working in the codomain bifibration of <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex>, we consider the <html:em>vertical factor</html:em> of the <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{v_\alpha }}{\alpha _F^*p}]]></fr:tex> of the square <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{\alpha }}{p}]]></fr:tex>:</html:p>
 
  
  <html:figure><fr:resource hash="7ac50735a4bbda21d8739e56601038f9"><fr:resource-content><html:img src="/7ac50735a4bbda21d8739e56601038f9.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <sq/>{
      nw/style = pullback,
      nw = \alpha _F^*p,
      ne = p,
      se = U,
      sw = F,
      south = \alpha _F,
      north = h_\alpha ,
      west/style = lies over,
      east/style = lies over,
      north/node/style = upright desc,
      width = 2.5cm,
      height = 1.5cm,
    }
    \node [above = of sq/nw] (nw) {$\pi $};
    \draw [->] (nw) to node[sloped,above] {$\alpha $} (sq/ne);
    \draw [->,exists] (nw) to node[upright desc] {$v_\alpha $} (sq/nw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Write <fr:tex display="inline"><![CDATA[{{\mathcal {E}}_{/F}}\xrightarrow {{\phi _!}}{{\mathcal {E}}_{/P}}]]></fr:tex> for the induced cocartesian lifting (postcomposition) functor.</html:p><html:ol><html:li>An <html:em>absolute eliminator</html:em> is defined to be an inverse to <fr:tex display="inline"><![CDATA[{\phi _!\pi }\xrightarrow {{\phi _!v_\alpha }}{\phi _!F}]]></fr:tex> in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/P}]]></fr:tex>.</html:li>
  <html:li>A <html:em>(weak, strong) eliminator</html:em> is defined to be a (weak, strong) left lifting structure for <fr:tex display="inline"><![CDATA[{\phi _!\pi }\xrightarrow {{\phi _!v_\alpha }}{\phi _!F}]]></fr:tex> against <fr:tex display="inline"><![CDATA[{P^*E}\xrightarrow {{P^*p}}{P^*U}]]></fr:tex> in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/P}]]></fr:tex>.</html:li></html:ol></fr:mainmatter>
            </fr:tree>
            <html:p>We can define the structure of recursors in terms of eliminators. To be very clear, we are <html:em>not</html:em> demonstrating the (obvious) fact that a recursor can be implemented using a eliminator: we are saying that a recursor for one <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> is <html:em>precisely the same thing</html:em> as a eliminator for a <html:em>different</html:em> <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> in a different category.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00F8/</fr:uri>
                <fr:display-uri>jms-00F8</fr:display-uri>
                <fr:route>/jms-00F8/</fr:route>
                <fr:title text="Recursors for formation squares">Recursors for <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation squares</fr:link></fr:title>
                <fr:taxon>Definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[{E}\xrightarrow {{p}}{U}]]></fr:tex> be a morphism in a category <fr:tex display="inline"><![CDATA[\mathcal {E}]]></fr:tex> with pullbacks, and let <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{\alpha }}{p}]]></fr:tex> be a <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> for a <fr:link href="/jms-00F9/" title="Type theoretic connective" uri="https://www.jonmsterling.com/jms-00F9/" display-uri="jms-00F9" type="local">connective</fr:link> <fr:tex display="inline"><![CDATA[I\xrightarrow {\pi }F\xrightarrow {\phi }P]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[{U^*I}\xrightarrow {{v}}{p}]]></fr:tex> be the following vertical factor in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/U}]]></fr:tex>:</html:p>
 
  
  <html:figure><fr:resource hash="d562da05bcfd86f99bda3010561e7c6e"><fr:resource-content><html:img src="/d562da05bcfd86f99bda3010561e7c6e.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <sq/>{
      nw = p,
      ne = E,
      se = 1,
      sw = U,
      south = !_U,
      nw/style = pullback,
      north = U^\dagger  E,
      west/style = lies over,
      east/style = lies over,
      height = 1.5cm,
    }
    \node [above = 1.5cm of sq/nw] (nw) {$U^*I$};
    \node [right = of nw] (ne) {$I$};
    \draw [->] (nw) to node[above] {$U^\dagger  I$} (ne);
    \draw [->] (ne) to node[right] {$\alpha _I$} (sq/ne);
    \draw [->,exists] (nw) to node[left] {$v$}  (sq/nw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
<html:p>Let <fr:tex display="inline"><![CDATA[{F}\xrightarrow {{\phi }}{P}]]></fr:tex> be a further morphism. An <html:em>(absolute, weak, strong) recursor for <fr:tex display="inline"><![CDATA[{\pi }\xrightarrow {{\alpha }}{p}]]></fr:tex> with <fr:tex display="inline"><![CDATA[{F}\xrightarrow {{\phi }}{P}]]></fr:tex> fixed</html:em> is defined to be an (absolute, weak, strong) eliminator for the following <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> in <fr:tex display="inline"><![CDATA[{\mathcal {E}}_{/U}]]></fr:tex>:</html:p>
 
  
  <html:figure><fr:resource hash="75cd3f10ba0a92fdd0dd67224968c5e9"><fr:resource-content><html:img src="/75cd3f10ba0a92fdd0dd67224968c5e9.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \begin {tikzpicture}[diagram]
    \SpliceDiagramSquare <sq/>{
      nw = U^*I,
      sw = U^*F,
      ne = p,
      se = 1_{U},
      west = U^*\pi ,
      east = !_p,
      south = !_{U^*F},
      north = v,
      height = 1.5cm,
    }
    \node [below = 1.5cm of sq/sw] (sw) {$U^*P$};
    \draw [->] (sq/sw) to node[left] {$U^*\phi $} (sw);
  \end {tikzpicture}
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>11</fr:month>
                  <fr:day>20</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-00FA/</fr:uri>
                <fr:display-uri>jms-00FA</fr:display-uri>
                <fr:route>/jms-00FA/</fr:route>
                <fr:title text="Comparing different kinds of eliminators">Comparing different kinds of <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">eliminators</fr:link></fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We summarise the basic relationship between the different kinds of eliminators.</html:p>
                <html:ol><html:li><fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">Absolute eliminators</fr:link> correspond to <html:em>projection-style</html:em> elimination rules, whereas <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">(strong, weak)</fr:link> correspond to <html:em>lifting-style</html:em> elimination rules (with, without) judgmental uniqueness rules.</html:li>
  <html:li><fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">Absolute and strong eliminators</fr:link> are unique whenever they exist.</html:li>
  <html:li><fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">Weak eliminators</fr:link> are not strictly unique, but they form a <html:em>contractible space</html:em> in the sense of homotopy as determined by an identity type; when this identity type satisfies equality reflection, then, the <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">weak eliminators</fr:link> become <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">strong</fr:link>.</html:li>
  <html:li>If a <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">formation square</fr:link> has an <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">absolute eliminator</fr:link>, then it has a <fr:link href="/jms-00F5/" title="Formation squares for connectives" uri="https://www.jonmsterling.com/jms-00F5/" display-uri="jms-00F5" type="local">strong eliminator</fr:link>. Although the converse holds in many specific examples, it does not hold in general.</html:li>
  <html:li>An <fr:link href="/jms-00F8/" title="Recursors for formation squares" uri="https://www.jonmsterling.com/jms-00F8/" display-uri="jms-00F8" type="local">absolute recursor</fr:link> can be upgraded to an <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">absolute eliminator</fr:link>.</html:li>
  <html:li>In the presence of dependent sums and (strong, weak) identity types, a <fr:link href="/jms-00F8/" title="Recursors for formation squares" uri="https://www.jonmsterling.com/jms-00F8/" display-uri="jms-00F8" type="local">(strong, weak) recursor</fr:link> can be upgraded to a <fr:link href="/jms-00F6/" title="Eliminators for formation squares" uri="https://www.jonmsterling.com/jms-00F6/" display-uri="jms-00F6" type="local">(strong, weak) eliminator</fr:link>.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>17</fr:day>
            </fr:date>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>4</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-01AO/</fr:uri>
            <fr:display-uri>jms-01AO</fr:display-uri>
            <fr:route>/jms-01AO/</fr:route>
            <fr:title text="Weeknotes 2025-W16 › Jem Lord at HoTT/UF in Genoa"><fr:link href="/2025-W16/" title="Weeknotes 2025-W16" uri="https://www.jonmsterling.com/2025-W16/" display-uri="2025-W16" type="local">Weeknotes 2025-W16</fr:link> › <fr:link href="/jemlord/" title="Jem Lord" uri="https://www.jonmsterling.com/jemlord/" display-uri="jemlord" type="local">Jem Lord</fr:link> at <fr:link href="/hott-uf-2025/" title="HoTT-UF ’25: Workshop on Homotopy Type Theory/ Univalent Foundations" uri="https://www.jonmsterling.com/hott-uf-2025/" display-uri="hott-uf-2025" type="local">HoTT/UF</fr:link> in Genoa</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>My first-year PhD student <fr:link href="/jemlord/" title="Jem Lord" uri="https://www.jonmsterling.com/jemlord/" display-uri="jemlord" type="local">Jem Lord</fr:link> presented <fr:link href="https://hott-uf.github.io/2025/abstracts/HoTTUF_2025_paper_21.pdf" type="external">their work on <html:em>Easy Parametricity</html:em></fr:link> at the <fr:link href="/hott-uf-2025/" title="HoTT-UF ’25: Workshop on Homotopy Type Theory/ Univalent Foundations" uri="https://www.jonmsterling.com/hott-uf-2025/" display-uri="hott-uf-2025" type="local">HoTT/UF</fr:link> workshop in Genoa this week. Although I was not able to come in person, a little birdy told me that Jem gave a very good talk, so I’m proud of them for that. Congratulations, Jem!</html:p>
            <html:p>Jem’s work concerns a very simple parametricity axiom for a universe <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:math> in type theory: namely, that every <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:math>-small type <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:mrow></mml:math> be <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:math>-null in the sense of <fr:link href="/rijke-shulman-spitters-2020/" title="Modalities in homotopy type theory" uri="https://www.jonmsterling.com/rijke-shulman-spitters-2020/" display-uri="rijke-shulman-spitters-2020" type="local">Rijke, Shulman and Spitters</fr:link>. This is a mathematical way to say that small types “cannot see” their universe; another way to phrase it is that every function <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">f</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi></mml:mrow></mml:math> for <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">A</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:mrow></mml:math> is constant. One of Jem’s results, which has a startling proof(!), is that when <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">C</mml:mi></mml:math> is a category that is complete with respect to certain <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:math>-small diagrams and <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">D</mml:mi></mml:math> is locally <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">U</mml:mi></mml:math>-small category, any “unnatural” transformation between functors <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mrow xmlns:mml="http://www.w3.org/1998/Math/MathML"><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">F</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">,</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">G</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">:</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">C</mml:mi><mml:mo xmlns:mml="http://www.w3.org/1998/Math/MathML">→</mml:mo><mml:mi xmlns:mml="http://www.w3.org/1998/Math/MathML">D</mml:mi></mml:mrow></mml:math> is automatically natural. Many similar results can be obtained in the same way.</html:p>
            <html:p>There are a variety of models of these axioms. One example is the impredicative universe of modest types within a category of assemblies, which is the “standard” categorical model of both System F and the original calculus of constructions. The same principle will work within <fr:link href="/uemura-2019-types/" title="Cubical assemblies, a univalent and impredicative universe and a failure of propositional resizing" uri="https://www.jonmsterling.com/uemura-2019-types/" display-uri="uemura-2019-types" type="local">cubical assemblies</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/lmcs/</fr:uri>
            <fr:display-uri>lmcs</fr:display-uri>
            <fr:route>/lmcs/</fr:route>
            <fr:title text="Logical Methods in Computer Science">Logical Methods in Computer Science</fr:title>
            <fr:taxon>Journal</fr:taxon>
            <fr:meta name="external">https://lmcs.episciences.org/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Logical Methods in Computer Science is a fully refereed, open access, free, electronic journal. It welcomes papers on theoretical and practical areas in computer science involving logical methods, taken in a broad sense; some particular areas within its scope are listed below. Papers are refereed in the traditional way, with two or more referees per paper. Copyright is retained by the author.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
