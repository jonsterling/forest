<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/thorstenaltenkirch/" title="Thorsten Altenkirch" uri="https://www.jonmsterling.com/thorstenaltenkirch/" display-uri="thorstenaltenkirch" type="local">Thorsten Altenkirch</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/peterdybjer/" title="Peter Dybjer" uri="https://www.jonmsterling.com/peterdybjer/" display-uri="peterdybjer" type="local">Peter Dybjer</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/martinhofmann/" title="Martin Hofmann" uri="https://www.jonmsterling.com/martinhofmann/" display-uri="martinhofmann" type="local">Martin Hofmann</fr:link>
      </fr:author>
      <fr:author>
        <fr:link href="/philipscott/" title="Philip Scott" uri="https://www.jonmsterling.com/philipscott/" display-uri="philipscott" type="local">Philip Scott</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2001</fr:year>
      <fr:month>6</fr:month>
      <fr:day>19</fr:day>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/</fr:uri>
    <fr:display-uri>altenkirch-dybjer-hofmann-scott-2001</fr:display-uri>
    <fr:route>/altenkirch-dybjer-hofmann-scott-2001/</fr:route>
    <fr:title text="Normalization by evaluation for typed lambda calculus with coproducts">Normalization by evaluation for typed lambda calculus with coproducts</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="doi">10.1109/LICS.2001.932506</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Solves the decision problem for the simply typed lambda calculus with a strong binary sum, or, equivalently, the word problem for free Cartesian closed categories with binary co-products. Our method is based on the semantic technique known as “normalization by evaluation”, and involves inverting the interpretation of the syntax in a suitable sheaf model and, from this, extracting an appropriate unique normal form. There is no rewriting theory involved and the proof is completely constructive, allowing program extraction from the proof.</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0013/</fr:uri>
            <fr:display-uri>jms-0013</fr:display-uri>
            <fr:route>/jms-0013/</fr:route>
            <fr:title text="Chapter 4: Tait's method of computability">Chapter 4: Tait's method of computability</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>It is simple enough to verify <html:strong>negative</html:strong> properties of a formal system, e.g. the non-derivability of a given assertion <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>: find a mathematical object that models all the rules of the formal system and yet refutes <fr:tex display="inline"><![CDATA[\Phi ]]></fr:tex>. In contrast, it is much harder to verify any non-trivial <html:strong>positive</html:strong> property of a formal system (such as canonicity, normalization, decidability, etc.). To handle such results, new techniques were needed — and delivered in the late 1960s by Tait, Martin-Löf and others under the name of Tait’s method of computability or logical predicates. Since its inception, Tait’s method has been the primary tool for verifying positive properties of logics, programming languages, and type theories. Early on, <fr:link href="/freyd-1978/" title="On proving that 1 is an indecomposable projective in various free categories" uri="https://www.jonmsterling.com/freyd-1978/" display-uri="freyd-1978" type="local">Freyd</fr:link> noticed that the logical predicates arguments can be rephrased as model constructions that glue together geometrical objects corresponding to <html:em>syntax</html:em> (object) and <html:em>set theory</html:em> (meta), setting the stage for this thesis. Thus despite appearances, both positive and negative properties can both be proved using semantic methods.</html:p>
            <html:p>In the subsequent development of the computability method for applications in computer science, <html:em>indexed</html:em> variants of the logical predicates have proved to be fundamental and a number of variations on indexed logical predicates have appeared including the Kripke logical predicates of <fr:link href="/jung-tiuryn-1993/" title="A new characterization of lambda definability" uri="https://www.jonmsterling.com/jung-tiuryn-1993/" display-uri="jung-tiuryn-1993" type="local">Jung and Tiuryn</fr:link> and the much more sophisticated <html:em>Grothendieck</html:em> logical predicates of <fr:link href="/fiore-simpson-1999/" title="Lambda definability with sums via Grothendieck logical relations" uri="https://www.jonmsterling.com/fiore-simpson-1999/" display-uri="fiore-simpson-1999" type="local">Fiore and Simpson</fr:link> as well as <fr:link href="/altenkirch-dybjer-hofmann-scott-2001/" title="Normalization by evaluation for typed lambda calculus with coproducts" uri="https://www.jonmsterling.com/altenkirch-dybjer-hofmann-scott-2001/" display-uri="altenkirch-dybjer-hofmann-scott-2001" type="local">Altenkirch, Dybjer, Hofmann, and Scott</fr:link>. This chapter points out that all of these forms of indexing arise in the same way from what is referred to as a <html:strong>figure shape</html:strong>, a continuous map into the classifying space of “Henkin models” of a given theory. Then the (Kripke, Grothendieck, etc.) logical predicates model is presented much more simply as the Artin gluing of this morphism’s inverse image.</html:p>
            <html:p>An explicit proof of canonicity for the simply typed <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-calculus motivates the abstraction and axiomatization of the geometry of figure shapes and their gluings as a new language for syntactic metatheory, namely <html:strong>synthetic Tait computability</html:strong>. The idea of synthetic Tait computability is to treat both object-level notions (e.g. the collection of terms of type <fr:tex display="inline"><![CDATA[\mathsf {bool}]]></fr:tex>) and meta-level notions (e.g. a normal form of a given term) in the same language by means of a pair of lex idempotent modalities. One strength of this presentation is that both object-level and meta-level notions can be treated using higher-order abstract syntax (HOAS) in the sense of <fr:link href="/hofmann-1999/" title="Semantical analysis of higher-order abstract syntax" uri="https://www.jonmsterling.com/hofmann-1999/" display-uri="hofmann-1999" type="local">Hofmann</fr:link>, which greatly simplifies the manipulation of variables.</html:p>
            <html:p>The first demonstration of the power and modularity of synthetic Tait
  computability is a new a proof of the canonicity property for Martin-Löf type theory. Unlike traditional proofs of canonicity via non-synthetic Tait computability, the synthetic version is completely modular and broken up into general-purpose lemmas that are stated at a high level of abstraction and can be reused in proofs of <html:em>different properties</html:em> for <html:em>different type theories</html:em>. (Indeed, some of the constructions isolated in this chapter are used off the shelf in <fr:link href="/jms-0014/" title="Chapter 7: normalization for cubical type theory" uri="https://www.jonmsterling.com/jms-0014/" display-uri="jms-0014" type="local">Chapter 7</fr:link> to prove normalization for cubical type theory.) The modularization of syntactic metatheory is one of the main contributions of this dissertation.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
