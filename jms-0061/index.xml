<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2022</fr:year>
    </fr:date>
    <fr:uri>https://www.jonmsterling.com/jms-0061/</fr:uri>
    <fr:display-uri>jms-0061</fr:display-uri>
    <fr:route>/jms-0061/</fr:route>
    <fr:title text="TypeSynth: synthetic methods in program verification">TypeSynth: synthetic methods in program verification</fr:title>
    <fr:taxon>Fellowship</fr:taxon>
    <fr:meta name="doi">10.3030/101065303</fr:meta>
    <fr:meta name="venue">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
  <html:table>
  

  
    
  <html:tr>
  <html:td><html:strong>Beneficiary</html:strong>:</html:td>

  <html:td><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jonathan Sterling</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Award</html:strong>:</html:td>

  <html:td><fr:link href="https://marie-sklodowska-curie-actions.ec.europa.eu/actions/postdoctoral-fellowships" type="external">Marie Skłodowska-Curie Actions Postdoctoral Fellowship</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Funder</html:strong>:</html:td>

  <html:td><fr:link href="https://ec.europa.eu/info/research-and-innovation/funding/funding-opportunities/funding-programmes-and-open-calls/horizon-europe_en" type="external">European Commission, Horizon Europe Framework Programme (HORIZON)</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Host</html:strong>:</html:td>

  <html:td><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link>, <fr:link href="https://cpv.au.dk/" type="external">Center for Basic Research in Program Verification</fr:link></html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Years</html:strong>:</html:td>

  <html:td>2022–2024 (terminated 2023)</html:td>
</html:tr>

  
  
    
  <html:tr>
  <html:td><html:strong>Amount</html:strong>:</html:td>

  <html:td>214,934.4 EUR</html:td>
</html:tr>

  
</html:table>
<html:p>See the <fr:link href="/jms-0075/" title="TypeSynth final report" uri="https://www.jonmsterling.com/jms-0075/" display-uri="jms-0075" type="local">Final Report</fr:link> and <fr:link href="/jms-00AH/" title="TypeSynth project bibliography" uri="https://www.jonmsterling.com/jms-00AH/" display-uri="jms-00AH" type="local">Bibliography</fr:link>.</html:p><html:p><html:strong>Abstract.</html:strong> Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction.</html:p><html:p>Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. Languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p><html:p>In the context of dependent type theory, I have recently developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages.</html:p><html:p>The goal of the <html:strong>TypeSynth</html:strong> project is to extend the successful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> approach to a wider class of programming models, in particular programming languages with effects.</html:p></fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>12</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00AH/</fr:uri>
            <fr:display-uri>jms-00AH</fr:display-uri>
            <fr:route>/jms-00AH/</fr:route>
            <fr:title text="TypeSynth project bibliography"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project bibliography</fr:title>
            <fr:taxon>Bibliography</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
  
  

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Accepted papers">Accepted papers</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Refereed papers">Refereed papers</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>13</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri><fr:display-uri>sterling-2025-grothendieck</fr:display-uri><fr:route>/sterling-2025-grothendieck/</fr:route><fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta><fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta><fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p><html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>7</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route><fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta><fr:meta name="venue"><fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link></fr:meta><fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link></fr:author><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri><fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri><fr:route>/grodin-niu-sterling-harper-2024/</fr:route><fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632852</fr:meta><fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta><fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p><html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri><fr:display-uri>jms-012Q</fr:display-uri><fr:route>/jms-012Q/</fr:route><fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/filipsieczkowski/" title="Filip Sieczkowski" uri="https://www.jonmsterling.com/filipsieczkowski/" display-uri="filipsieczkowski" type="local">Filip Sieczkowski</fr:link></fr:author><fr:author><fr:link href="/sergeistepanenko/" title="Sergei Stepanenko" uri="https://www.jonmsterling.com/sergeistepanenko/" display-uri="sergeistepanenko" type="local">Sergei Stepanenko</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:uri><fr:display-uri>sieczkowski-stepanenko-sterling-birkedal-2024</fr:display-uri><fr:route>/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:route><fr:title text="The essence of generalized algebraic data types">The essence of generalized algebraic data types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632866</fr:meta><fr:meta name="bibtex"><![CDATA[@article{sieczkowski-stepanenko-sterling-birkedal-2024,
  author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
  title = {The Essence of Generalized Algebraic Data Types},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632866},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {24},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>This paper considers direct encodings of generalized algebraic data types (GADTs) in a minimal suitable lambda-calculus. To this end, we develop an extension of System F<html:sub>ω</html:sub> with recursive types and internalized type equalities with injective constant type constructors. We show how GADTs and associated pattern-matching constructs can be directly expressed in the calculus, thus showing that it may be treated as a highly idealized modern functional programming language. We prove that the internalized type equalities in conjunction with injectivity rules increase the expressive power of the calculus by establishing a non-macro-expressibility result in F<html:sub>ω</html:sub>, and prove the system type-sound via a syntactic argument. Finally, we build two relational models of our calculus: a simple, unary model that illustrates a novel, two-stage interpretation technique, necessary to account for the equational constraints; and a more sophisticated, binary model that relaxes the construction to allow, for the first time, formal reasoning about data-abstraction in a calculus equipped with GADTs.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri><fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri><fr:route>/aagaard-sterling-birkedal-2023/</fr:route><fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.46298/entics.12232</fr:meta><fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-generic/</fr:uri><fr:display-uri>sterling-2023-generic</fr:display-uri><fr:route>/sterling-2023-generic/</fr:route><fr:title text="What should a generic object be?">What should a generic object be?</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2023-generic,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2023},
  doi = {10.1017/S0960129523000117},
  journaltitle = {Mathematical Structures in Computer Science},
  pages = {1--22},
  title = {What should a generic object be?},
}]]></fr:meta><fr:meta name="doi">10.1017/S0960129523000117</fr:meta><fr:meta name="venue"><fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> has proposed definitions for (weak, strong, split) generic objects for a fibered category; building on his definition of (split) generic objects, <fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> develops a menagerie of important fibrational structures with applications to categorical logic and computer science, including higher order fibrations, polymorphic fibrations, 𝜆2-fibrations, triposes, and others. We observe that a split generic object need not in particular be a generic object under the given definitions, and that the definitions of polymorphic fibrations, triposes, etc. are strict enough to rule out some fundamental examples: for instance, the fibered preorder induced by a partial combinatory algebra in realizability is not a tripos in this sense. We propose a new alignment of terminology that emphasizes the forms of generic object appearing most commonly in nature, i.e. in the study of internal categories, triposes, and the denotational semantics of polymorphism. In addition, we propose a new class of acyclic generic objects inspired by recent developments in higher category theory and the semantics of homotopy type theory, generalizing the realignment property of universes to the setting of an arbitrary fibration.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Manuscripts">Manuscripts</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author><fr:author><fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri><fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri><fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2022/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-existentials/</fr:uri><fr:display-uri>sterling-2022-existentials</fr:display-uri><fr:route>/sterling-2022-existentials/</fr:route><fr:title text="Reflections on existential types">Reflections on existential types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2022-existentials,
  doi = {10.48550/ARXIV.2210.00758},
  author = {Sterling, Jonathan},
  title = {Reflections on existential types},
  publisher = {arXiv},
  year = {2022},
  note = {Unpublished manuscript},
}]]></fr:meta><fr:meta name="doi">10.48550/arXiv.2210.00758</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Existential types are reconstructed in terms of <html:em>small reflective subuniverses</html:em> and dependent sums. The folklore decomposition detailed here gives rise to a particularly simple account of first class modules as a mode of use of traditional second class modules in connection with the modal operator induced by a reflective subuniverse, leading to a semantic justification for the rules of first-class modules in languages like OCaml and MoscowML.   Additionally, we expose several constructions that give rise to semantic models of ML-style programming languages with both first-class modules and realistic computational effects, culminating in a model that accommodates higher-order first class recursive modules <html:em>and</html:em> higher-order store.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri><fr:display-uri>sterling-2022-naive</fr:display-uri><fr:route>/sterling-2022-naive/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta><fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Dissertations">Dissertations</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Technical reports">Technical reports</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Workshop talks">Workshop talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-catmi/</fr:uri><fr:display-uri>sterling-2023-catmi</fr:display-uri><fr:route>/sterling-2023-catmi/</fr:route><fr:title text="Naïve denotational semantics: synthetic domains in the 21st century">Naïve denotational semantics: synthetic domains in the 21st century</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="external">http://www.catmi.no/</fr:meta><fr:meta name="slides">/bafkrmielsxg42lagb5fu2zymlfcvlvyqpvclrzc3kre6dszhwpgvdxuum4.pdf</fr:meta><fr:meta name="venue"><fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It is easy to teach a student how to give a naïve denotational semantics to a language like System T, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p><html:p>The dream of the 1990s was to find a category that behaves like <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this <html:strong>synthetic domain theory</html:strong> is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including simple denotational semantics for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p><html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta><fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-pujet-workshop/</fr:uri><fr:display-uri>sterling-2022-pujet-workshop</fr:display-uri><fr:route>/sterling-2022-pujet-workshop/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiajrzaq3g6iptivu37xqg6kfcxs32gvwnwqzrrzpp5g5cnvyhsfgy.pdf</fr:meta><fr:meta name="venue">Workshop on Dependent Type Theory (to celebrate the Defense of <fr:link href="/lo%C3%AFcpujet/" title="Loïc Pujet" uri="https://www.jonmsterling.com/loïcpujet/" display-uri="loïcpujet" type="local">Loïc Pujet</fr:link>)</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for <fr:link href="/gratzer-sterling-angiuli-coquand-birkedal-2022/" title="Controlling unfolding in type theory" uri="https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/" display-uri="gratzer-sterling-angiuli-coquand-birkedal-2022" type="local">controlling the unfolding of definitions in dependent type theory</fr:link>. Traditionally, proof assistants let users specify whether each definition can or cannot be unfolded in the remainder of a development; unfolding definitions is often necessary in order to reason about them, but an excess of unfolding can result in brittle proofs and intractably large proof goals. In our system, definitions are by default not unfolded, but users can selectively unfold them in a local manner. We justify our mechanism by means of elaboration to a core type theory with <html:em>extension types</html:em>, a connective first introduced in the context of homotopy type theory.  We prove a normalization theorem for our core calculus and have implemented our system in the cooltt proof assistant, providing both theoretical and practical evidence for it.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Seminar talks">Seminar talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-logsem/</fr:uri><fr:display-uri>sterling-2023-logsem</fr:display-uri><fr:route>/sterling-2023-logsem/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiczxyoaqvsobp544cpqfjrr5tisnm36cmkyb2pykcw5owku7hzoai.pdf</fr:meta><fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines guarded recursion (the "later" modality) with impredicative polymorphism (universal and existential types). It turns out that these two features are sufficient to define a very simple denotational semantics for System F with recursive types and higher-order store. We believe that the expressivity of iGDTT brings us one step closer to a general metalanguage for realistic denotational semantics, and provides a compelling strategy to elude the burden of operational semantics. As a further benefit, we are now able to justify the extension of full dependent type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-cambridge/</fr:uri><fr:display-uri>sterling-2023-cambridge</fr:display-uri><fr:route>/sterling-2023-cambridge/</fr:route><fr:title text="Crossing boundaries in program semantics">Crossing boundaries in program semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiaqido7bsry3bs2tnh5rtwa3ozf4wpm3zui46pneusslkxoh46nza.pdf</fr:meta><fr:meta name="venue"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>The great semanticist John Reynolds famously wrote in 1983 that “type structure is a syntactic
discipline for enforcing levels of abstraction”. If the last twenty years of programming language
semantics and verification have taught us anything, it is that we also need a syntactic discipline
for breaking abstraction — in other words, a way to glue together programs and verifications that
cut across abstraction barriers.</html:p><html:p>In programming language semantics and verification, the problem of combining multiple levels of
abstraction arises when choosing a “level of detail” at which to view program execution:
for instance, one could look at program execution as a detailed operational process of
discrete steps evincing the cost or complexity of an algorithm, or one could think of
it more abstractly as a black box that only sends inputs to outputs. The difficulty is
that in practice, verifications tend to cut across this barrier between complexity
and functional correctness: for instance, complexity bounds often depend on the
functional correctness of subroutines, and the existence of such a bound implies
termination (a correctness property).</html:p><html:p>For this reason, it is crucial to develop integrated logical foundations for <html:strong>soundly</html:strong> reasoning
using multiple models of execution at the same time, even when they expose different facets of
a program's meaning. For the past three years, my research program has been to uncover and
exploit the basic “laws of motion” governing all such abstraction barriers, which has led
to the solution of a few significant open problems in homotopy type theory and modal type
theory, as well as some preliminary applications to security and cost analysis.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-birmingham/</fr:uri><fr:display-uri>sterling-2023-birmingham</fr:display-uri><fr:route>/sterling-2023-birmingham/</fr:route><fr:title text="New spaces for denotational semantics">New spaces for denotational semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmihzmtwc65afir3o7ttpmckh5xakkorwpwjj6x5eg4hascotp456ke.pdf</fr:meta><fr:meta name="venue">University of Birmingham</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>11</fr:month><fr:day>8</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-itu/</fr:uri><fr:display-uri>sterling-2022-itu</fr:display-uri><fr:route>/sterling-2022-itu/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmigiix5np3fp4npmgxvmx7kl7nb52ieyiazbwdxh6amdbfxdhnp2fy.pdf</fr:meta><fr:meta name="venue">Programming, Logic and Semantics, ITU Copenhagen</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines
<html:em>guarded recursion</html:em> (the "later" modality) with <html:em>impredicative polymorphism</html:em> (universal and existential types).
It turns out that these two features are sufficient to define a very simple denotational semantics for
System F with recursive types and higher-order store. We believe that the expressivity of iGDTT
brings us one step closer to a general metalanguage for realistic denotational semantics,
and provides a compelling strategy to elude the burden of operational semantics.
As a further benefit, we are now able to justify the extension of full dependent
type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Roladex">Roladex</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri><fr:display-uri>jonmsterling</fr:display-uri><fr:route>/jonmsterling/</fr:route><fr:title text="Jon Sterling">Jon Sterling</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta><fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta><fr:meta name="orcid">0000-0002-0585-5564</fr:meta><fr:meta name="position">Associate Professor</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="postdoc-advisor">larsbirkedal</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p><html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>9</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-008M/</fr:uri>
            <fr:display-uri>jms-008M</fr:display-uri>
            <fr:route>/jms-008M/</fr:route>
            <fr:title text="Professional history">Professional history</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>From September 2023, I am an <fr:link href="https://www.cst.cam.ac.uk/people/js2878" type="external"><html:em>Associate Professor in Logical Foundations and Formal Methods</html:em></fr:link> at University of Cambridge.</html:p>
            <html:p>From 2022, I was a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> working with <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>.</html:p>
            <html:p>From 2016 to 2021, I was a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Professor Robert Harper</fr:link> at <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link>, where I wrote my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link> on <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link> and its application to <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">normalization for cubical type theory</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0076/</fr:uri>
            <fr:display-uri>jms-0076</fr:display-uri>
            <fr:route>/jms-0076/</fr:route>
            <fr:title text="Context and overall objectives">Context and overall objectives</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction. Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. One of the most extreme forms of computational effect is “higher-order mutable state”, which is when programs can read and write data as well as entire subroutines to the computer’s memory during execution.  Programming languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p>
            <html:p>Recently there have been several significant technical advances in mathematical semantics for programming languages that have been ripe for exploitation. For instance, in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral thesis</fr:link> I developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or “STC” that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, STC enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the STC method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages. Another related advance is the use of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">Synthetic Guarded Domain Theory</fr:link> or “SGDT” as a mathematical language in which to describe and reason about the behavior of computer programs, potentially exhibiting complex interactions with their environment and with other programs. A third advance setting the stage for this project is the development of <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Univalent Foundations and Homotopy Type Theory</fr:link>, a new and backwards-compatible foundation of mathematics that places symmetries and reversible transformations of mathematical structures in the forefront.</html:p>
            <html:p>The goal of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been to combine these three ideas to break a long-standing logjam in the mathematical understanding of computer programming: the denotational semantics and equational separation logic of higher-order mutable state.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0078/</fr:uri>
            <fr:display-uri>jms-0078</fr:display-uri>
            <fr:route>/jms-0078/</fr:route>
            <fr:title text="Denotational semantics of higher-order store">Denotational semantics of higher-order store</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> plan to develop denotational semantics of higher-order store had two components: the first was to develop a practical semantic model of polymorphic higher-order store without garbage collection, and the second was to extend this model to support the equational theory of garbage collection. For the former, the results have greatly outstripped expectations: I have succeeded in constructing not only the indended model of store with polymorphism, but in fact a <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">model of full dependent type theory with higher-order store</fr:link> — posing the prospect for being able to write and verify the correctness of programs in the same language. This result is the first of its kind for higher-order store, and is a significant advance. In the final months of the project, we have also gone further beyond this result in a different direction, and constructed a version of the model of higher-order store satisfying a new gamut of compelling representation independence equations which I refer to as the theory of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link>: in short, two programs can be considered equal even if they allocate memory cells of different types, so long as the two types are in bijection and programs' interaction with the memory cell respects this bijection.</html:p>
            <html:p>I have begun to extend these results to include the equational theory of garbage collection, but as the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been terminated nearly one year early (due to my recent appointment as Associate Professor at University of Cambridge), this further exploitation of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> methodology will continue beyond the conclusion of the project.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-007A/</fr:uri>
            <fr:display-uri>jms-007A</fr:display-uri>
            <fr:route>/jms-007A/</fr:route>
            <fr:title text="Effectful synthetic Tait computability">Effectful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A third achievement of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project was to extend the highly successful “<fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link>” method, developed in my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link>, to the case of realistic programming languages with computational effects. The purpose of this extension was to achieve strong representation independence results, by which we can show the computational indistinguishability of even two programs that allocate memory cells of different types that are linked not by a bijection but by a mere relation, in contrast to univalent reference types. We have gone quite a bit beyond our expectations, as our account of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local"><fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> for higher-order store</fr:link> applies not only to the simple polymorphic store model, but also to the full dependent type theory. This allows many classic results from the literature that previously required very complicated reasoning with the semantic model to be reconstructed in a simpler and more direct fashion.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0079/</fr:uri>
            <fr:display-uri>jms-0079</fr:display-uri>
            <fr:route>/jms-0079/</fr:route>
            <fr:title text="Equational higher-order separation logic for higher-order store">Equational higher-order separation logic for higher-order store</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In collaboration with my colleagues <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Ljerbjerg Aagaard</fr:link> and <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>, I have developed a <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">guarded higher-order separation logic called TULIP</fr:link> over the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational model of higher-order store</fr:link>. This logic represents a significant step forward in the march toward simple, abstract, and compositional reasoning about higher-order stateful programs. Prior program logics (such as Iris and the Verified Software Toolchain) interact with computer programs only indirectly, by verifying properties of a specific “transition function” that simulates the steps that a (highly idealized) computer would take when executing a program; this style is called “operational”. Unfortunately, the important structural properties of programs are highly unnatural to express at the level of transition steps, and as such, existing operationally-based program logics impose a great deal of bureaucracy by forcing those verifying programs to manually mediate the mismatch between the viewpoint of the machine (which cannot see program structure), and the viewpoint of the programmer (which is entirely based on program structure). An equational, or "denotationally-based", program logic like <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> instead treats programs directly without needing to pass through an encoding in terms of machine transitions. An immediate benefit of the equational approach is that program equivalences can be glued together directly in any context, a kind of practical compositionality that is unique to equational and denotationally-based program logics. Our development of the <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> logic is a strong first step in this direction.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-007C/</fr:uri>
            <fr:display-uri>jms-007C</fr:display-uri>
            <fr:route>/jms-007C/</fr:route>
            <fr:title text="Policy relevant evidence of the project">Policy relevant evidence of the project</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Research in program semantics and verification is essentially of two kinds. On the one hand, there is work that pushes the envelope of what kinds of programs can be verified — demonstrating (at great exertion and expense) the potential to verify the correctness of the extremely complex software that makes our society work, including onboard software used in air planes, industrial production, agricultural production, artificial intelligence, etc.  On the other hand, there is research that aims to rethink from the ground up the mathematical understanding of programming, radically simplifying the foundations on which the program verification tools are built. Both kinds of research are important and rely heavily on each other. Applied program verification is critical because the need to prevent software faults is ever-present, and in order to get any kind of uptake and adoption, we must demonstrate the capability of our tools to handle the very complex problems that are raised by industrial and governmental use of software. Likewise, foundational research is extremely important because when applied program verification hits its conceptual limitations, it can only advance by becoming bigger and more expensive — requiring larger and larger teams and budgets to make smaller and smaller incremental improvements. In just one year, the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has achieved (through careful attention to building bridges between different mathematical disciplines) what many researchers in this area considered impossible or at least significantly farther off in the future; this experience must be replicated with further grants and fellowships to theoretically and foundationally minded researchers who are willing to undertake interdisciplinary work.</html:p>
            <html:p>At the present time, my perception is that applied program verification is significantly more intelligible to funders and agencies because it speaks directly to the fears and concerns that we all have for our society in the age of software domination, artificial intelligence, and quantum computing; this is understandable, but it has regrettably led to the neglect of foundational research at the time when it is most urgent — it is now that we must lay the foundations for the next generation of program verifiers, before rather than after applied work in program verification reaches the hard limitations that more theoretically-oriented researchers have been working to remove. Therefore, I urge the European Commission and relevant policy makers to increase their consideration of foundational research as an investment in the future, alongside their continued funding of the very important applied direction in program semantics and verification.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-007B/</fr:uri>
            <fr:display-uri>jms-007B</fr:display-uri>
            <fr:route>/jms-007B/</fr:route>
            <fr:title text="Results beyond the state of the art">Results beyond the state of the art</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The results of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project have gone significantly beyond the state of the art in denotational semantics for computational effects: not only is ours the first typed denotational model of higher-order store compatible with parametric polymorphism, but we have shown that the same construction also gives rise to a model of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">full dependent type theory with higher-order store</fr:link> — a long sought-after result whose implications we have not yet fully exploited. Our model of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link> is also a significant break with the state of the art, and points the way to a new and more fruitful interaction between the fields of programming languages on the one hand, and homotopy type theory and algebraic topology on the other hand.</html:p>
            <html:p>The <fr:link href="/jms-0077/" title="Work performed and main achievements" uri="https://www.jonmsterling.com/jms-0077/" display-uri="jms-0077" type="local">technical achievements</fr:link> of <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> point to healthy growth in the long-neglected area of denotational semantics and equational program logics, but there is an urgent need for further research to bring these superior but comparatively less-developed methods to practical parity with the more established operational paradigm, which currently achieves stronger results in program verification — which we believe can be accounted for by the twenty-year headstart enjoyed by teams favoring operational methods during the relative dormancy of semantic and categorical methods in programming languages.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0075/</fr:uri>
            <fr:display-uri>jms-0075</fr:display-uri>
            <fr:route>/jms-0075/</fr:route>
            <fr:title text="TypeSynth final report"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> final report</fr:title>
            <fr:taxon>Report</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This is the final report for the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> MSCA project.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0076/</fr:uri>
                <fr:display-uri>jms-0076</fr:display-uri>
                <fr:route>/jms-0076/</fr:route>
                <fr:title text="Context and overall objectives">Context and overall objectives</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction. Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. One of the most extreme forms of computational effect is “higher-order mutable state”, which is when programs can read and write data as well as entire subroutines to the computer’s memory during execution.  Programming languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p>
                <html:p>Recently there have been several significant technical advances in mathematical semantics for programming languages that have been ripe for exploitation. For instance, in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral thesis</fr:link> I developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or “STC” that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, STC enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the STC method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages. Another related advance is the use of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">Synthetic Guarded Domain Theory</fr:link> or “SGDT” as a mathematical language in which to describe and reason about the behavior of computer programs, potentially exhibiting complex interactions with their environment and with other programs. A third advance setting the stage for this project is the development of <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Univalent Foundations and Homotopy Type Theory</fr:link>, a new and backwards-compatible foundation of mathematics that places symmetries and reversible transformations of mathematical structures in the forefront.</html:p>
                <html:p>The goal of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been to combine these three ideas to break a long-standing logjam in the mathematical understanding of computer programming: the denotational semantics and equational separation logic of higher-order mutable state.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0077/</fr:uri>
                <fr:display-uri>jms-0077</fr:display-uri>
                <fr:route>/jms-0077/</fr:route>
                <fr:title text="Work performed and main achievements">Work performed and main achievements</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I highlight the three main achievements of the TypeSynth project below:</html:p>
                <html:ol><html:li>a new denotational semantics of higher-order store;</html:li>
  <html:li>an equational higher-order separation logic based on the above denotational semantics;</html:li>
  <html:li>the extension of <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link> to support computational effects including guarded recursion and higher-order store.</html:li></html:ol>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0078/</fr:uri>
                    <fr:display-uri>jms-0078</fr:display-uri>
                    <fr:route>/jms-0078/</fr:route>
                    <fr:title text="Denotational semantics of higher-order store">Denotational semantics of higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> plan to develop denotational semantics of higher-order store had two components: the first was to develop a practical semantic model of polymorphic higher-order store without garbage collection, and the second was to extend this model to support the equational theory of garbage collection. For the former, the results have greatly outstripped expectations: I have succeeded in constructing not only the indended model of store with polymorphism, but in fact a <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">model of full dependent type theory with higher-order store</fr:link> — posing the prospect for being able to write and verify the correctness of programs in the same language. This result is the first of its kind for higher-order store, and is a significant advance. In the final months of the project, we have also gone further beyond this result in a different direction, and constructed a version of the model of higher-order store satisfying a new gamut of compelling representation independence equations which I refer to as the theory of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link>: in short, two programs can be considered equal even if they allocate memory cells of different types, so long as the two types are in bijection and programs' interaction with the memory cell respects this bijection.</html:p>
                    <html:p>I have begun to extend these results to include the equational theory of garbage collection, but as the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been terminated nearly one year early (due to my recent appointment as Associate Professor at University of Cambridge), this further exploitation of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> methodology will continue beyond the conclusion of the project.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0079/</fr:uri>
                    <fr:display-uri>jms-0079</fr:display-uri>
                    <fr:route>/jms-0079/</fr:route>
                    <fr:title text="Equational higher-order separation logic for higher-order store">Equational higher-order separation logic for higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In collaboration with my colleagues <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Ljerbjerg Aagaard</fr:link> and <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>, I have developed a <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">guarded higher-order separation logic called TULIP</fr:link> over the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational model of higher-order store</fr:link>. This logic represents a significant step forward in the march toward simple, abstract, and compositional reasoning about higher-order stateful programs. Prior program logics (such as Iris and the Verified Software Toolchain) interact with computer programs only indirectly, by verifying properties of a specific “transition function” that simulates the steps that a (highly idealized) computer would take when executing a program; this style is called “operational”. Unfortunately, the important structural properties of programs are highly unnatural to express at the level of transition steps, and as such, existing operationally-based program logics impose a great deal of bureaucracy by forcing those verifying programs to manually mediate the mismatch between the viewpoint of the machine (which cannot see program structure), and the viewpoint of the programmer (which is entirely based on program structure). An equational, or "denotationally-based", program logic like <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> instead treats programs directly without needing to pass through an encoding in terms of machine transitions. An immediate benefit of the equational approach is that program equivalences can be glued together directly in any context, a kind of practical compositionality that is unique to equational and denotationally-based program logics. Our development of the <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> logic is a strong first step in this direction.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-007A/</fr:uri>
                    <fr:display-uri>jms-007A</fr:display-uri>
                    <fr:route>/jms-007A/</fr:route>
                    <fr:title text="Effectful synthetic Tait computability">Effectful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link></fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A third achievement of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project was to extend the highly successful “<fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link>” method, developed in my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link>, to the case of realistic programming languages with computational effects. The purpose of this extension was to achieve strong representation independence results, by which we can show the computational indistinguishability of even two programs that allocate memory cells of different types that are linked not by a bijection but by a mere relation, in contrast to univalent reference types. We have gone quite a bit beyond our expectations, as our account of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local"><fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> for higher-order store</fr:link> applies not only to the simple polymorphic store model, but also to the full dependent type theory. This allows many classic results from the literature that previously required very complicated reasoning with the semantic model to be reconstructed in a simpler and more direct fashion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007B/</fr:uri>
                <fr:display-uri>jms-007B</fr:display-uri>
                <fr:route>/jms-007B/</fr:route>
                <fr:title text="Results beyond the state of the art">Results beyond the state of the art</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The results of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project have gone significantly beyond the state of the art in denotational semantics for computational effects: not only is ours the first typed denotational model of higher-order store compatible with parametric polymorphism, but we have shown that the same construction also gives rise to a model of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">full dependent type theory with higher-order store</fr:link> — a long sought-after result whose implications we have not yet fully exploited. Our model of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link> is also a significant break with the state of the art, and points the way to a new and more fruitful interaction between the fields of programming languages on the one hand, and homotopy type theory and algebraic topology on the other hand.</html:p>
                <html:p>The <fr:link href="/jms-0077/" title="Work performed and main achievements" uri="https://www.jonmsterling.com/jms-0077/" display-uri="jms-0077" type="local">technical achievements</fr:link> of <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> point to healthy growth in the long-neglected area of denotational semantics and equational program logics, but there is an urgent need for further research to bring these superior but comparatively less-developed methods to practical parity with the more established operational paradigm, which currently achieves stronger results in program verification — which we believe can be accounted for by the twenty-year headstart enjoyed by teams favoring operational methods during the relative dormancy of semantic and categorical methods in programming languages.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007C/</fr:uri>
                <fr:display-uri>jms-007C</fr:display-uri>
                <fr:route>/jms-007C/</fr:route>
                <fr:title text="Policy relevant evidence of the project">Policy relevant evidence of the project</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Research in program semantics and verification is essentially of two kinds. On the one hand, there is work that pushes the envelope of what kinds of programs can be verified — demonstrating (at great exertion and expense) the potential to verify the correctness of the extremely complex software that makes our society work, including onboard software used in air planes, industrial production, agricultural production, artificial intelligence, etc.  On the other hand, there is research that aims to rethink from the ground up the mathematical understanding of programming, radically simplifying the foundations on which the program verification tools are built. Both kinds of research are important and rely heavily on each other. Applied program verification is critical because the need to prevent software faults is ever-present, and in order to get any kind of uptake and adoption, we must demonstrate the capability of our tools to handle the very complex problems that are raised by industrial and governmental use of software. Likewise, foundational research is extremely important because when applied program verification hits its conceptual limitations, it can only advance by becoming bigger and more expensive — requiring larger and larger teams and budgets to make smaller and smaller incremental improvements. In just one year, the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has achieved (through careful attention to building bridges between different mathematical disciplines) what many researchers in this area considered impossible or at least significantly farther off in the future; this experience must be replicated with further grants and fellowships to theoretically and foundationally minded researchers who are willing to undertake interdisciplinary work.</html:p>
                <html:p>At the present time, my perception is that applied program verification is significantly more intelligible to funders and agencies because it speaks directly to the fears and concerns that we all have for our society in the age of software domination, artificial intelligence, and quantum computing; this is understandable, but it has regrettably led to the neglect of foundational research at the time when it is most urgent — it is now that we must lay the foundations for the next generation of program verifiers, before rather than after applied work in program verification reaches the hard limitations that more theoretically-oriented researchers have been working to remove. Therefore, I urge the European Commission and relevant policy makers to increase their consideration of foundational research as an investment in the future, alongside their continued funding of the very important applied direction in program semantics and verification.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/jms-006B/</fr:uri>
            <fr:display-uri>jms-006B</fr:display-uri>
            <fr:route>/jms-006B/</fr:route>
            <fr:title text="Funding and grants">Funding and grants</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:ol><html:li><fr:link href="/jms-008K/" title="New Spaces for Denotational Semantics" uri="https://www.jonmsterling.com/jms-008K/" display-uri="jms-008K" type="local">New Spaces for Denotational Semantics</fr:link></html:li>
 <html:li><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth: synthetic methods in program verification</fr:link></html:li>
 <html:li><fr:link href="/jms-006C/" title="Session types and phase distinctions for noninterference" uri="https://www.jonmsterling.com/jms-006C/" display-uri="jms-006C" type="local">Session types and phase distinctions for noninterference</fr:link></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri>
            <fr:display-uri>jonmsterling</fr:display-uri>
            <fr:route>/jonmsterling/</fr:route>
            <fr:title text="Jon Sterling">Jon Sterling</fr:title>
            <fr:taxon>Person</fr:taxon>
            <fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta>
            <fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta>
            <fr:meta name="orcid">0000-0002-0585-5564</fr:meta>
            <fr:meta name="position">Associate Professor</fr:meta>
            <fr:meta name="phd-advisor">robertharper</fr:meta>
            <fr:meta name="postdoc-advisor">larsbirkedal</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
            <html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>10</fr:month>
              <fr:day>12</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-00AH/</fr:uri>
            <fr:display-uri>jms-00AH</fr:display-uri>
            <fr:route>/jms-00AH/</fr:route>
            <fr:title text="TypeSynth project bibliography"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project bibliography</fr:title>
            <fr:taxon>Bibliography</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
  
  

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Accepted papers">Accepted papers</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Refereed papers">Refereed papers</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>13</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri><fr:display-uri>sterling-2025-grothendieck</fr:display-uri><fr:route>/sterling-2025-grothendieck/</fr:route><fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta><fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta><fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p><html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>2</fr:month><fr:day>7</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2024-univalent</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2024-univalent/</fr:route><fr:title text="Towards univalent reference types">Towards univalent reference types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.4230/LIPIcs.CSL.2024.47</fr:meta><fr:meta name="venue"><fr:link href="/csl-2024/" title="CSL ’24: 32nd EACSL Annual Conference on Computer Science Logic 2024" uri="https://www.jonmsterling.com/csl-2024/" display-uri="csl-2024" type="local"><html:em>CSL ’24</html:em>: 32nd EACSL Annual Conference on Computer Science Logic 2024</fr:link></fr:meta><fr:meta name="bibtex"><![CDATA[@inproceedings{sterling-gratzer-birkedal-2024-univalent,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  title = {{Towards Univalent Reference Types: The Impact of Univalence on Denotational Semantics}},
  booktitle = {32nd EACSL Annual Conference on Computer Science Logic (CSL 2024)},
  pages = {47:1--47:21},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-310-2},
  ISSN = {1868-8969},
  year = {2024},
  volume = {288},
  editor = {Murano, Aniello and Silva, Alexandra},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  doi =  {10.4230/LIPIcs.CSL.2024.47},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We develop a denotational semantics for general reference types in an <fr:link href="/awodey-frey-speight-2018/" title="Impredicative encodings of (higher) inductive types" uri="https://www.jonmsterling.com/awodey-frey-speight-2018/" display-uri="awodey-frey-speight-2018" type="local">impredicative version</fr:link> of <fr:link href="/bbcgsv-2019/" title="Guarded cubical type theory" uri="https://www.jonmsterling.com/bbcgsv-2019/" display-uri="bbcgsv-2019" type="local"><html:strong><html:em>guarded homotopy type theory</html:em></html:strong></fr:link>, an adaptation of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">synthetic guarded domain theory</fr:link> to Voevodsky’s <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">univalent foundations</fr:link>. We observe for the first time the profound impact of univalence on the <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational semantics of mutable state</fr:link>. Univalence automatically ensures that all computations are invariant under symmetries of the heap—a bountiful source of program equivalences. In particular, even the most simplistic univalent model enjoys many new program equivalences that do not hold when the same constructions are carried out in the universes of traditional set-level (extensional) type theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link></fr:author><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri><fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri><fr:route>/grodin-niu-sterling-harper-2024/</fr:route><fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632852</fr:meta><fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta><fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p><html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri><fr:display-uri>jms-012Q</fr:display-uri><fr:route>/jms-012Q/</fr:route><fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/filipsieczkowski/" title="Filip Sieczkowski" uri="https://www.jonmsterling.com/filipsieczkowski/" display-uri="filipsieczkowski" type="local">Filip Sieczkowski</fr:link></fr:author><fr:author><fr:link href="/sergeistepanenko/" title="Sergei Stepanenko" uri="https://www.jonmsterling.com/sergeistepanenko/" display-uri="sergeistepanenko" type="local">Sergei Stepanenko</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:uri><fr:display-uri>sieczkowski-stepanenko-sterling-birkedal-2024</fr:display-uri><fr:route>/sieczkowski-stepanenko-sterling-birkedal-2024/</fr:route><fr:title text="The essence of generalized algebraic data types">The essence of generalized algebraic data types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632866</fr:meta><fr:meta name="bibtex"><![CDATA[@article{sieczkowski-stepanenko-sterling-birkedal-2024,
  author = {Sieczkowski, Filip and Stepanenko, Sergei and Sterling, Jonathan and Birkedal, Lars},
  title = {The Essence of Generalized Algebraic Data Types},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632866},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {24},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>This paper considers direct encodings of generalized algebraic data types (GADTs) in a minimal suitable lambda-calculus. To this end, we develop an extension of System F<html:sub>ω</html:sub> with recursive types and internalized type equalities with injective constant type constructors. We show how GADTs and associated pattern-matching constructs can be directly expressed in the calculus, thus showing that it may be treated as a highly idealized modern functional programming language. We prove that the internalized type equalities in conjunction with injectivity rules increase the expressive power of the calculus by establishing a non-macro-expressibility result in F<html:sub>ω</html:sub>, and prove the system type-sound via a syntactic argument. Finally, we build two relational models of our calculus: a simple, unary model that illustrates a novel, two-stage interpretation technique, necessary to account for the equational constraints; and a more sophisticated, binary model that relaxes the construction to allow, for the first time, formal reasoning about data-abstraction in a calculus equipped with GADTs.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Lerbjerg Aagaard</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>11</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/</fr:uri><fr:display-uri>aagaard-sterling-birkedal-2023</fr:display-uri><fr:route>/aagaard-sterling-birkedal-2023/</fr:route><fr:title text="A denotationally-based program logic for higher-order store">A denotationally-based program logic for higher-order store</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.46298/entics.12232</fr:meta><fr:meta name="venue">39th International Conference on Mathematical Foundations of Programming Semantics</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Separation logic is used to reason locally about stateful programs. State of the art program logics for higher-order store are usually built on top of untyped operational semantics, in part because traditional denotational methods have struggled to simultaneously account for general references and parametric polymorphism. The <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">recent discovery</fr:link> of simple denotational semantics for general references and polymorphism in synthetic guarded domain theory has enabled us to develop <html:strong>Tulip</html:strong>, a higher-order separation logic over the typed equational theory of higher-order store for a monadic version of System <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex>. The <html:strong>Tulip</html:strong> logic differs from operationally-based program logics in two ways: predicates range over the meanings of typed terms rather than over the raw code of untyped terms, and they are automatically invariant under the equational congruence of higher-order store, which applies even underneath a binder. As a result, “pure” proof steps that conventionally require focusing the Hoare triple on an operational redex are replaced by a simple equational rewrite in <html:strong>Tulip</html:strong>. We have evaluated <html:strong>Tulip</html:strong> against standard examples involving linked lists in the heap, comparing our abstract equational reasoning with more familiar operational-style reasoning. Our main result is the soundness of <html:strong>Tulip</html:strong>, which we establish by constructing a BI-hyperdoctrine over the denotational semantics of <fr:tex display="inline"><![CDATA[\textbf {F}^{\mu ,\textit {ref}}]]></fr:tex> in an impredicative version of synthetic guarded domain theory.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-generic/</fr:uri><fr:display-uri>sterling-2023-generic</fr:display-uri><fr:route>/sterling-2023-generic/</fr:route><fr:title text="What should a generic object be?">What should a generic object be?</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2023-generic,
  author = {Sterling, Jonathan},
  publisher = {Cambridge University Press},
  date = {2023},
  doi = {10.1017/S0960129523000117},
  journaltitle = {Mathematical Structures in Computer Science},
  pages = {1--22},
  title = {What should a generic object be?},
}]]></fr:meta><fr:meta name="doi">10.1017/S0960129523000117</fr:meta><fr:meta name="venue"><fr:link href="/mscs/" title="Mathematical Structures in Computer Science" uri="https://www.jonmsterling.com/mscs/" display-uri="mscs" type="local">Mathematical Structures in Computer Science</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> has proposed definitions for (weak, strong, split) generic objects for a fibered category; building on his definition of (split) generic objects, <fr:link href="/jacobs-1999/" title="Categorical logic and type theory" uri="https://www.jonmsterling.com/jacobs-1999/" display-uri="jacobs-1999" type="local">Jacobs</fr:link> develops a menagerie of important fibrational structures with applications to categorical logic and computer science, including higher order fibrations, polymorphic fibrations, 𝜆2-fibrations, triposes, and others. We observe that a split generic object need not in particular be a generic object under the given definitions, and that the definitions of polymorphic fibrations, triposes, etc. are strict enough to rule out some fundamental examples: for instance, the fibered preorder induced by a partial combinatory algebra in realizability is not a tripos in this sense. We propose a new alignment of terminology that emphasizes the forms of generic object appearing most commonly in nature, i.e. in the study of internal categories, triposes, and the denotational semantics of polymorphism. In addition, we propose a new class of acyclic generic objects inspired by recent developments in higher category theory and the semantics of homotopy type theory, generalizing the realignment property of universes to the setting of an arbitrary fibration.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Manuscripts">Manuscripts</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author><fr:author><fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri><fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri><fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2022/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-existentials/</fr:uri><fr:display-uri>sterling-2022-existentials</fr:display-uri><fr:route>/sterling-2022-existentials/</fr:route><fr:title text="Reflections on existential types">Reflections on existential types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@article{sterling-2022-existentials,
  doi = {10.48550/ARXIV.2210.00758},
  author = {Sterling, Jonathan},
  title = {Reflections on existential types},
  publisher = {arXiv},
  year = {2022},
  note = {Unpublished manuscript},
}]]></fr:meta><fr:meta name="doi">10.48550/arXiv.2210.00758</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Existential types are reconstructed in terms of <html:em>small reflective subuniverses</html:em> and dependent sums. The folklore decomposition detailed here gives rise to a particularly simple account of first class modules as a mode of use of traditional second class modules in connection with the modal operator induced by a reflective subuniverse, leading to a semantic justification for the rules of first-class modules in languages like OCaml and MoscowML.   Additionally, we expose several constructions that give rise to semantic models of ML-style programming languages with both first-class modules and realistic computational effects, culminating in a model that accommodates higher-order first class recursive modules <html:em>and</html:em> higher-order store.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri><fr:display-uri>sterling-2022-naive</fr:display-uri><fr:route>/sterling-2022-naive/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta><fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Dissertations">Dissertations</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Technical reports">Technical reports</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Workshop talks">Workshop talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>6</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-catmi/</fr:uri><fr:display-uri>sterling-2023-catmi</fr:display-uri><fr:route>/sterling-2023-catmi/</fr:route><fr:title text="Naïve denotational semantics: synthetic domains in the 21st century">Naïve denotational semantics: synthetic domains in the 21st century</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="external">http://www.catmi.no/</fr:meta><fr:meta name="slides">/bafkrmielsxg42lagb5fu2zymlfcvlvyqpvclrzc3kre6dszhwpgvdxuum4.pdf</fr:meta><fr:meta name="venue"><fr:link href="/catmi-2023/" title="Category Theory at Work in Computational Mathematics and Theoretical Informatics" uri="https://www.jonmsterling.com/catmi-2023/" display-uri="catmi-2023" type="local">Category Theory at Work in Computational Mathematics and Theoretical Informatics</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It is easy to teach a student how to give a naïve denotational semantics to a language like System T, and then use it to reason about the equational theory: a type might as well be a set, and a program might as well be a function, and equational adequacy at base type is established using a logical relation between the initial model and the category of sets. Adding any non-trivial feature to this language (e.g. general recursion, polymorphism, state, etc.) immediately increases the difficulty beyond the facility of a beginner: to add recursion, one must replace sets and functions with domains and continuous maps, and to accommodate polymorphism and state, one must pass to increasingly inaccessible variations on this basic picture.</html:p><html:p>The dream of the 1990s was to find a category that behaves like <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex> in which even general recursive and effectful programming languages could be given naïve denotational semantics, where types are interpreted as “sets” and programs are interpreted as a “functions”, without needing to check any arduous technical conditions like continuity. The benefit of this <html:strong>synthetic domain theory</html:strong> is not only that it looks “easy” for beginners, as more expert-level constructions like powerdomains or even domain equations for recursively defined semantic worlds become simple and direct. Although there have been starts and stops, the dream of synthetic domain theory is alive and well in the 21st Century. Today’s synthetic domain theory is, however, both more modular and more powerful than ever before, and has yielded significant results in programming language semantics including simple denotational semantics for an state of the art programming language with higher-order polymorphism, dependent types, recursive types, general reference types, and first-class module packages that can be stored in the heap.</html:p><html:p>In this talk, I will explain some important classical results in synthetic domain theory as well as more recent results that illustrate the potential impact of “naïve denotational semantics” on the life of a workaday computer scientist.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2023-fics/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2023-fics</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2023-fics/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmig7pcke5cku7gmwwyfiufvq3ryetshmedkgwkup7qdeorpahsdilq.pdf</fr:meta><fr:meta name="venue">Fixed Points in Computer Science 2023</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an
equational theory for general (higher-order) reference types and recursive types, based on a
combination of guarded recursion and impredicative polymorphism; because our model is based on
<html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning
about stateful abstract datatypes. What is new in relation to prior typed denotational models of
higher-order store is that our Kripke worlds need not be syntactically definable, and are thus
compatible with relational reasoning in the heap. Our work combines recent advances in the
operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>12</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-pujet-workshop/</fr:uri><fr:display-uri>sterling-2022-pujet-workshop</fr:display-uri><fr:route>/sterling-2022-pujet-workshop/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiajrzaq3g6iptivu37xqg6kfcxs32gvwnwqzrrzpp5g5cnvyhsfgy.pdf</fr:meta><fr:meta name="venue">Workshop on Dependent Type Theory (to celebrate the Defense of <fr:link href="/lo%C3%AFcpujet/" title="Loïc Pujet" uri="https://www.jonmsterling.com/loïcpujet/" display-uri="loïcpujet" type="local">Loïc Pujet</fr:link>)</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for <fr:link href="/gratzer-sterling-angiuli-coquand-birkedal-2022/" title="Controlling unfolding in type theory" uri="https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/" display-uri="gratzer-sterling-angiuli-coquand-birkedal-2022" type="local">controlling the unfolding of definitions in dependent type theory</fr:link>. Traditionally, proof assistants let users specify whether each definition can or cannot be unfolded in the remainder of a development; unfolding definitions is often necessary in order to reason about them, but an excess of unfolding can result in brittle proofs and intractably large proof goals. In our system, definitions are by default not unfolded, but users can selectively unfold them in a local manner. We justify our mechanism by means of elaboration to a core type theory with <html:em>extension types</html:em>, a connective first introduced in the context of homotopy type theory.  We prove a normalization theorem for our core calculus and have implemented our system in the cooltt proof assistant, providing both theoretical and practical evidence for it.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Seminar talks">Seminar talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>4</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-logsem/</fr:uri><fr:display-uri>sterling-2023-logsem</fr:display-uri><fr:route>/sterling-2023-logsem/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiczxyoaqvsobp544cpqfjrr5tisnm36cmkyb2pykcw5owku7hzoai.pdf</fr:meta><fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines guarded recursion (the "later" modality) with impredicative polymorphism (universal and existential types). It turns out that these two features are sufficient to define a very simple denotational semantics for System F with recursive types and higher-order store. We believe that the expressivity of iGDTT brings us one step closer to a general metalanguage for realistic denotational semantics, and provides a compelling strategy to elude the burden of operational semantics. As a further benefit, we are now able to justify the extension of full dependent type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-cambridge/</fr:uri><fr:display-uri>sterling-2023-cambridge</fr:display-uri><fr:route>/sterling-2023-cambridge/</fr:route><fr:title text="Crossing boundaries in program semantics">Crossing boundaries in program semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiaqido7bsry3bs2tnh5rtwa3ozf4wpm3zui46pneusslkxoh46nza.pdf</fr:meta><fr:meta name="venue"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>The great semanticist John Reynolds famously wrote in 1983 that “type structure is a syntactic
discipline for enforcing levels of abstraction”. If the last twenty years of programming language
semantics and verification have taught us anything, it is that we also need a syntactic discipline
for breaking abstraction — in other words, a way to glue together programs and verifications that
cut across abstraction barriers.</html:p><html:p>In programming language semantics and verification, the problem of combining multiple levels of
abstraction arises when choosing a “level of detail” at which to view program execution:
for instance, one could look at program execution as a detailed operational process of
discrete steps evincing the cost or complexity of an algorithm, or one could think of
it more abstractly as a black box that only sends inputs to outputs. The difficulty is
that in practice, verifications tend to cut across this barrier between complexity
and functional correctness: for instance, complexity bounds often depend on the
functional correctness of subroutines, and the existence of such a bound implies
termination (a correctness property).</html:p><html:p>For this reason, it is crucial to develop integrated logical foundations for <html:strong>soundly</html:strong> reasoning
using multiple models of execution at the same time, even when they expose different facets of
a program's meaning. For the past three years, my research program has been to uncover and
exploit the basic “laws of motion” governing all such abstraction barriers, which has led
to the solution of a few significant open problems in homotopy type theory and modal type
theory, as well as some preliminary applications to security and cost analysis.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>2</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2023-birmingham/</fr:uri><fr:display-uri>sterling-2023-birmingham</fr:display-uri><fr:route>/sterling-2023-birmingham/</fr:route><fr:title text="New spaces for denotational semantics">New spaces for denotational semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmihzmtwc65afir3o7ttpmckh5xakkorwpwjj6x5eg4hascotp456ke.pdf</fr:meta><fr:meta name="venue">University of Birmingham</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>11</fr:month><fr:day>8</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-itu/</fr:uri><fr:display-uri>sterling-2022-itu</fr:display-uri><fr:route>/sterling-2022-itu/</fr:route><fr:title text="Denotational semantics in impredicative guarded dependent type theory">Denotational semantics in impredicative guarded dependent type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmigiix5np3fp4npmgxvmx7kl7nb52ieyiazbwdxh6amdbfxdhnp2fy.pdf</fr:meta><fr:meta name="venue">Programming, Logic and Semantics, ITU Copenhagen</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Impredicative guarded dependent type theory (iGDTT) is a new version of type theory that combines
<html:em>guarded recursion</html:em> (the "later" modality) with <html:em>impredicative polymorphism</html:em> (universal and existential types).
It turns out that these two features are sufficient to define a very simple denotational semantics for
System F with recursive types and higher-order store. We believe that the expressivity of iGDTT
brings us one step closer to a general metalanguage for realistic denotational semantics,
and provides a compelling strategy to elude the burden of operational semantics.
As a further benefit, we are now able to justify the extension of full dependent
type theory with a Haskell-style <html:code>IO</html:code>-monad and <html:code>IORef</html:code> types.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>12</fr:day></fr:date><fr:title text="Roladex">Roladex</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri><fr:display-uri>jonmsterling</fr:display-uri><fr:route>/jonmsterling/</fr:route><fr:title text="Jon Sterling">Jon Sterling</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta><fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta><fr:meta name="orcid">0000-0002-0585-5564</fr:meta><fr:meta name="position">Associate Professor</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="postdoc-advisor">larsbirkedal</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p><html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>8</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>https://www.jonmsterling.com/jms-0075/</fr:uri>
            <fr:display-uri>jms-0075</fr:display-uri>
            <fr:route>/jms-0075/</fr:route>
            <fr:title text="TypeSynth final report"><fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> final report</fr:title>
            <fr:taxon>Report</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This is the final report for the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> MSCA project.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0076/</fr:uri>
                <fr:display-uri>jms-0076</fr:display-uri>
                <fr:route>/jms-0076/</fr:route>
                <fr:title text="Context and overall objectives">Context and overall objectives</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Software systems mediate a growing proportion of human activity, e.g. communication, transport, medicine, industrial and agricultural production, etc. As a result, it is urgent to understand and better control both the correctness and security properties of these increasingly complex software systems. The diversity of verification requirements speaks to a need for models of program execution that smoothly interpolate between many different levels of abstraction. Models of program execution vary in expressiveness along the spectrum of possible programming languages and specification logics. At one extreme, dependent type theory is a language for mathematically-inspired functional programming that is sufficiently expressive to serve as its own specification logic. Dependent type theory has struggled, however, to incorporate several computational effects that are common in every-day programming languages, such as state and concurrency. One of the most extreme forms of computational effect is “higher-order mutable state”, which is when programs can read and write data as well as entire subroutines to the computer’s memory during execution.  Programming languages that support these features require very sophisticated specification logics due to the myriad details that must be surfaced in their semantic models.</html:p>
                <html:p>Recently there have been several significant technical advances in mathematical semantics for programming languages that have been ripe for exploitation. For instance, in <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral thesis</fr:link> I developed a new technique called <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link> or “STC” that smoothly combines multiple levels of abstraction into a single language. Inspired by sophisticated mathematical techniques invented in topos theory and category theory for entirely different purposes, STC enables low-level details (even down to execution steps) to be manipulated in a simpler and more abstract way than ever before, making them easier to control mathematically. Perhaps more importantly, the STC method makes it possible to import ideas and techniques from other mathematical fields that are comparatively more developed than programming languages. Another related advance is the use of <fr:link href="/bmss-2011/" title="First steps in synthetic guarded domain theory: step-indexing in the topos of trees" uri="https://www.jonmsterling.com/bmss-2011/" display-uri="bmss-2011" type="local">Synthetic Guarded Domain Theory</fr:link> or “SGDT” as a mathematical language in which to describe and reason about the behavior of computer programs, potentially exhibiting complex interactions with their environment and with other programs. A third advance setting the stage for this project is the development of <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Univalent Foundations and Homotopy Type Theory</fr:link>, a new and backwards-compatible foundation of mathematics that places symmetries and reversible transformations of mathematical structures in the forefront.</html:p>
                <html:p>The goal of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been to combine these three ideas to break a long-standing logjam in the mathematical understanding of computer programming: the denotational semantics and equational separation logic of higher-order mutable state.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-0077/</fr:uri>
                <fr:display-uri>jms-0077</fr:display-uri>
                <fr:route>/jms-0077/</fr:route>
                <fr:title text="Work performed and main achievements">Work performed and main achievements</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>I highlight the three main achievements of the TypeSynth project below:</html:p>
                <html:ol><html:li>a new denotational semantics of higher-order store;</html:li>
  <html:li>an equational higher-order separation logic based on the above denotational semantics;</html:li>
  <html:li>the extension of <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link> to support computational effects including guarded recursion and higher-order store.</html:li></html:ol>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0078/</fr:uri>
                    <fr:display-uri>jms-0078</fr:display-uri>
                    <fr:route>/jms-0078/</fr:route>
                    <fr:title text="Denotational semantics of higher-order store">Denotational semantics of higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>The <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> plan to develop denotational semantics of higher-order store had two components: the first was to develop a practical semantic model of polymorphic higher-order store without garbage collection, and the second was to extend this model to support the equational theory of garbage collection. For the former, the results have greatly outstripped expectations: I have succeeded in constructing not only the indended model of store with polymorphism, but in fact a <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">model of full dependent type theory with higher-order store</fr:link> — posing the prospect for being able to write and verify the correctness of programs in the same language. This result is the first of its kind for higher-order store, and is a significant advance. In the final months of the project, we have also gone further beyond this result in a different direction, and constructed a version of the model of higher-order store satisfying a new gamut of compelling representation independence equations which I refer to as the theory of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link>: in short, two programs can be considered equal even if they allocate memory cells of different types, so long as the two types are in bijection and programs' interaction with the memory cell respects this bijection.</html:p>
                    <html:p>I have begun to extend these results to include the equational theory of garbage collection, but as the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has been terminated nearly one year early (due to my recent appointment as Associate Professor at University of Cambridge), this further exploitation of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> methodology will continue beyond the conclusion of the project.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-0079/</fr:uri>
                    <fr:display-uri>jms-0079</fr:display-uri>
                    <fr:route>/jms-0079/</fr:route>
                    <fr:title text="Equational higher-order separation logic for higher-order store">Equational higher-order separation logic for higher-order store</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In collaboration with my colleagues <fr:link href="/flaagaard/" title="Frederik Lerbjerg Aagaard" uri="https://www.jonmsterling.com/flaagaard/" display-uri="flaagaard" type="local">Frederik Ljerbjerg Aagaard</fr:link> and <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Professor Lars Birkedal</fr:link>, I have developed a <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">guarded higher-order separation logic called TULIP</fr:link> over the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">denotational model of higher-order store</fr:link>. This logic represents a significant step forward in the march toward simple, abstract, and compositional reasoning about higher-order stateful programs. Prior program logics (such as Iris and the Verified Software Toolchain) interact with computer programs only indirectly, by verifying properties of a specific “transition function” that simulates the steps that a (highly idealized) computer would take when executing a program; this style is called “operational”. Unfortunately, the important structural properties of programs are highly unnatural to express at the level of transition steps, and as such, existing operationally-based program logics impose a great deal of bureaucracy by forcing those verifying programs to manually mediate the mismatch between the viewpoint of the machine (which cannot see program structure), and the viewpoint of the programmer (which is entirely based on program structure). An equational, or "denotationally-based", program logic like <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> instead treats programs directly without needing to pass through an encoding in terms of machine transitions. An immediate benefit of the equational approach is that program equivalences can be glued together directly in any context, a kind of practical compositionality that is unique to equational and denotationally-based program logics. Our development of the <fr:link href="/aagaard-sterling-birkedal-2023/" title="A denotationally-based program logic for higher-order store" uri="https://www.jonmsterling.com/aagaard-sterling-birkedal-2023/" display-uri="aagaard-sterling-birkedal-2023" type="local">TULIP</fr:link> logic is a strong first step in this direction.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2023</fr:year>
                      <fr:month>8</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>https://www.jonmsterling.com/jms-007A/</fr:uri>
                    <fr:display-uri>jms-007A</fr:display-uri>
                    <fr:route>/jms-007A/</fr:route>
                    <fr:title text="Effectful synthetic Tait computability">Effectful <fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">synthetic Tait computability</fr:link></fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>A third achievement of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project was to extend the highly successful “<fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">Synthetic Tait Computability</fr:link>” method, developed in my <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">doctoral thesis</fr:link>, to the case of realistic programming languages with computational effects. The purpose of this extension was to achieve strong representation independence results, by which we can show the computational indistinguishability of even two programs that allocate memory cells of different types that are linked not by a bijection but by a mere relation, in contrast to univalent reference types. We have gone quite a bit beyond our expectations, as our account of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local"><fr:link href="/jms-005T/" title="Synthetic Tait computability" uri="https://www.jonmsterling.com/jms-005T/" display-uri="jms-005T" type="local">STC</fr:link> for higher-order store</fr:link> applies not only to the simple polymorphic store model, but also to the full dependent type theory. This allows many classic results from the literature that previously required very complicated reasoning with the semantic model to be reconstructed in a simpler and more direct fashion.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007B/</fr:uri>
                <fr:display-uri>jms-007B</fr:display-uri>
                <fr:route>/jms-007B/</fr:route>
                <fr:title text="Results beyond the state of the art">Results beyond the state of the art</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The results of the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project have gone significantly beyond the state of the art in denotational semantics for computational effects: not only is ours the first typed denotational model of higher-order store compatible with parametric polymorphism, but we have shown that the same construction also gives rise to a model of <fr:link href="/sterling-gratzer-birkedal-2022/" title="Denotational semantics of general store and polymorphism" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/" display-uri="sterling-gratzer-birkedal-2022" type="local">full dependent type theory with higher-order store</fr:link> — a long sought-after result whose implications we have not yet fully exploited. Our model of <fr:link href="/sterling-gratzer-birkedal-2024-univalent/" title="Towards univalent reference types" uri="https://www.jonmsterling.com/sterling-gratzer-birkedal-2024-univalent/" display-uri="sterling-gratzer-birkedal-2024-univalent" type="local">“univalent reference types”</fr:link> is also a significant break with the state of the art, and points the way to a new and more fruitful interaction between the fields of programming languages on the one hand, and homotopy type theory and algebraic topology on the other hand.</html:p>
                <html:p>The <fr:link href="/jms-0077/" title="Work performed and main achievements" uri="https://www.jonmsterling.com/jms-0077/" display-uri="jms-0077" type="local">technical achievements</fr:link> of <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> point to healthy growth in the long-neglected area of denotational semantics and equational program logics, but there is an urgent need for further research to bring these superior but comparatively less-developed methods to practical parity with the more established operational paradigm, which currently achieves stronger results in program verification — which we believe can be accounted for by the twenty-year headstart enjoyed by teams favoring operational methods during the relative dormancy of semantic and categorical methods in programming languages.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2023</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/jms-007C/</fr:uri>
                <fr:display-uri>jms-007C</fr:display-uri>
                <fr:route>/jms-007C/</fr:route>
                <fr:title text="Policy relevant evidence of the project">Policy relevant evidence of the project</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Research in program semantics and verification is essentially of two kinds. On the one hand, there is work that pushes the envelope of what kinds of programs can be verified — demonstrating (at great exertion and expense) the potential to verify the correctness of the extremely complex software that makes our society work, including onboard software used in air planes, industrial production, agricultural production, artificial intelligence, etc.  On the other hand, there is research that aims to rethink from the ground up the mathematical understanding of programming, radically simplifying the foundations on which the program verification tools are built. Both kinds of research are important and rely heavily on each other. Applied program verification is critical because the need to prevent software faults is ever-present, and in order to get any kind of uptake and adoption, we must demonstrate the capability of our tools to handle the very complex problems that are raised by industrial and governmental use of software. Likewise, foundational research is extremely important because when applied program verification hits its conceptual limitations, it can only advance by becoming bigger and more expensive — requiring larger and larger teams and budgets to make smaller and smaller incremental improvements. In just one year, the <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">TypeSynth</fr:link> project has achieved (through careful attention to building bridges between different mathematical disciplines) what many researchers in this area considered impossible or at least significantly farther off in the future; this experience must be replicated with further grants and fellowships to theoretically and foundationally minded researchers who are willing to undertake interdisciplinary work.</html:p>
                <html:p>At the present time, my perception is that applied program verification is significantly more intelligible to funders and agencies because it speaks directly to the fears and concerns that we all have for our society in the age of software domination, artificial intelligence, and quantum computing; this is understandable, but it has regrettably led to the neglect of foundational research at the time when it is most urgent — it is now that we must lay the foundations for the next generation of program verifiers, before rather than after applied work in program verification reaches the hard limitations that more theoretically-oriented researchers have been working to remove. Therefore, I urge the European Commission and relevant policy makers to increase their consideration of foundational research as an investment in the future, alongside their continued funding of the very important applied direction in program semantics and verification.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jms-00GC/</fr:uri>
            <fr:display-uri>jms-00GC</fr:display-uri>
            <fr:route>/jms-00GC/</fr:route>
            <fr:title text="Aarhus University">Aarhus University</fr:title>
            <fr:taxon>Institution</fr:taxon>
            <fr:meta name="external">https://www.au.dk/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri>
            <fr:display-uri>jonmsterling</fr:display-uri>
            <fr:route>/jonmsterling/</fr:route>
            <fr:title text="Jon Sterling">Jon Sterling</fr:title>
            <fr:taxon>Person</fr:taxon>
            <fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta>
            <fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta>
            <fr:meta name="orcid">0000-0002-0585-5564</fr:meta>
            <fr:meta name="position">Associate Professor</fr:meta>
            <fr:meta name="phd-advisor">robertharper</fr:meta>
            <fr:meta name="postdoc-advisor">larsbirkedal</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p>
            <html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://www.jonmsterling.com/jms-005T/</fr:uri>
            <fr:display-uri>jms-005T</fr:display-uri>
            <fr:route>/jms-005T/</fr:route>
            <fr:title text="Synthetic Tait computability">Synthetic Tait computability</fr:title>
            <fr:taxon>Bibliography</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>This page collects papers and dissertations about Synthetic Tait Computability, also known as the <html:em>logical relations as types</html:em> / LRAT principle; if you have written a paper or dissertation on this topic, please <fr:link href="mailto:jon@jonmsterling.com" type="external">write to me</fr:link> to have it added to this list.</html:p>
  
  

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Accepted papers">Accepted papers</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Refereed papers">Refereed papers</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>8</fr:month><fr:day>13</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2025-grothendieck/</fr:uri><fr:display-uri>sterling-2025-grothendieck</fr:display-uri><fr:route>/sterling-2025-grothendieck/</fr:route><fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.1007/978-3-031-68934-5_15</fr:meta><fr:meta name="venue">Chapter contributed to <html:em>The Mathematical and Philosophical Legacy of Alexander Grothendieck</html:em>, postproceedings of the Chapman <fr:link href="/chapman-grothendieck-2022/" title="Grothendieck Conference" uri="https://www.jonmsterling.com/chapman-grothendieck-2022/" display-uri="chapman-grothendieck-2022" type="local">Grothendieck Conference</fr:link>.</fr:meta><fr:meta name="bibtex"><![CDATA[@inbook{sterling:2025:grothendieck,
  author = {Sterling, Jonathan},
  editor = {Panza, Marco and Struppa, Daniele C. and Szczeciniarz, Jean-Jacques},
  location = {Cham},
  publisher = {Springer Nature Switzerland},
  booktitle = {The Mathematical and Philosophical Legacy of Alexander Grothendieck},
  date = {2025},
  doi = {10.1007/978-3-031-68934-5_15},
  eprint = {2307.09497},
  eprinttype = {arXiv},
  isbn = {978-3-031-68934-5},
  pages = {391--432},
  title = {Toward a Geometry for Syntax},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>It often happens that free algebras for a given theory satisfy useful reasoning principles that are not preserved under homomorphisms of algebras, and hence need not hold in an arbitrary algebra. For instance, if <fr:tex display="inline"><![CDATA[M]]></fr:tex> is the free monoid on a set <fr:tex display="inline"><![CDATA[A]]></fr:tex>, then the scalar multiplication function <fr:tex display="inline"><![CDATA[A\times  M\to  M]]></fr:tex> is injective. Therefore, when reasoning in the formal theory of monoids under <fr:tex display="inline"><![CDATA[A]]></fr:tex>, it is possible to use this injectivity law to make sound deductions even about monoids under A for which scalar multiplication is not injective — a principle known in algebra as the permanence of identity. Properties of this kind are of fundamental practical importance to the logicians and computer scientists who design and implement computerized proof assistants like Lean and Coq, as they enable the formal reductions of equational problems that make type checking tractable.</html:p><html:p>As type theories have become increasingly more sophisticated, it has become more and more difficult to establish the useful properties of their free models that facilitate effective implementation. These obstructions have facilitated a fruitful return to foundational work in type theory, which has taken on a more geometrical flavor than ever before. Here we expose a modern way to prove a highly non-trivial injectivity law for free models of Martin-Löf type theory, paying special attention to the ways that contemporary methods in type theory have been influenced by three important ideas of the Grothendieck school: the relative point of view, the language of universes, and the recollement of generalized spaces.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link></fr:author><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>1</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/</fr:uri><fr:display-uri>grodin-niu-sterling-harper-2024</fr:display-uri><fr:route>/grodin-niu-sterling-harper-2024/</fr:route><fr:title text=" decalf: a directed, effectful cost-aware logical framework"><![CDATA[ decalf]]>: a directed, effectful cost-aware logical framework</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/popl-2024/" title="POPL ’24: 51st ACM SIGPLAN Symposium on Principles of Programming Languages" uri="https://www.jonmsterling.com/popl-2024/" display-uri="popl-2024" type="local"><html:em>POPL ’24</html:em>: 51st ACM SIGPLAN Symposium on Principles of Programming Languages</fr:link></fr:meta><fr:meta name="doi">10.1145/3632852</fr:meta><fr:meta name="external">https://arxiv.org/abs/2307.05938</fr:meta><fr:meta name="bibtex"><![CDATA[@article{grodin-niu-sterling-harper-2024,
  author = {Grodin, Harrison and Niu, Yue and Sterling, Jonathan and Harper, Robert},
  title = {Decalf: A Directed, Effectful Cost-Aware Logical Framework},
  year = {2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {POPL},
  doi = {10.1145/3632852},
  journal = {Proc. ACM Program. Lang.},
  month = {jan},
  articleno = {10},
  numpages = {29},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present <html:strong>decalf</html:strong>, a <html:strong>d</html:strong>irected, <html:strong>e</html:strong>ffectful <html:strong>c</html:strong>ost-<html:strong>a</html:strong>ware <html:strong>l</html:strong>ogical <html:strong>f</html:strong>ramework for studying quantitative aspects of functional programs with effects.  Like <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the language is based on a formal <html:em>phase distinction</html:em> between the <html:em>extension</html:em> and the <html:em>intension</html:em> of a program, its pure <html:em>behavior</html:em> as distinct from its <html:em>cost</html:em> measured by an effectful step-counting primitive. The type theory ensures that the behavior is unaffected by the cost accounting.  Unlike <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>, the present language takes account of <html:em>effects</html:em>, such as probabilistic choice and mutable state; this extension requires a reformulation of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local"><html:strong>calf</html:strong></fr:link>’s approach to cost accounting: rather than rely on a “separable” notion of cost, here <html:em>a cost bound is simply another program</html:em>. To make this formal, we equip every type with an intrinsic preorder, relaxing the precise cost accounting intrinsic to a program to a looser but nevertheless informative estimate.  For example, the cost bound of a probabilistic program is itself a probabilistic program that specifies the distribution of costs.  This approach serves as a streamlined alternative to the standard method of isolating a recurrence that bounds the cost in a manner that readily extends to higher-order, effectful programs.</html:p><html:p>The development proceeds by first introducing the <html:strong>decalf</html:strong> type system, which is based on an intrinsic ordering among terms that restricts in the extensional phase to extensional equality, but in the intensional phase reflects an approximation of the cost of a program of interest.  This formulation is then applied to a number of illustrative examples, including pure and effectful sorting algorithms, simple probabilistic programs, and higher-order functions.  Finally, we justify <html:strong>decalf</html:strong> via a model in the topos of augmented simplicial sets.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-012Q/</fr:uri><fr:display-uri>jms-012Q</fr:display-uri><fr:route>/jms-012Q/</fr:route><fr:title text="Missing assumptions about the interval in Decalf">Missing assumptions about the interval in <fr:link href="/grodin-niu-sterling-harper-2024/" title=" decalf: a directed, effectful cost-aware logical framework" uri="https://www.jonmsterling.com/grodin-niu-sterling-harper-2024/" display-uri="grodin-niu-sterling-harper-2024" type="local">Decalf</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In section 4.2, we assumed only a (non-strict) interval object <fr:tex display="inline"><![CDATA[\mathbb {I}]]></fr:tex>, and then asserted in Definition 4.5 the map <fr:tex display="inline"><![CDATA[(-=1)\colon  \mathbb {I}\to \Omega ]]></fr:tex> was a monomorphism. Obviously, this need not be the case, so it needs to be turned into an assumption about <fr:tex display="inline"><![CDATA[(\mathcal {E},\mathbb {I})]]></fr:tex>. This assumption will, however, hold of the interval in simplicial sets for the following reason: the interval in simplicial sets is the <html:em>nerve</html:em> of the actual poset <fr:tex display="inline"><![CDATA[\{0<1\}]]></fr:tex>, and the statement in question holds for this poset and is preserved by the nerve functor.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/taichiuemura/" title="Taichi Uemura" uri="https://www.jonmsterling.com/taichiuemura/" display-uri="taichiuemura" type="local">Taichi Uemura</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>12</fr:month><fr:day>5</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/uemura-2023-fscd/</fr:uri><fr:display-uri>uemura-2023-fscd</fr:display-uri><fr:route>/uemura-2023-fscd/</fr:route><fr:title text="Homotopy type theory as internal languages of diagrams of ∞-logoses">Homotopy type theory as internal languages of diagrams of ∞-logoses</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@inproceedings{uemura-2023-fscd,
  author = {Uemura, Taichi},
  editor = {Gaboardi, Marco and van Raamsdonk, Femke},
  address = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f\"{u}r Informatik},
  url = {https://drops.dagstuhl.de/opus/volltexte/2023/17989},
  booktitle = {8th International Conference on Formal Structures for Computation and Deduction (FSCD 2023)},
  year = {2023},
  doi = {10.4230/LIPIcs.FSCD.2023.5},
  isbn = {978-3-95977-277-8},
  issn = {1868-8969},
  pages = {5:1--5:19},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {{Homotopy Type Theory as Internal Languages of Diagrams of $\infty$-Logoses}},
  volume = {260}
}]]></fr:meta><fr:meta name="doi">10.4230/LIPIcs.FSCD.2023.5</fr:meta><fr:meta name="venue">8th International Conference on Formal Structures for Computation and Deduction (FSCD 2023)</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>9</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/niu-harper-2022/</fr:uri><fr:display-uri>niu-harper-2022</fr:display-uri><fr:route>/niu-harper-2022/</fr:route><fr:title text="A metalanguage for cost-aware denotational semantics">A metalanguage for cost-aware denotational semantics</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2209.12669</fr:meta><fr:meta name="venue">Thirty-Eighth Annual ACM/IEEE Symposium on
Logic in Computer Science (LICS)</fr:meta><fr:meta name="bibtex"><![CDATA[@article{niu-harper-2022,
  doi = {10.48550/ARXIV.2209.12669},
  author = {Niu, Yue and Harper, Robert},
  title = {A metalanguage for cost-aware denotational semantics},
  publisher = {arXiv},
  year = {2022},
}]]></fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>4</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-birkedal-2022/</fr:uri><fr:display-uri>gratzer-birkedal-2022</fr:display-uri><fr:route>/gratzer-birkedal-2022/</fr:route><fr:title text="A stratified approach to Löb induction">A stratified approach to Löb induction</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@inproceedings{gratzer-birkedal-2022,
  author = {Gratzer, Daniel and Birkedal, Lars},
  editor = {Felty, Amy},
  address = {Dagstuhl, Germany},
  publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  url = {https://jozefg.github.io/papers/a-stratified-approach-to-lob-induction.pdf},
  booktitle = {7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)},
  year = {2022},
  month = aug,
  doi = {10.4230/LIPIcs.FSCD.2022.23},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title = {A Stratified Approach to {L\"{o}b} Induction},
  volume = {228},
}]]></fr:meta><fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.23</fr:meta><fr:meta name="venue">International Conference on Formal Structures for Computation and Deduction (FSCD)</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>4</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-2022/</fr:uri><fr:display-uri>gratzer-2022</fr:display-uri><fr:route>/gratzer-2022/</fr:route><fr:title text="Normalization for multimodal type theory">Normalization for multimodal type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@inproceedings{gratzer-2022,
  title = {Normalization for Multimodal Type Theory},
  author = {Gratzer, Daniel},
  address = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  booktitle = {Proceedings of the 37th Annual ACM/IEEE Symposium on Logic in Computer Science},
  year = {2022},
  doi = {10.1145/3531130.3532398},
  url = {https://jozefg.github.io/papers/2022-normalization-for-multimodal-type-theory-short.pdf},
}]]></fr:meta><fr:meta name="doi">10.1145/3531130.3532398</fr:meta><fr:meta name="venue">Symposium on Logic and Computer Science (LICS)</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>1</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/</fr:uri><fr:display-uri>niu-sterling-grodin-harper-2022</fr:display-uri><fr:route>/niu-sterling-grodin-harper-2022/</fr:route><fr:title text="A cost-aware logical framework">A cost-aware logical framework</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/pacmpl/" title="Proceedings of the ACM on Programming Languages" uri="https://www.jonmsterling.com/pacmpl/" display-uri="pacmpl" type="local">Proceedings of the ACM on Programming Languages</fr:link>, Volume 6, Issue POPL</fr:meta><fr:meta name="doi">10.1145/3498670</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present calf, a cost-aware logical framework for studying quantitative aspects of functional programs. Taking inspiration from recent work that reconstructs traditional aspects of programming languages in terms of a modal account of phase distinctions, we argue that the cost structure of programs motivates a phase distinction between intension and extension. Armed with this technology, we contribute a synthetic account of cost structure as a computational effect in which cost-aware programs enjoy an internal noninterference property: input/output behavior cannot depend on cost. As a full-spectrum dependent type theory, calf presents a unified language for programming and specification of both cost and behavior that can be integrated smoothly with existing mathematical libraries available in type theoretic proof assistants.</html:p><html:p>We evaluate calf as a general framework for cost analysis by implementing two fundamental techniques for algorithm analysis: the method of recurrence relations and physicist’s method for amortized analysis. We deploy these techniques on a variety of case studies: we prove a tight, closed bound for Euclid’s algorithm, verify the amortized complexity of batched queues, and derive tight, closed bounds for the sequential and parallel complexity of merge sort, all fully mechanized in the Agda proof assistant. Lastly we substantiate the soundness of quantitative reasoning in calf by means of a model construction.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/sterling-harper-2022/</fr:uri><fr:display-uri>sterling-harper-2022</fr:display-uri><fr:route>/sterling-harper-2022/</fr:route><fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.4230/LIPIcs.FSCD.2022.5</fr:meta><fr:meta name="venue">7th International Conference on Formal Structures for Computation and Deduction (FSCD 2022)</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We propose a new sheaf semantics for secure information flow over a space of abstract behaviors, based on synthetic domain theory: security classes are open/closed partitions, types are sheaves, and redaction of sensitive information corresponds to restricting a sheaf to a closed subspace. Our security-aware computational model satisfies termination-insensitive noninterference automatically, and therefore constitutes an intrinsic alternative to state of the art extrinsic/relational models of noninterference. Our semantics is the latest application of <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link>’s recent re-interpretation of phase distinctions and noninterference in programming languages in terms of Artin gluing and topos-theoretic open/closed modalities. Prior applications include <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">parametricity for ML modules</fr:link>, the proof of normalization for cubical type theory by <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">Sterling and Angiuli</fr:link>, and the cost-aware logical framework of <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Niu et al</fr:link>. In this paper we employ the phase distinction perspective twice: first to reconstruct the syntax and semantics of secure information flow as a lattice of phase distinctions between “higher” and “lower” security, and second to verify the computational adequacy of our sheaf semantics with respect to a version of Abadi et al.’s dependency core calculus to which we have added a construct for declassifying termination channels.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/jms-005Y/</fr:uri><fr:display-uri>jms-005Y</fr:display-uri><fr:route>/jms-005Y/</fr:route><fr:title text="Minor mistakes in sheaf semantics of noninterference">Minor mistakes in <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>In the published version of this paper, there were a few mistakes that have been corrected in the local copy hosted here.</html:p><html:ol><html:li>In the <html:em>Critique of relational semantics for information flow</html:em>, our discussion of the <html:em>Failure of monotonicity</html:em> stated incorrectly that algebras for the sealing monad at a higher security level could not be transformed into algebras for the sealing monad at a lower security level in the semantics of Abadi et al. This is not true, as pointed out to us privately by Carlos Tomé Cortiñas. What we meant to say was that it is not the case that a type whose component at a high security level is trivial shall always remain trivial at a lower security level.</html:li>
  <html:li>The original version of the extended edition of this paper, we claimed that the constructive existence of tensor products on pointed dcpos was obvious; in fact, tensor products do exist, but their construction involves a reflexive coequalizer of pointed dcpos.</html:li></html:ol></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>7</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri><fr:display-uri>jms-005Z</fr:display-uri><fr:route>/jms-005Z/</fr:route><fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>12</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-harper-2021/</fr:uri><fr:display-uri>sterling-harper-2021</fr:display-uri><fr:route>/sterling-harper-2021/</fr:route><fr:title text="Logical relations as types: proof-relevant parametricity for program modules">Logical relations as types: proof-relevant parametricity for program modules</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue"><fr:link href="/jacm/" title="Journal of the ACM" uri="https://www.jonmsterling.com/jacm/" display-uri="jacm" type="local">Journal of the ACM</fr:link>, Volume 68, Issue 6</fr:meta><fr:meta name="doi">10.1145/3474834</fr:meta></fr:frontmatter><fr:mainmatter><html:p>The theory of program modules is of interest to language designers not only for its practical importance to programming, but also because it lies at the nexus of three fundamental concerns in language design: the <html:em>phase distinction</html:em>, <html:em>computational effects</html:em>, and <html:em>type abstraction</html:em>. We contribute a fresh “synthetic” take on program modules that treats modules as the fundamental constructs, in which the usual suspects of prior module calculi (kinds, constructors, dynamic programs) are rendered as derived notions in terms of a modal type-theoretic account of the phase distinction. We simplify the account of type abstraction (embodied in the generativity of module functors) through a <html:em>lax modality</html:em> that encapsulates computational effects, placing <html:em>projectibility</html:em> of module expressions on a type-theoretic basis.</html:p><html:p>Our main result is a (significant) proof-relevant and phase-sensitive generalization of the Reynolds abstraction theorem for a calculus of program modules, based on a new kind of logical relation called a <html:em>parametricity structure</html:em>. Parametricity structures generalize the proof-irrelevant relations of classical parametricity to proof-<html:em>relevant</html:em> families, where there may be non-trivial evidence witnessing the relatedness of two programs—simplifying the metatheory of strong sums over the collection of types, for although there can be no “relation classifying relations,” one easily accommodates a “family classifying small families.”</html:p><html:p>Using the insight that logical relations/parametricity is itself a form of phase distinction between the syntactic and the semantic, we contribute a new synthetic approach to phase separated parametricity based on the slogan <html:em>logical relations as types</html:em>, by iterating our modal account of the phase distinction. We axiomatize a dependent type theory of parametricity structures using two pairs of complementary modalities (syntactic, semantic) and (static, dynamic), substantiated using the topos theoretic <html:em>Artin gluing</html:em> construction. Then, to construct a simulation between two implementations of an abstract type, one simply programs a third implementation whose type component carries the representation invariant.</html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/jms-0060/</fr:uri><fr:display-uri>jms-0060</fr:display-uri><fr:route>/jms-0060/</fr:route><fr:title text="Minor mistakes in logical relations as types">Minor mistakes in <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">logical relations as types</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>After going to press, we have fixed the following mistakes:</html:p><html:ol><html:li>In the definition of a logos, we mistakenly said that "colimits commute with finite limits" but we meant to say that they are preserved by pullback. We thank <fr:link href="/sarahzrf/" title="Sarah Z. Rovner-Frydman" uri="https://www.jonmsterling.com/sarahzrf/" display-uri="sarahzrf" type="local">Sarah Z. Rovner-Frydman</fr:link> for noticing this mistake.</html:li>
  <html:li>In Remark 5.15, we used the notation for the closed immersion prior to introducing it.</html:li>
  <html:li>We have fixed a few broken links in the bibliography.</html:li></html:ol><html:p>The local copy hosted here has the corrections implemented</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>7</fr:month><fr:day>7</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021/</fr:uri><fr:display-uri>sterling-angiuli-2021</fr:display-uri><fr:route>/sterling-angiuli-2021/</fr:route><fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">2021 36th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS)</fr:meta><fr:meta name="doi">10.1109/LICS52264.2021.9470719</fr:meta><fr:meta name="external">https://arxiv.org/abs/2101.11479</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. Our normalization result is reduction-free, in the sense of yielding a bijection between equivalence classes of terms in context and a tractable language of <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex>/<fr:tex display="inline"><![CDATA[\eta ]]></fr:tex>-normal forms. As corollaries we obtain both decidability of judgmental equality and the injectivity of type constructors.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Manuscripts">Manuscripts</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/treborhuang/" title="Trebor Huang" uri="https://www.jonmsterling.com/treborhuang/" display-uri="treborhuang" type="local">Trebor Huang</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>10</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/huang-2023/</fr:uri><fr:display-uri>huang-2023</fr:display-uri><fr:route>/huang-2023/</fr:route><fr:title text="Synthetic Tait computability the hard way">Synthetic Tait computability the hard way</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2310.02051</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We walk through a few proofs of canonicity and normalization, each one with more aspects dissected and re-expressed in category theory, so that readers can compare the difference across proofs. During this process we isolate the different ideas that make up the proofs. Finally we arrive at <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">synthetic Tait computability</fr:link> as proposed by <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">J. Sterling</fr:link>. We also give a synthetic proof for parametricity of system F.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/taichiuemura/" title="Taichi Uemura" uri="https://www.jonmsterling.com/taichiuemura/" display-uri="taichiuemura" type="local">Taichi Uemura</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>12</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/uemura-2022-coh/</fr:uri><fr:display-uri>uemura-2022-coh</fr:display-uri><fr:route>/uemura-2022-coh/</fr:route><fr:title text="Normalization and coherence for ∞-type theories">Normalization and coherence for ∞-type theories</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{uemura-2022-coh,
  doi = {10.48550/ARXIV.2212.11764},
  author = {Uemura, Taichi},
  title = {Normalization and coherence for $\infty$-type theories},
  publisher = {arXiv},
  year = {2022},
}]]></fr:meta><fr:meta name="doi">10.48550/arXiv.2212.11764</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author><fr:author><fr:link href="/thierrycoquand/" title="Thierry Coquand" uri="https://www.jonmsterling.com/thierrycoquand/" display-uri="thierrycoquand" type="local">Thierry Coquand</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:uri><fr:display-uri>gratzer-sterling-angiuli-coquand-birkedal-2022</fr:display-uri><fr:route>/gratzer-sterling-angiuli-coquand-birkedal-2022/</fr:route><fr:title text="Controlling unfolding in type theory">Controlling unfolding in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.05420</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-sterling-angiuli-coquand-birkedal-2022,
  doi = {10.48550/ARXIV.2210.05420},
  author = {Gratzer, Daniel and Sterling, Jonathan and Angiuli, Carlo and Coquand, Thierry and Birkedal, Lars},
  title = {Controlling unfolding in type theory},
  year = {2022},
  note = {Unpublished manuscript}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We present a novel mechanism for controlling the unfolding of definitions in
dependent type theory. Traditionally, proof assistants let users specify
whether each definition can or cannot be unfolded in the remainder of a
development; unfolding definitions is often necessary in order to reason about
them, but an excess of unfolding can result in brittle proofs and intractably
large proof goals. In our system, definitions are by default not unfolded, but
users can selectively unfold them in a local manner. We justify our mechanism
by means of elaboration to a core type theory with <html:em>extension types</html:em>, a
connective first introduced in the context of homotopy type theory.  We prove a
normalization theorem for our core calculus and have implemented our system in
the cooltt proof assistant, providing both theoretical and practical evidence
for it.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author><fr:author><fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>10</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-gratzer-birkedal-2022/</fr:uri><fr:display-uri>sterling-gratzer-birkedal-2022</fr:display-uri><fr:route>/sterling-gratzer-birkedal-2022/</fr:route><fr:title text="Denotational semantics of general store and polymorphism">Denotational semantics of general store and polymorphism</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="doi">10.48550/arXiv.2210.02169</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-gratzer-birkedal-2022,
  author = {Sterling, Jonathan and Gratzer, Daniel and Birkedal, Lars},
  year = {2022},
  month = jul,
  note = {Unpublished manuscript},
  title = {Denotational semantics of general store and polymorphism},
}]]></fr:meta></fr:frontmatter><fr:mainmatter><html:p>We contribute the first denotational semantics of polymorphic dependent type theory extended by an equational theory for general (higher-order) reference types and recursive types, based on a combination of guarded recursion and impredicative polymorphism; because our model is based on <html:em>recursively defined semantic worlds</html:em>, it is compatible with polymorphism and relational reasoning about stateful abstract datatypes. We then extend our language with modal constructs for proof-relevant relational reasoning based on the <html:em>logical relations as types</html:em> principle, in which equivalences between imperative abstract datatypes can be established synthetically. Finally we develop a decomposition of the store model as a general construction that extends an arbitrary polymorphic call-by-push-value adjunction with higher-order store, improving on <fr:link href="/paulblainlevy/" title="Paul Blain Levy" uri="https://www.jonmsterling.com/paulblainlevy/" display-uri="paulblainlevy" type="local">Levy</fr:link>'s possible worlds model construction; what is new in relation to prior typed denotational models of higher-order store is that our Kripke worlds need not be syntactically definable, and are thus compatible with relational reasoning in the heap. Our work combines recent advances in the operational semantics of state with the purely denotational viewpoint of <html:em>synthetic guarded domain theory</html:em>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-naive/</fr:uri><fr:display-uri>sterling-2022-naive</fr:display-uri><fr:route>/sterling-2022-naive/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-2022-naive,
  author = {Sterling, Jonathan},
  year = {2022},
  month = jun,
  note = {Unpublished manuscript},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta><fr:meta name="external">/bafkrmialyvkzh6w6snnzr3k4h2b62bztsk4le57idughqik24bltinieki.pdf</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-2021-crisp-induction/</fr:uri><fr:display-uri>gratzer-2021-crisp-induction</fr:display-uri><fr:route>/gratzer-2021-crisp-induction/</fr:route><fr:title text="Crisp induction for intensional identity types">Crisp induction for intensional identity types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="external">https://jozefg.github.io/papers/crisp-induction-for-intensional-identity-types.pdf</fr:meta><fr:meta name="bibtex"><![CDATA[@unpublished{gratzer-2021-crisp-induction,
  author = {Gratzer, Daniel},
  url = {https://jozefg.github.io/papers/crisp-induction-for-intensional-identity-types.pdf},
  year = {2021},
  note = {Unpublished manuscript},
  title = {Crisp induction for intensional identity types},
}]]></fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Dissertations">Dissertations</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/danielgratzer/" title="Daniel Gratzer" uri="https://www.jonmsterling.com/danielgratzer/" display-uri="danielgratzer" type="local">Daniel Gratzer</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>8</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/gratzer-2023-thesis/</fr:uri><fr:display-uri>gratzer-2023-thesis</fr:display-uri><fr:route>/gratzer-2023-thesis/</fr:route><fr:title text="Syntax and semantics of modal type theory">Syntax and semantics of modal type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">PhD Dissertation, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta><fr:meta name="external">https://iris-project.org/pdfs/2023-phd-gratzer.pdf</fr:meta></fr:frontmatter><fr:mainmatter><html:p>One idiosyncratic framing of type theory is as the study of operations invariant under substitution. Modal type theory, by contrast, concerns the controlled integration of operations—modalities—into type theory which violate this discipline, so-called <html:em>non-fibered connectives</html:em>. Modal type theory is therefore built around a fundamental tension: the desire to include modalities and powerful principles for reasoning with them on one hand, and the need to maintain the conveniences and character of Martin-Löf type theory which stem from substitution invariance.</html:p><html:p>In this thesis, we thoroughly explore and discuss this contradiction. We discuss several different formulations of modal type theory, explore their various syntactic properties, and relate them through their categorical semantics. In particular, we show that most modal type theories that have arisen in the last two decades can be understood through the abstraction of <html:em>weak dependent right adjoints</html:em>. We also put forward a new <html:em>general</html:em> modal type theory, MTT, based on this abstraction.</html:p><html:p>The generality of MTT means that, without any additional work, it can be specialized to an arbitrary collection of type theories related by modalities and natural transformations between them. It is therefore easy to obtain a type theory for a comonad, an adjunction, a local topos, or any other number of complex and realistic scenarios. In addition to showing that many modal type theories are closely related to specific instantiations of MTT, we thoroughly explore the syntax and semantics of MTT itself. We prove that MTT enjoys an unconditional normalization result and decidable type-checking under mild assumptions. We show how MTT may be interpreted into a wide variety of structured categories and use this to study the expressive power of the type theory and various extensions thereof.</html:p><html:p>Finally, we explore several concrete applications of MTT in the context of guarded type theory and guarded denotational semantics. We propose a highly usable language for guarded recursion and explore its particular models and metatheorems. We show a relatively sharp result bounding the extent to which classical guarded recursion can be added to any type theory with decidable type-checking and propose a system to mitigate this issue. Finally, we conduct an in-depth case study using guarded MTT to obtain a fully synthetic account of the Iris program logic, proving adequacy in a fully internal manner.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>9</fr:month><fr:day>13</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-thesis/</fr:uri><fr:display-uri>sterling-2021-thesis</fr:display-uri><fr:route>/sterling-2021-thesis/</fr:route><fr:title text="First steps in synthetic Tait computability: the objective metatheory of cubical type theory">First steps in synthetic Tait computability: the objective metatheory of cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">Doctoral dissertation, <fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta><fr:meta name="bibtex"><![CDATA[@phdthesis{sterling-2021-thesis,
  author = {Sterling, Jonathan},
  school = {Carnegie Mellon University},
  year = {2021},
  doi = {10.5281/zenodo.6990769},
  note = {Version 1.1, revised May 2022},
  number = {CMU-CS-21-142},
  title = {First Steps in Synthetic {Tait} Computability: The Objective Metatheory of Cubical Type Theory},
}]]></fr:meta><fr:meta name="doi">10.5281/zenodo.6990769</fr:meta></fr:frontmatter><fr:mainmatter><html:p>The implementation and semantics of dependent type theories can be studied in a syntax-independent way: the objective metatheory of dependent type theories exploits the universal properties of their syntactic categories to endow them with computational content, mathematical meaning, and practical implementation (normalization, type checking, elaboration). The semantic methods of the objective metatheory inform the design and implementation of correct-by-construction elaboration algorithms, promising a principled interface between real proof assistants and ideal mathematics.</html:p><html:p>In this dissertation, I add synthetic Tait computability to the arsenal of the objective metatheorist. Synthetic Tait computability is a mathematical machine to reduce difficult problems of type theory and programming languages to trivial theorems of topos theory. First employed by <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">Sterling and Harper</fr:link> to reconstruct the theory of program modules and their phase separated parametricity, synthetic Tait computability is deployed here to resolve the last major open question in the syntactic metatheory of cubical type theory: normalization of open terms.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Technical reports">Technical reports</fr:title></fr:frontmatter><fr:mainmatter /></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Workshop talks">Workshop talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>6</fr:month><fr:day>21</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/harper-2023-calco-mfps/</fr:uri><fr:display-uri>harper-2023-calco-mfps</fr:display-uri><fr:route>/harper-2023-calco-mfps/</fr:route><fr:title text="Integrating cost and behavior in type theory">Integrating cost and behavior in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">http://www.cs.cmu.edu/~rwh/talks/calco-mfps-2023.pdf</fr:meta><fr:meta name="venue"> Plenary invited lecture for CALCO/MFPS 2023</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Joint work with <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Harrison Grodin</fr:link> (Carnegie Mellon), <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> (Carnegie Mellon), and <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> (Cambridge).</html:p><html:p>The computational view of intuitionistic dependent type theory is as an intrinsic logic of (functional) programs in which types are viewed as specifications of their behavior. Equational reasoning is particularly relevant in the functional case, where correctness can be formulated as equality between two implementations of the same behavior. Besides behavior, it is also important to specify and verify the cost of programs, measured in terms of their resource usage, with respect to both sequential and parallel evaluation. Although program cost can—and has been—verified in type theory using an extrinsic formulation of programs as data objects, what we seek here is, instead, an intrinsic account within type theory itself.</html:p><html:p>In this talk we discuss Calf, the <fr:link href="/niu-sterling-grodin-harper-2022/" title="A cost-aware logical framework" uri="https://www.jonmsterling.com/niu-sterling-grodin-harper-2022/" display-uri="niu-sterling-grodin-harper-2022" type="local">Cost-Aware Logical Framework</fr:link>, which is an extension of dependent call-by-push-value type theory that provides an intrinsic account of both parallel and sequential resource usage for a variety of problem-specific measures of cost. Thus, for example, it is possible to prove that insertion sort and merge sort are equal as regards behavior, but differ in terms of the number of comparisons required to achieve the same results. But how can equal functions have different cost? To provide an intrinsic account of both intensional and extensional properties of programs, we make use of <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">Sterling's notion of Synthetic Tait Computability</fr:link>, a generalization of Tait's method originally developed for the study of higher type theory. In STC the concept of a “phase” plays a central role: originally as the distinction between the syntactic and semantic aspects of a computability structure, but more recently applied to the formulation of type theories for program modules and for information flow properties of programs. In Calf we distinguish two phases, the intensional and extensional, which differ as regards the significance of cost accounting—extensionally it is neglected, intensionally it is of paramount importance. Thus, in the extensional phase insertion sort and merge sort are equal, but in the intensional phase they are distinct, and indeed one is proved to have optimal behavior as regards comparisons, and the other not. Importantly, both phases are needed in a cost verification—the proof of the complexity of an algorithm usually relies on aspects of its correctness.</html:p><html:p>We will provide an overview of Calf itself, and of its application in the verification of the cost and behavior of a variety of programs. So far we have been able to verify cost bounds on Euclid's Algorithm, amortized bounds on batched queues, parallel cost bounds on a joinable form of red-black trees, and the equivalence and cost of the aforementioned sorting methods. In a <fr:link href="/grodin-harper-2023-calco/" title="Amortized analysis via coinduction" uri="https://www.jonmsterling.com/grodin-harper-2023-calco/" display-uri="grodin-harper-2023-calco" type="local">companion paper</fr:link> at this meeting <fr:link href="/harrisongrodin/" title="Harrison Grodin" uri="https://www.jonmsterling.com/harrisongrodin/" display-uri="harrisongrodin" type="local">Grodin</fr:link> and I develop an account of amortization that relates the standard inductive view of instruction sequences with the coinductive view of data structures characterized by the same operations. In ongoing work we are extending the base of verified deterministic algorithms to those taught in the undergraduate parallel algorithms course at Carnegie Mellon, and are extending Calf itself to account for probabilistic methods, which are also used in that course.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/taichiuemura/" title="Taichi Uemura" uri="https://www.jonmsterling.com/taichiuemura/" display-uri="taichiuemura" type="local">Taichi Uemura</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>7</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/uemura-2022-hott-uf/</fr:uri><fr:display-uri>uemura-2022-hott-uf</fr:display-uri><fr:route>/uemura-2022-hott-uf/</fr:route><fr:title text="Internal languages of diagrams of ∞-toposes">Internal languages of diagrams of ∞-toposes</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@misc{uemura-2022-hott-uf,
  author = {Uemura, Taichi},
  year = {2022},
  month = july,
  note = {Workshop on Homotopy Type Theory / Univalent Foundations},
  title = {Internal languages of diagrams of $\infty$-toposes},
  url = {https://hott-uf.github.io/2022/uemura-hott-uf-2022-notes.pdf}
}]]></fr:meta><fr:meta name="venue">Workshop on Homotopy Type Theory / Univalent Foundations</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonathanweinberger/" title="Jonathan Weinberger" uri="https://www.jonmsterling.com/jonathanweinberger/" display-uri="jonathanweinberger" type="local">Jonathan Weinberger</fr:link></fr:author><fr:author><fr:link href="/benediktahrens/" title="Benedikt Ahrens" uri="https://www.jonmsterling.com/benediktahrens/" display-uri="benediktahrens" type="local">Benedikt Ahrens</fr:link></fr:author><fr:author><fr:link href="/ulrikbuchholtz/" title="Ulrik Buchholtz" uri="https://www.jonmsterling.com/ulrikbuchholtz/" display-uri="ulrikbuchholtz" type="local">Ulrik Buchholtz</fr:link></fr:author><fr:author><fr:link href="/paigenorth/" title="Paige Randall North" uri="https://www.jonmsterling.com/paigenorth/" display-uri="paigenorth" type="local">Paige Randall North</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>7</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/weinberger-ahrens-buchholtz-north-2022-hott-uf/</fr:uri><fr:display-uri>weinberger-ahrens-buchholtz-north-2022-hott-uf</fr:display-uri><fr:route>/weinberger-ahrens-buchholtz-north-2022-hott-uf/</fr:route><fr:title text="Towards normalization of simplicial type theory via synthetic Tait computability">Towards normalization of simplicial type theory via synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@misc{weinberger-ahrens-buchholtz-north-2022-hott-uf,
  author = {Weinberger, Jonathan and Ahrens, Benedikt and Buchholtz, Ulrik and North, Paige},
  year = {2022},
  month = july,
  note = {Workshop on Homotopy Type Theory / Univalent Foundations},
  title = {Towards Normalization of Simplicial Type Theory via Synthetic Tait Computability},
  url = {https://hott-uf.github.io/2022/HoTTUF_2022_paper_6.pdf}
}]]></fr:meta><fr:meta name="video">https://www.dropbox.com/s/6dhiqiaemzmewm1/weinberger_HoTTUF22_SSTC.mp4?dl=0</fr:meta><fr:meta name="venue">Workshop on Homotopy Type Theory / Univalent Foundations</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-muri/</fr:uri><fr:display-uri>sterling-2022-muri</fr:display-uri><fr:route>/sterling-2022-muri/</fr:route><fr:title text="Sheaf semantics of termination-insensitive noninterference">Sheaf semantics of termination-insensitive noninterference</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@misc{sterling-harper-2022-muri,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {\route-asset{assets/slides/sterling:2022:muri.pdf}},
  year = {2022},
  month = jun,
  note = {Talk given at the 2022 MURI Team Meeting},
  title = {Sheaf semantics of termination-insensitive noninterference},
}]]></fr:meta><fr:meta name="slides">/bafkrmidn65xp7ewox6ka5uijltbkg5ikkuuuj5zid7viz5dbu35fx44qoq.pdf</fr:meta><fr:meta name="venue">MURI Team Meeting 2022</fr:meta></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2023</fr:year><fr:month>7</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/jms-005Z/</fr:uri><fr:display-uri>jms-005Z</fr:display-uri><fr:route>/jms-005Z/</fr:route><fr:title text="Adequacy of sheaf semantics of noninterference">Adequacy of <fr:link href="/sterling-harper-2022/" title="Sheaf semantics of termination-insensitive noninterference" uri="https://www.jonmsterling.com/sterling-harper-2022/" display-uri="sterling-harper-2022" type="local">sheaf semantics of noninterference</fr:link></fr:title><fr:taxon>Erratum</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A serious (and as-yet unfixed) problem was discovered in July of 2023 by <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>, which undermines the proof of adequacy given; in particular, the proof that the logical relation on free algebras is admissible is not correct. I believe there is a different proof of adequacy for the calculus described, but it will have a different structure from what currently appears in the paper. We thank <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link> for his attention to detail and careful reading of this paper.</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonathanweinberger/" title="Jonathan Weinberger" uri="https://www.jonmsterling.com/jonathanweinberger/" display-uri="jonathanweinberger" type="local">Jonathan Weinberger</fr:link></fr:author><fr:author><fr:link href="/benediktahrens/" title="Benedikt Ahrens" uri="https://www.jonmsterling.com/benediktahrens/" display-uri="benediktahrens" type="local">Benedikt Ahrens</fr:link></fr:author><fr:author><fr:link href="/ulrikbuchholtz/" title="Ulrik Buchholtz" uri="https://www.jonmsterling.com/ulrikbuchholtz/" display-uri="ulrikbuchholtz" type="local">Ulrik Buchholtz</fr:link></fr:author><fr:author><fr:link href="/paigenorth/" title="Paige Randall North" uri="https://www.jonmsterling.com/paigenorth/" display-uri="paigenorth" type="local">Paige Randall North</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/weinberger-ahrens-buchholtz-north-2022-types/</fr:uri><fr:display-uri>weinberger-ahrens-buchholtz-north-2022-types</fr:display-uri><fr:route>/weinberger-ahrens-buchholtz-north-2022-types/</fr:route><fr:title text="Synthetic Tait computability for simplicial type theory">Synthetic Tait computability for simplicial type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@inproceedings{weinberger-ahrens-buchholtz-north-2022-types,
  author = {Weinberger, Jonathan and Ahrens, Benedikt and Buchholtz, Ulrik and North, Paige},
  booktitle = {28th International Conference on Types for Proofs and Programs (TYPES 2022)},
  year = {2022},
  title = {Synthetic {Tait} Computability for Simplicial Type Theory},
  url = {https://types22.inria.fr/files/2022/06/TYPES_2022_paper_17.pdf}
}]]></fr:meta><fr:meta name="video">https://www.youtube.com/watch?v=jX76Kv-E_ls</fr:meta><fr:meta name="venue">28th International Conference on Types for Proofs and Programs</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/taichiuemura/" title="Taichi Uemura" uri="https://www.jonmsterling.com/taichiuemura/" display-uri="taichiuemura" type="local">Taichi Uemura</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>5</fr:month><fr:day>21</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/uemura-2022-wg6/</fr:uri><fr:display-uri>uemura-2022-wg6</fr:display-uri><fr:route>/uemura-2022-wg6/</fr:route><fr:title text="Normalization for initial space-valued models of type theories">Normalization for initial space-valued models of type theories</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@misc{uemura-2022-wg6,
  author = {Uemura, Taichi},
  year = {2022},
  month = may,
  note = {WG6 kick-off meeting: Syntax and Semantics of Type Theories},
  title = {Normalization for initial space-valued models of type theories},
}]]></fr:meta><fr:meta name="venue">WG6 kick-off meeting: Syntax and Semantics of Type Theories</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>5</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-wg6/</fr:uri><fr:display-uri>sterling-2022-wg6</fr:display-uri><fr:route>/sterling-2022-wg6/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@misc{sterling-2022-wg6,
  author = {Sterling, Jonathan},
  year = {2022},
  month = may,
  note = {WG6 kick-off meeting: Syntax and Semantics of Type Theories (Invited Talk)},
  title = {Na\"{i}ve logical relations in synthetic {Tait} computability},
}]]></fr:meta><fr:meta name="venue">WG6 kick-off meeting: Syntax and Semantics of Type Theories</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>10</fr:month><fr:day>15</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-muri/</fr:uri><fr:display-uri>sterling-2021-muri</fr:display-uri><fr:route>/sterling-2021-muri/</fr:route><fr:title text="Normalization for (Cartesian) cubical type theory">Normalization for (Cartesian) cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmigc53m5m72p66jxbd7oxkvrl7irbrfxdjsatj2igngbm44a6g5cnq.pdf</fr:meta><fr:meta name="venue">MURI Team Meeting 2021</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/sterling-harper-2021-mlw/</fr:uri><fr:display-uri>sterling-harper-2021-mlw</fr:display-uri><fr:route>/sterling-harper-2021-mlw/</fr:route><fr:title text="A metalanguage for multi-phase modularity">A metalanguage for multi-phase modularity</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="bibtex"><![CDATA[@unpublished{sterling-harper-2021-mlw,
  author = {Sterling, Jonathan and Harper, Robert},
  url = {https://icfp21.sigplan.org/details/mlfamilyworkshop-2021-papers/5/A-metalanguage-for-multi-phase-modularity},
  year = {2021},
  month = aug,
  note = {ML 2021 abstract and talk},
  title = {A metalanguage for multi-phase modularity},
}]]></fr:meta><fr:meta name="slides">/bafkrmigp2ekztc4xgmcxoxv7mxawb33zro6apew2m54hmctdosmregbpha.pdf</fr:meta><fr:meta name="video">https://www.youtube.com/watch?v=5kWS-umBA7k</fr:meta><fr:meta name="venue">ML Family Workshop</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Type abstraction, the phase distinction, and computational effects all play an important role in the design and implementation of ML-style module systems. We propose a simple type theoretic metalanguage <html:strong>φML</html:strong> for multi-phase modularity in which these concepts are treated individually, supporting the definition of high-level modular constructs such as generative and applicative functors, as well as all extant forms of structure sharing.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year></fr:date><fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-ct/</fr:uri><fr:display-uri>sterling-angiuli-2021-ct</fr:display-uri><fr:route>/sterling-angiuli-2021-ct/</fr:route><fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmie6j57qqrx6av73q6ropesavo76e57fcttaxm6t7qyhzpsyhjazjm.pdf</fr:meta><fr:meta name="video">https://www.youtube.com/watch?v=AhivFjnBakE</fr:meta><fr:meta name="venue">Category Theory 2021</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree></fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Seminar talks">Seminar talks</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>6</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-pps/</fr:uri><fr:display-uri>sterling-2022-pps</fr:display-uri><fr:route>/sterling-2022-pps/</fr:route><fr:title text="Naïve logical relations in synthetic Tait computability">Naïve logical relations in synthetic Tait computability</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">Proofs, Programs and Systems seminar (IRIF PPS)</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Logical relations are the main tool for proving <html:em>positive</html:em> properties of logics, type theories, and programming languages: canonicity, normalization, decidability, conservativity, computational adequacy, and more. Logical relations combine pure syntax with <html:em>non-syntactic</html:em> objects that are parameterized in syntax in a somewhat complex way; the sophistication of possible parameterizations makes logical relations a tool that is primarily accessible to specialists. In the spirit of Halmos' book <html:em>Naïve Set Theory</html:em>, I advocate for a new viewpoint on logical relations based on <html:em>synthetic Tait computability</html:em>, the internal language of categories of logical relations. In synthetic Tait computability, logical relations are manipulated as if they were sets, making the essence of many complex logical relations arguments accessible to non-specialists.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2022</fr:year><fr:month>4</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2022-bu-popv/</fr:uri><fr:display-uri>sterling-2022-bu-popv</fr:display-uri><fr:route>/sterling-2022-bu-popv/</fr:route><fr:title text="Intrinsic semantics of termination-insensitive noninterference">Intrinsic semantics of termination-insensitive noninterference</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiakx5dlx7mjxgf2e3qfga4xmjbru46crc6ds52thmiktqyjri46n4.pdf</fr:meta><fr:meta name="venue">Boston University POPV Seminar</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Security-typed programming languages aim to control the flow of high-security information to low security clients. Starting with Abadi et al.'s dependency core calculus, the denotational semantics of such languages has been dominated by an <html:strong>extrinsic</html:strong> approach in which an existing insecure model of computation (e.g. ordinary domains) is restricted by a logical relation of "indistinguishability" to prevent low-security outputs from depending on high-security inputs (noninterference). Thus in the extrinsic approach, security properties are bolted onto an insecure model by brute force, as it were. A more refined information flow policy called termination-insensitive noninterference allows high-security bits to be leaked through termination channels but not through return values; unfortunately, the adaptation of the extrinsic/relational semantics to this more relaxed policy is incompatible with the transitivity of the logical relation, contradicting the intuition of "indistinguishability".</html:p><html:p>In contrast, an <html:strong>intrinsic</html:strong> semantics of security typing would involve a new computational model that evinces secure information flow and noninterference properties directly without any post hoc restriction by a logical relation. We contribute the first such intrinsic semantics of security typing in this sense by considering sheaves of dcpos on a space of abstract behaviors on which security classes arise as open/closed partitions; the security monads then arise as the <html:em>closed modalities</html:em> of topos theory that restrict a sheaf to its component over a closed subspace.</html:p><html:p>An advantage of our intrinsic semantics is that termination-insensitive noninterference arises automatically from our computational model, namely the fact that the Sierpiński domain is not a constant sheaf; a further advantage is that our semantics is an instance of standard domain theoretic denotational semantics, albeit over a richer category of domains.</html:p><html:p>(j.w.w. <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">R. Harper</fr:link>)</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/harper-2021-topos-institute/</fr:uri><fr:display-uri>harper-2021-topos-institute</fr:display-uri><fr:route>/harper-2021-topos-institute/</fr:route><fr:title text="Phase distinctions in type theory">Phase distinctions in type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="video">https://www.youtube.com/watch?v=7DYkyB1Rm3I</fr:meta><fr:meta name="venue"><fr:link href="/toposinstitute/" title="Topos Institute" uri="https://www.jonmsterling.com/toposinstitute/" display-uri="toposinstitute" type="local">Topos Institute</fr:link> Colloquium</fr:meta></fr:frontmatter><fr:mainmatter><html:p>(Joint work with <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> and <fr:link href="/yueniu/" title="Yue Niu" uri="https://www.jonmsterling.com/yueniu/" display-uri="yueniu" type="local">Yue Niu</fr:link>)</html:p><html:p>The informal phase distinction between compile-time and run-time in programming languages is formally manifested by the distinction between kinds, which classify types, and types, which classify code. The distinction underpins standard programming methodology whereby code is first type-checked for consistency before being compiled for execution. When used effectively, types help eliminate bugs before they occur.</html:p><html:p>Program modules, in even the most rudimentary form, threaten the distinction, comprising as they do both types and programs in a single unit. Matters worsen when considerating “open” modules, with free module variables standing for its imports. To maintain the separation in their presence it is necessary to limit the dependency of types, the static parts of a module, to their imported types. Such restrictions are fundamental for using dependent types to express modular structure, as originally suggested by MacQueen.</html:p><html:p>To address this question <fr:link href="/moggi-1989/" title="A category-theoretic account of program modules" uri="https://www.jonmsterling.com/moggi-1989/" display-uri="moggi-1989" type="local">Moggi</fr:link> gave an “analytic” formulation of program modules in which modules are explicitly separated into their static and dynamic components using tools from category theory. Recent work by Dreyer, Rossberg, and Russo develops this approach fully in their account of ML-like module systems. In this talk we consider instead a “synthetic” formulation using a proposition to segregate the static from the dynamic, in particular to define static equivalence to manage type sharing and type dependency.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>11</fr:month><fr:day>19</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-ccl/</fr:uri><fr:display-uri>sterling-2021-ccl</fr:display-uri><fr:route>/sterling-2021-ccl/</fr:route><fr:title text="Towards a geometry for syntax">Towards a geometry for syntax</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmig65yyrnooa2ki3usvufg3gmrp24zw3u634erewg2pwgjpthnlksq.pdf</fr:meta><fr:meta name="venue"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>The purpose of this talk is to pose the question, “What are the Euclid’s postulates for syntactic metatheory?”</html:p><html:p>In the fourth century B.C.E., the Greek mathematician Euclid set down his famous postulates for plane geometry, explaining geometric shapes in terms of rules that govern their construction and incidence. The dialectical relationship between theories (axioms) and their models (coordinate systems) has been the driving force in the last two millennia of geometrical investigation.</html:p><html:p>In logic and computer science, workers in the “syntactic metatheory” investigate questions that lie on the fringe between a theory and its models — definability, normalization, decidability, conservativity, computational adequacy, parametricity, type safety, etc. Dominant methods attack these questions by means of explicit computations (e.g. Kripke logical relations) which practitioners have found to be both reliable and somewhat opaque. In this talk, I introduce <html:em>Synthetic Tait computability</html:em> — a new system of axioms that transforms these explicit computations into synthetic manipulations; classical Kripke logical relations can be seen as models or “coordinate systems” for the new geometry of syntax that is beginning to unfold.</html:p><html:p>Synthetic Tait computability has already been employed to positively resolve the normalization and decidability conjectures for cubical type theory, as well as a number of other recent results.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>11</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-logsem/</fr:uri><fr:display-uri>sterling-2021-logsem</fr:display-uri><fr:route>/sterling-2021-logsem/</fr:route><fr:title text="Between abstraction and composition...">Between abstraction and composition...</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmibvdmy674htuxiv72zuvqwhdzjsygbcvw3zcishgnlucuoc3q35iq.pdf</fr:meta><fr:meta name="venue">Logic and Semantics Seminar, <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><html:p>The fundamental contradiction of programming and program verification can be located in the tension between abstraction and composition. We make programs more abstract in order to prevent bad interactions between components; on the other side of the coin, we impede the composition of components when we abstract them. Modern programming practice evinces many distinct levels of abstraction that must be considered at the same time — for instance, compilers break module boundaries during linking, complexity analysis breaks the abstraction of extensional equivalence, and logical relations proofs break the abstraction of closure under substitution. What is needed to meet this challenge is linguistic tools that smoothly interpolate between these different levels of abstraction. Building on <fr:link href="/sterling-2021-thesis/" title="First steps in synthetic Tait computability: the objective metatheory of cubical type theory" uri="https://www.jonmsterling.com/sterling-2021-thesis/" display-uri="sterling-2021-thesis" type="local">my doctoral dissertation</fr:link> and <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">joint work with Bob Harper</fr:link>, I introduce a new plan for modal programming languages and logics that treat the transition between different abstraction levels as a first-class notion.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>8</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-ss/</fr:uri><fr:display-uri>sterling-2021-cmu-ss</fr:display-uri><fr:route>/sterling-2021-cmu-ss/</fr:route><fr:title text="Abstraction, composition, and the phase distinction">Abstraction, composition, and the phase distinction</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiauzlnmczowkvzdsbt3hw2hzxc35xoyii4qvpkg2cykqba7bu5pya.pdf</fr:meta><fr:meta name="venue">CMU Speakers Club</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Programmers use abstraction to hide representation details from ourselves: either to avoid mistakes (e.g. confusing a list index with a length) or to exploit representation invariants (e.g. two implementations of the QUEUE interface are indistinguishable). These abstraction boundaries can unfortunately impede the linking of smaller program units into efficient composite programs, because compilers must exploit representation details in order to produce efficient code.  Sometimes seen as the "waterloo of separate compilation", the need to break abstraction is answered by whole-program analysis techniques that break all abstractions (as in the MLton compiler for Standard ML). Separate compilation, however, has a number of advantages including speed, parallelization, and elegance.</html:p><html:p>We present an alternative type theoretic account of abstraction-breaking during compilation based on the famous phase distinction of ML languages; rather than distinguishing between compiletime and runtime, we focus on separating "devtime" from compiletime. Our framework allows the programmer to selectively reveal representation details to the compiler without giving up the representation independence properties guaranteed by "devtime" type correctness.  We also describe an application to the problem of printf-debugging, which is ordinarily obstructed by abstraction.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>5</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-angiuli-2021-padova/</fr:uri><fr:display-uri>sterling-angiuli-2021-padova</fr:display-uri><fr:route>/sterling-angiuli-2021-padova/</fr:route><fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">Padova Logic Seminar</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application <html:code>(p @ i)</html:code> ceases to be neutral within its “locus of instability” <html:code>∂(i)</html:code> and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables <html:code>x : A</html:code> and dimensions <html:code>i : 𝕀</html:code>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>4</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-au-ccs/</fr:uri><fr:display-uri>sterling-2021-au-ccs</fr:display-uri><fr:route>/sterling-2021-au-ccs/</fr:route><fr:title text="Logical relations as types">Logical relations as types</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="slides">/bafkrmiafb2gihhkx6w3wjzpfzs5bvjxmjospi4wuhgnszcmuq3j6w4lyue.pdf</fr:meta><fr:meta name="video">https://www.youtube.com/watch?v=AEthjg2k718</fr:meta><fr:meta name="venue">CCS Colloquium, Augusta University</fr:meta></fr:frontmatter><fr:mainmatter><html:p><html:em>This is joint work with <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:em></html:p><html:p>How do you prove that two implementations of an abstract type behave the same in all configurations? Reynolds famously employed logical relations to establish such results; roughly, a logical relation is a structure-respecting relation between two interpretations of a theory that evinces, in the base case, a desirable invariant.</html:p><html:p>We present a synthetic way to understand and interact with logical relations, related to classical logical relations in the same way that Euclidean geometry relates to point-sets. Previously a logical relation was defined in terms of the (complicated) details of how it is constructed as a certain kind of relation over syntax. We instead take the simpler view that everything in sight is a logical relation, and then use modalities to isolate those logical relations that are degenerate in either the syntactic or the semantic direction.</html:p><html:p>Our “logical relations as types” principle has led to a new account of modules and representation independence <fr:link href="/sterling-harper-2021/" title="Logical relations as types: proof-relevant parametricity for program modules" uri="https://www.jonmsterling.com/sterling-harper-2021/" display-uri="sterling-harper-2021" type="local">(S., Harper)</fr:link>, as well as the first proofs of normalization for cubical type theory <fr:link href="/sterling-angiuli-2021/" title="Normalization for cubical type theory" uri="https://www.jonmsterling.com/sterling-angiuli-2021/" display-uri="sterling-angiuli-2021" type="local">(S., Angiuli)</fr:link> and general multi-modal dependent type theory <fr:link href="/gratzer-2022/" title="Normalization for multimodal type theory" uri="https://www.jonmsterling.com/gratzer-2022/" display-uri="gratzer-2022" type="local">(Gratzer)</fr:link>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author><fr:author><fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link></fr:author></fr:authors><fr:date><fr:year>2021</fr:year><fr:month>2</fr:month></fr:date><fr:uri>https://www.jonmsterling.com/sterling-2021-cmu-hott/</fr:uri><fr:display-uri>sterling-2021-cmu-hott</fr:display-uri><fr:route>/sterling-2021-cmu-hott/</fr:route><fr:title text="Normalization for cubical type theory">Normalization for cubical type theory</fr:title><fr:taxon>Reference</fr:taxon><fr:meta name="venue">Pittsburgh's HoTT Seminar</fr:meta></fr:frontmatter><fr:mainmatter><html:p>We prove normalization for (univalent, Cartesian) cubical type theory, closing the last major open problem in the syntactic metatheory of cubical type theory. The main difficulty in comparison to conventional type theory is located in a new feature of cubical type theories, the absence of a stable notion of neutral term: for instance, the path application p(i) ceases to be neutral within its “locus of instability” ∂(i) and must compute to an endpoint. We introduce a new, geometrically-inspired generalization of the notion of neutral term, stabilizing neutrals by gluing them together with partial computability data along their loci of instability — when the locus of instability is nowhere, a stabilized neutral is a conventional neutral, and when the locus of instability is everywhere, a stabilized neutral is just computability data. Our normalization result is based on a reduction-free Artin gluing argument, and yields an injective function from equivalence classes of terms in context to a tractable language of beta/eta-normal forms. As corollaries we obtain both decidability of judgmental equality, as well as injectivity of type constructors in contexts formed by assuming variables x : A and dimensions i : 𝕀.</html:p><html:p>(j.w.w. <fr:link href="/carloangiuli/" title="Carlo Angiuli" uri="https://www.jonmsterling.com/carloangiuli/" display-uri="carloangiuli" type="local">Carlo Angiuli</fr:link>.)</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://www.jonmsterling.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link></fr:author></fr:authors><fr:title text="Roladex">Roladex</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/carloangiuli/</fr:uri><fr:display-uri>carloangiuli</fr:display-uri><fr:route>/carloangiuli/</fr:route><fr:title text="Carlo Angiuli">Carlo Angiuli</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://carloangiuli.com/</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="institution">Indiana University</fr:meta><fr:meta name="position">Assistant Professor</fr:meta><fr:meta name="postdoc-advisor">robertharper</fr:meta><fr:meta name="orcid">0000-0002-9590-3303</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/danielgratzer/</fr:uri><fr:display-uri>danielgratzer</fr:display-uri><fr:route>/danielgratzer/</fr:route><fr:title text="Daniel Gratzer">Daniel Gratzer</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">http://www.danielgratzer.com/</fr:meta><fr:meta name="institution"><fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link></fr:meta><fr:meta name="position">PhD Student</fr:meta><fr:meta name="phd-advisor">larsbirkedal</fr:meta><fr:meta name="orcid">0000-0003-1944-0789</fr:meta></fr:frontmatter><fr:mainmatter><html:blockquote>I study programming languages, type theories, and logics. I am particularly interested in applying semantic methods to prove syntactic properties of modal type theories and programming languages. I am also involved in the development of program logics for concurrent programming languages through the <fr:link href="https://iris-project.org/" type="external">Iris project</fr:link>.</html:blockquote></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/harrisongrodin/</fr:uri><fr:display-uri>harrisongrodin</fr:display-uri><fr:route>/harrisongrodin/</fr:route><fr:title text="Harrison Grodin">Harrison Grodin</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://www.harrisongrodin.com/</fr:meta><fr:meta name="position">PhD Student</fr:meta><fr:meta name="institution"><fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="orcid">0000-0002-0947-3520</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/jonmsterling/</fr:uri><fr:display-uri>jonmsterling</fr:display-uri><fr:route>/jonmsterling/</fr:route><fr:title text="Jon Sterling">Jon Sterling</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://www.jonmsterling.com/index/</fr:meta><fr:meta name="institution"><fr:link href="/camcl/" title="Cambridge Computer Laboratory" uri="https://www.jonmsterling.com/camcl/" display-uri="camcl" type="local">Cambridge Computer Laboratory</fr:link>; <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link></fr:meta><fr:meta name="orcid">0000-0002-0585-5564</fr:meta><fr:meta name="position">Associate Professor</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="postdoc-advisor">larsbirkedal</fr:meta></fr:frontmatter><fr:mainmatter><html:p>Associate Professor in Logical Foundations and Formal Methods at University of Cambridge. Formerly a <fr:link href="/jms-0061/" title="TypeSynth: synthetic methods in program verification" uri="https://www.jonmsterling.com/jms-0061/" display-uri="jms-0061" type="local">Marie Skłodowska-Curie Postdoctoral Fellow</fr:link> hosted at <fr:link href="/jms-00GC/" title="Aarhus University" uri="https://www.jonmsterling.com/jms-00GC/" display-uri="jms-00GC" type="local">Aarhus University</fr:link> by <fr:link href="/larsbirkedal/" title="Lars Birkedal" uri="https://www.jonmsterling.com/larsbirkedal/" display-uri="larsbirkedal" type="local">Lars Birkedal</fr:link>, and before this a PhD student of <fr:link href="/robertharper/" title="Robert Harper" uri="https://www.jonmsterling.com/robertharper/" display-uri="robertharper" type="local">Robert Harper</fr:link>.</html:p><html:p>I am a Bye-Fellow of <fr:link href="/jms-00GP/" title="Clare College" uri="https://www.jonmsterling.com/jms-00GP/" display-uri="jms-00GP" type="local">Clare College</fr:link> from February 2024, and have been elected a Fellow for the coming year.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/robertharper/</fr:uri><fr:display-uri>robertharper</fr:display-uri><fr:route>/robertharper/</fr:route><fr:title text="Robert Harper">Robert Harper</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="institution"><fr:link href="/cmu/" title="Carnegie Mellon University" uri="https://www.jonmsterling.com/cmu/" display-uri="cmu" type="local">Carnegie Mellon University</fr:link></fr:meta><fr:meta name="position">Professor</fr:meta><fr:meta name="orcid">0000-0002-9400-2941</fr:meta><fr:meta name="external">http://www.cs.cmu.edu/~rwh</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/taichiuemura/</fr:uri><fr:display-uri>taichiuemura</fr:display-uri><fr:route>/taichiuemura/</fr:route><fr:title text="Taichi Uemura">Taichi Uemura</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="external">https://uemurax.github.io/</fr:meta><fr:meta name="institution">Stockholm University</fr:meta><fr:meta name="position">Postdoc</fr:meta><fr:meta name="orcid">0000-0003-4930-1384</fr:meta></fr:frontmatter><fr:mainmatter><html:blockquote>I am a postdoc at the Department of Mathematics at Stockholm University. My main research interests are in <fr:link href="/hottbook/" title="Homotopy Type Theory: univalent foundations of mathematics" uri="https://www.jonmsterling.com/hottbook/" display-uri="hottbook" type="local">Homotopy Type Theory</fr:link>, in particular its semantics using (higher) category theory. I am also interested in type theory in general and pure category theory.</html:blockquote></fr:mainmatter></fr:tree><fr:tree show-metadata="true" expanded="false" toc="false" numbered="false"><fr:frontmatter><fr:authors /><fr:uri>https://www.jonmsterling.com/yueniu/</fr:uri><fr:display-uri>yueniu</fr:display-uri><fr:route>/yueniu/</fr:route><fr:title text="Yue Niu">Yue Niu</fr:title><fr:taxon>Person</fr:taxon><fr:meta name="position">Postdoc</fr:meta><fr:meta name="phd-advisor">robertharper</fr:meta><fr:meta name="institution">National Institute of Informatics</fr:meta><fr:meta name="orcid">0000-0003-4888-6042</fr:meta></fr:frontmatter><fr:mainmatter /></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
