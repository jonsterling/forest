<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://www.jonmsterling.com/frct-000D/</fr:uri>
    <fr:display-uri>frct-000D</fr:display-uri>
    <fr:route>/frct-000D/</fr:route>
    <fr:title text="Iteration and pushforward">Iteration and pushforward</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>It also makes sense to speak of categories displayed over other displayed
categories; one way to formalize this notion is as follows. Let <fr:tex display="inline"><![CDATA[E]]></fr:tex> be
displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex>; we define a category displayed over <fr:tex display="inline"><![CDATA[E]]></fr:tex> to be simply a
category displayed over the total category <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex>.</html:p>
    <html:p>Now let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be displayed over <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex>. Then we may regard <fr:tex display="inline"><![CDATA[F]]></fr:tex> as a
displayed category <fr:tex display="inline"><![CDATA[B_{!}F]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> as follows:</html:p>
    <html:ol><html:li>An object of <fr:tex display="inline"><![CDATA[(B_{!}F)_{x}]]></fr:tex> is a pair <fr:tex display="inline"><![CDATA[(\bar {x},{\ddot {x}})]]></fr:tex> with <fr:tex display="inline"><![CDATA[\bar {x}\in  E_{x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\ddot {x}}\in  F_{\bar {x}}]]></fr:tex>.</html:li>
<html:li>A morphism <fr:tex display="inline"><![CDATA[(\bar {x},{\ddot {x}})\xrightarrow [f]{}(\bar {y},{\ddot {y}})]]></fr:tex> is given by a pair <fr:tex display="inline"><![CDATA[(\bar {f},{\ddot {f}})]]></fr:tex> where <fr:tex display="inline"><![CDATA[\bar {f}:\bar {x}\xrightarrow [f]{}\bar {y}]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\ddot {f}}:{\ddot {x}}\xrightarrow [\bar {f}]{} {\ddot {y}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li></html:ol>
    <html:p>Using the <fr:link href="/frct-000B/" title="Displayed categories from functors" uri="https://www.jonmsterling.com/frct-000B/" display-uri="frct-000B" type="local">displayed category induced by a functor</fr:link>, we may define the <html:em>pushforward</html:em> of a displayed category along a functor. In particular, let <fr:tex display="inline"><![CDATA[E]]></fr:tex>
be displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex> and let <fr:tex display="inline"><![CDATA[U:B\to  C]]></fr:tex> be an ordinary functor; then we may
obtain a displayed category <fr:tex display="inline"><![CDATA[U_{!}E]]></fr:tex> over <fr:tex display="inline"><![CDATA[C]]></fr:tex> as follows:</html:p>
    <html:ol><html:li>First we construct the displayed category <fr:tex display="inline"><![CDATA[U_{\bullet }]]></fr:tex> corresponding to the
functor <fr:tex display="inline"><![CDATA[U:B \to  C]]></fr:tex>.</html:li>
<html:li>We recall that there is a canonical equivalence of categories
<fr:tex display="inline"><![CDATA[\widetilde {U_{\bullet }}\to  B]]></fr:tex>.</html:li>
<html:li>Because <fr:tex display="inline"><![CDATA[E]]></fr:tex> is displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex>, we may regard it as displayed over the
equivalent total category <fr:tex display="inline"><![CDATA[\widetilde {U_{\bullet }}]]></fr:tex> by
  <fr:link href="/frct-0007/" title="Change of base of displayed categories" uri="https://www.jonmsterling.com/frct-0007/" display-uri="frct-0007" type="local">change of base</fr:link>.</html:li>
<html:li>Hence we may define the pushforward <fr:tex display="inline"><![CDATA[U_{!}E]]></fr:tex> to be the displayed category <fr:tex display="inline"><![CDATA[(U_{\bullet })_{!}E]]></fr:tex> as defined above.</html:li></html:ol>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/frct-0009/</fr:uri>
            <fr:display-uri>frct-0009</fr:display-uri>
            <fr:route>/frct-0009/</fr:route>
            <fr:title text="The Grothendieck construction">The Grothendieck construction</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2022</fr:year>
                </fr:date>
                <fr:uri>https://www.jonmsterling.com/frct-000A/</fr:uri>
                <fr:display-uri>frct-000A</fr:display-uri>
                <fr:route>/frct-000A/</fr:route>
                <fr:title text="The total category and its projection">The total category and its projection</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Note that any displayed category <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> can be viewed as an undisplayed category <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex> equipped with a projection functor <fr:tex display="inline"><![CDATA[p_{E}: \widetilde {E}\to  B]]></fr:tex>; in this case <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex> is called the <html:em>total category</html:em> of <fr:tex display="inline"><![CDATA[E]]></fr:tex>.</html:p>
                <html:ol><html:li>An object of <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex> is given by a pair <fr:tex display="inline"><![CDATA[(x,\bar {x})]]></fr:tex> where <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex> and <fr:tex display="inline"><![CDATA[\bar {x}\in  E_{x}]]></fr:tex>.</html:li>
<html:li>A morphism <fr:tex display="inline"><![CDATA[{(x,\bar {x})}\xrightarrow {{}}{(y,\bar {y})}]]></fr:tex> in <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex> is given by a pair <fr:tex display="inline"><![CDATA[(f,\bar {f})]]></fr:tex> where <fr:tex display="inline"><![CDATA[{x}\xrightarrow {{f}}{y}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\bar {x}}\xrightarrow [f]{\bar {f}}{\bar {y}}:\bar {x}]]></fr:tex>.</html:li></html:ol>
                <html:p>The construction of the total category of a displayed category is called the <html:em>Grothendieck construction.</html:em></html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001T/</fr:uri>
                    <fr:display-uri>frct-001T</fr:display-uri>
                    <fr:route>/frct-001T/</fr:route>
                    <fr:taxon>Exercise</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Prove that the <fr:link href="/frct-000A/" title="The total category and its projection" uri="https://www.jonmsterling.com/frct-000A/" display-uri="frct-000A" type="local">total category</fr:link> <fr:tex display="inline"><![CDATA[\widetilde {\underline {B}}]]></fr:tex> of <fr:link href="/frct-0003/" title="The fundamental self-indexing" uri="https://www.jonmsterling.com/frct-0003/" display-uri="frct-0003" type="local">the fundamental self-indexing</fr:link> is the arrow category <fr:tex display="inline"><![CDATA[B^{\to }]]></fr:tex>, and the projection is the codomain functor.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-000B/</fr:uri>
                <fr:display-uri>frct-000B</fr:display-uri>
                <fr:route>/frct-000B/</fr:route>
                <fr:title text="Displayed categories from functors">Displayed categories from functors</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In many cases, one starts with a functor <fr:tex display="inline"><![CDATA[P:E\to  B]]></fr:tex>; if it were meaningful to speak of <html:em>equality</html:em> of objects in an arbitrary category then there would be an obvious construction of a displayed category <fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> from <fr:tex display="inline"><![CDATA[P]]></fr:tex>; we would simply set <fr:tex display="inline"><![CDATA[P_{x}]]></fr:tex> to be the collection of objects <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> such that <fr:tex display="inline"><![CDATA[Pu=x]]></fr:tex>. As it stands there is a more subtle version that will coincide up to categorical
equivalence with the naïve one in all cases that the latter is meaningful.</html:p>
                <html:ol><html:li>We define an object of <fr:tex display="inline"><![CDATA[P_{x}]]></fr:tex> to be a pair <fr:tex display="inline"><![CDATA[(u,\phi _{u})]]></fr:tex> where <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> and  <fr:tex display="inline"><![CDATA[\phi _{u} : Pu\cong  x]]></fr:tex>. It is good to visualize such a pair as a “crooked
  leg” like so:
    
 
  
  <html:figure><fr:resource hash="c5c482ac2e421eee635366bd7f6d1447"><fr:resource-content><html:img src="/c5c482ac2e421eee635366bd7f6d1447.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (u) {$u$};
        \node  (Pu) [below = 1cm of u] {$Pu$};
        \node  (x) [right = 1.5cm of Pu] {$x$};
        \draw [lies over] (u) to (Pu);
        \draw [->] (Pu) to node [below] {$\phi _{u}$} (x);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li>

  <html:li>A morphism <fr:tex display="inline"><![CDATA[(u,\phi _{u})\xrightarrow [f]{} (v,\phi _{v})]]></fr:tex> over <fr:tex display="inline"><![CDATA[f : x \to  y]]></fr:tex> is given by a morphism <fr:tex display="inline"><![CDATA[h : u\to  v]]></fr:tex> that lies over <fr:tex display="inline"><![CDATA[f]]></fr:tex> modulo the isomorphisms <fr:tex display="inline"><![CDATA[\phi _{u},\phi _{v}]]></fr:tex> in sense depicted below:


    
 
  
  <html:figure><fr:resource hash="52dd38c1ce55bea158fd4d9d3a0f2b17"><fr:resource-content><html:img src="/52dd38c1ce55bea158fd4d9d3a0f2b17.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (pu) {$Pu$};
        \node  (pv) [right = of pu] {$Pv$};
        \node  (x) [below left = 1.5cm of pu] {$x$};
        \node  (y) [below right = 1.5cm of pv] {$y$};
        \node  (u) [above = 1.5cm of pu] {$u$};
        \node  (v) [above = 1.5cm of pv] {$v$};
        \draw [lies over] (u) to (pu);
        \draw [lies over] (v) to (pv);
        \draw [->] (u) to node [above] {$h$} (v);
        \draw [->] (x) to node [sloped,above] {$\phi _{u}^{-1}$} (pu);
        \draw [->] (pu) to node [upright desc] {$Ph$} (pv);
        \draw [->] (pv) to node [sloped,above] {$\phi _{v}$} (y);
        \draw [->,bend right=30] (x) to node [below] {$f$} (y);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li></html:ol>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001U/</fr:uri>
                    <fr:display-uri>frct-001U</fr:display-uri>
                    <fr:route>/frct-001U/</fr:route>
                    <fr:taxon>Exercise</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Suppose that <fr:tex display="inline"><![CDATA[B]]></fr:tex> is an internal category in <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>, i.e.
it has a set of objects. Exhibit an equivalence of displayed categories between
<fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> as described above, and the naïve definition which <fr:tex display="inline"><![CDATA[E_{x}]]></fr:tex> is the
collection of objects <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> such that <fr:tex display="inline"><![CDATA[Pu = x]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <html:p>We have a functor <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex> taking a pair <fr:tex display="inline"><![CDATA[(x,(u,\phi _{u}))]]></fr:tex> to <fr:tex display="inline"><![CDATA[u]]></fr:tex>.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001V/</fr:uri>
                    <fr:display-uri>frct-001V</fr:display-uri>
                    <fr:route>/frct-001V/</fr:route>
                    <fr:taxon>Exercise</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Explicitly construct the functorial action of <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex>.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-001W/</fr:uri>
                    <fr:display-uri>frct-001W</fr:display-uri>
                    <fr:route>/frct-001W/</fr:route>
                    <fr:taxon>Exercise</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>Verify that <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex> is a categorical equivalence.</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:uri>https://www.jonmsterling.com/frct-000C/</fr:uri>
                    <fr:display-uri>frct-000C</fr:display-uri>
                    <fr:route>/frct-000C/</fr:route>
                    <fr:title text="Relationship to Street's fibrations">Relationship to Street's fibrations</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>In classical category theory, cartesian fibrations are defined by
  <fr:link href="/sga-1/" title="Revêtements étales et groupe fondamental (SGA 1)" uri="https://www.jonmsterling.com/sga-1/" display-uri="sga-1" type="local">Grothendieck</fr:link> to be certain functors <fr:tex display="inline"><![CDATA[E\to  B]]></fr:tex> such that any morphism <fr:tex display="inline"><![CDATA[f:x\to  Pv]]></fr:tex>
in <fr:tex display="inline"><![CDATA[B]]></fr:tex> lies strictly underneath a cartesian morphism in <fr:tex display="inline"><![CDATA[E]]></fr:tex>. As we have
discussed, this condition cannot be formulated unless equality is meaningful
for the collection of objects of <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:p>
                    <html:p>There is an alternative definition of cartesian fibration due to <fr:link href="/street-1980/" title="Fibrations in bicategories" uri="https://www.jonmsterling.com/street-1980/" display-uri="street-1980" type="local">Street</fr:link> that avoids
equality of objects; here we require for each <fr:tex display="inline"><![CDATA[f:x\to  Pv]]></fr:tex> a cartesian morphism
<fr:tex display="inline"><![CDATA[h:f^{*}v \to  v]]></fr:tex> together with an isomorphism <fr:tex display="inline"><![CDATA[\phi  : P(f^{*}v)\cong  x]]></fr:tex>
such that <fr:tex display="inline"><![CDATA[\phi ^{-1};Ph = f]]></fr:tex>.</html:p>
                    <html:p>By unrolling definitions, it is not difficult to see that the displayed
category <fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> is a cartesian fibration in our sense if and only if the functor
<fr:tex display="inline"><![CDATA[P:E\to  B]]></fr:tex> was a fibration in Street’s sense. Moreover, it can be seen that the
Grothendieck construction yields a <html:em>Grothendieck</html:em> fibration
<fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  B]]></fr:tex>; hence we have introduced by accident a convenient
destription of the <html:em>strictification</html:em> of Street fibrations into equivalent
Grothendieck fibrations.</html:p>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-000D/</fr:uri>
                <fr:display-uri>frct-000D</fr:display-uri>
                <fr:route>/frct-000D/</fr:route>
                <fr:title text="Iteration and pushforward">Iteration and pushforward</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>It also makes sense to speak of categories displayed over other displayed
categories; one way to formalize this notion is as follows. Let <fr:tex display="inline"><![CDATA[E]]></fr:tex> be
displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex>; we define a category displayed over <fr:tex display="inline"><![CDATA[E]]></fr:tex> to be simply a
category displayed over the total category <fr:tex display="inline"><![CDATA[\widetilde {E}]]></fr:tex>.</html:p>
                <html:p>Now let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be displayed over <fr:tex display="inline"><![CDATA[E]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex>. Then we may regard <fr:tex display="inline"><![CDATA[F]]></fr:tex> as a
displayed category <fr:tex display="inline"><![CDATA[B_{!}F]]></fr:tex> over <fr:tex display="inline"><![CDATA[B]]></fr:tex> as follows:</html:p>
                <html:ol><html:li>An object of <fr:tex display="inline"><![CDATA[(B_{!}F)_{x}]]></fr:tex> is a pair <fr:tex display="inline"><![CDATA[(\bar {x},{\ddot {x}})]]></fr:tex> with <fr:tex display="inline"><![CDATA[\bar {x}\in  E_{x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\ddot {x}}\in  F_{\bar {x}}]]></fr:tex>.</html:li>
<html:li>A morphism <fr:tex display="inline"><![CDATA[(\bar {x},{\ddot {x}})\xrightarrow [f]{}(\bar {y},{\ddot {y}})]]></fr:tex> is given by a pair <fr:tex display="inline"><![CDATA[(\bar {f},{\ddot {f}})]]></fr:tex> where <fr:tex display="inline"><![CDATA[\bar {f}:\bar {x}\xrightarrow [f]{}\bar {y}]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex> and <fr:tex display="inline"><![CDATA[{\ddot {f}}:{\ddot {x}}\xrightarrow [\bar {f}]{} {\ddot {y}}]]></fr:tex> in <fr:tex display="inline"><![CDATA[F]]></fr:tex>.</html:li></html:ol>
                <html:p>Using the <fr:link href="/frct-000B/" title="Displayed categories from functors" uri="https://www.jonmsterling.com/frct-000B/" display-uri="frct-000B" type="local">displayed category induced by a functor</fr:link>, we may define the <html:em>pushforward</html:em> of a displayed category along a functor. In particular, let <fr:tex display="inline"><![CDATA[E]]></fr:tex>
be displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex> and let <fr:tex display="inline"><![CDATA[U:B\to  C]]></fr:tex> be an ordinary functor; then we may
obtain a displayed category <fr:tex display="inline"><![CDATA[U_{!}E]]></fr:tex> over <fr:tex display="inline"><![CDATA[C]]></fr:tex> as follows:</html:p>
                <html:ol><html:li>First we construct the displayed category <fr:tex display="inline"><![CDATA[U_{\bullet }]]></fr:tex> corresponding to the
functor <fr:tex display="inline"><![CDATA[U:B \to  C]]></fr:tex>.</html:li>
<html:li>We recall that there is a canonical equivalence of categories
<fr:tex display="inline"><![CDATA[\widetilde {U_{\bullet }}\to  B]]></fr:tex>.</html:li>
<html:li>Because <fr:tex display="inline"><![CDATA[E]]></fr:tex> is displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex>, we may regard it as displayed over the
equivalent total category <fr:tex display="inline"><![CDATA[\widetilde {U_{\bullet }}]]></fr:tex> by
  <fr:link href="/frct-0007/" title="Change of base of displayed categories" uri="https://www.jonmsterling.com/frct-0007/" display-uri="frct-0007" type="local">change of base</fr:link>.</html:li>
<html:li>Hence we may define the pushforward <fr:tex display="inline"><![CDATA[U_{!}E]]></fr:tex> to be the displayed category <fr:tex display="inline"><![CDATA[(U_{\bullet })_{!}E]]></fr:tex> as defined above.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/frct-0007/</fr:uri>
            <fr:display-uri>frct-0007</fr:display-uri>
            <fr:route>/frct-0007/</fr:route>
            <fr:title text="Change of base of displayed categories">Change of base of displayed categories</fr:title>
            <fr:taxon>Construction</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Suppose that <fr:tex display="inline"><![CDATA[E]]></fr:tex> is displayed over <fr:tex display="inline"><![CDATA[B]]></fr:tex> and <fr:tex display="inline"><![CDATA[{X}\xrightarrow {{F}}{B}]]></fr:tex> is a
functor; then we may define a displayed category <fr:tex display="inline"><![CDATA[F^{*}E]]></fr:tex> as over <fr:tex display="inline"><![CDATA[X]]></fr:tex> follows:</html:p><html:ol><html:li>An object of <fr:tex display="inline"><![CDATA[(F^{*}E)_{x}]]></fr:tex> is an object of <fr:tex display="inline"><![CDATA[E_{Fx}]]></fr:tex>.</html:li>
  <html:li>Given <fr:tex display="inline"><![CDATA[\bar {x}\in  (F^{*}E)_{x}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\bar {y}\in  (F^{*}E)_{y}]]></fr:tex> and <fr:tex display="inline"><![CDATA[f : x \to  y]]></fr:tex>, a morphism <fr:tex display="inline"><![CDATA[\bar {x}\xrightarrow [f]{}\bar {y}]]></fr:tex> in <fr:tex display="inline"><![CDATA[F^{*}E]]></fr:tex> is given by a morphism <fr:tex display="inline"><![CDATA[\bar {x}\xrightarrow [Ff]{}\bar {y}]]></fr:tex> in <fr:tex display="inline"><![CDATA[E]]></fr:tex>.</html:li></html:ol><html:p>We visualize the change of base scenario as follows:</html:p>
 
  
  <html:figure><fr:resource hash="6571f70748320b5cd25dd01c2742f9af"><fr:resource-content><html:img src="/6571f70748320b5cd25dd01c2742f9af.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
  \DiagramSquare {
    nw/style = pullback,
    west/style = lies over,
    east/style = lies over,
    height = 1.5cm,
    nw = F^{*}{E},
    ne = E,
    sw = X,
    se = B,
    south = F,
  }
]]></fr:resource-source></fr:resource></html:figure>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://www.jonmsterling.com/frct-000B/</fr:uri>
            <fr:display-uri>frct-000B</fr:display-uri>
            <fr:route>/frct-000B/</fr:route>
            <fr:title text="Displayed categories from functors">Displayed categories from functors</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In many cases, one starts with a functor <fr:tex display="inline"><![CDATA[P:E\to  B]]></fr:tex>; if it were meaningful to speak of <html:em>equality</html:em> of objects in an arbitrary category then there would be an obvious construction of a displayed category <fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> from <fr:tex display="inline"><![CDATA[P]]></fr:tex>; we would simply set <fr:tex display="inline"><![CDATA[P_{x}]]></fr:tex> to be the collection of objects <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> such that <fr:tex display="inline"><![CDATA[Pu=x]]></fr:tex>. As it stands there is a more subtle version that will coincide up to categorical
equivalence with the naïve one in all cases that the latter is meaningful.</html:p>
            <html:ol><html:li>We define an object of <fr:tex display="inline"><![CDATA[P_{x}]]></fr:tex> to be a pair <fr:tex display="inline"><![CDATA[(u,\phi _{u})]]></fr:tex> where <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> and  <fr:tex display="inline"><![CDATA[\phi _{u} : Pu\cong  x]]></fr:tex>. It is good to visualize such a pair as a “crooked
  leg” like so:
    
 
  
  <html:figure><fr:resource hash="c5c482ac2e421eee635366bd7f6d1447"><fr:resource-content><html:img src="/c5c482ac2e421eee635366bd7f6d1447.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (u) {$u$};
        \node  (Pu) [below = 1cm of u] {$Pu$};
        \node  (x) [right = 1.5cm of Pu] {$x$};
        \draw [lies over] (u) to (Pu);
        \draw [->] (Pu) to node [below] {$\phi _{u}$} (x);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li>

  <html:li>A morphism <fr:tex display="inline"><![CDATA[(u,\phi _{u})\xrightarrow [f]{} (v,\phi _{v})]]></fr:tex> over <fr:tex display="inline"><![CDATA[f : x \to  y]]></fr:tex> is given by a morphism <fr:tex display="inline"><![CDATA[h : u\to  v]]></fr:tex> that lies over <fr:tex display="inline"><![CDATA[f]]></fr:tex> modulo the isomorphisms <fr:tex display="inline"><![CDATA[\phi _{u},\phi _{v}]]></fr:tex> in sense depicted below:


    
 
  
  <html:figure><fr:resource hash="52dd38c1ce55bea158fd4d9d3a0f2b17"><fr:resource-content><html:img src="/52dd38c1ce55bea158fd4d9d3a0f2b17.svg" /></fr:resource-content><fr:resource-source type="latex" part="preamble"><![CDATA[
   
  \RequirePackage{tikz}
 \RequirePackage{amsmath}
 \usetikzlibrary{backgrounds, intersections, calc, spath3, fit}

 \definecolor{catccolor}{RGB}{255,244,138}
 \tikzstyle{dot}=[circle, draw=black, fill=black, minimum size=1mm, inner sep=0mm]
 \tikzstyle{catc}=[catccolor!60]
 \tikzstyle{catd}=[orange!40]
 \tikzstyle{cate}=[red!40]
 \tikzstyle{catf}=[blue!10]
 \tikzstyle{catg}=[green!25]


 \tikzstyle{blue halo}=[fill=blue!10, opacity=0.7, rounded corners]
 \tikzstyle{white halo}=[fill=white, opacity=0.7, rounded corners]

 \NewDocumentCommand\CreateRect{D<>{} m m}{
   \path
     coordinate (#1nw)
     ++(#2,-#3) coordinate (#1se)
     coordinate (#1sw) at (#1se -| #1nw)
     coordinate (#1ne) at (#1nw -| #1se)
   ;

   \path[spath/save = #1north] (#1nw) to (#1ne);
   \path[spath/save = #1west] (#1nw) to (#1sw);
   \path[spath/save = #1east] (#1ne) to (#1se);
   \path[spath/save = #1south] (#1sw) to (#1se);
 }

   
  \usepackage{tikz, tikz-cd, mathtools, amssymb, stmaryrd}
 \usetikzlibrary{matrix,arrows}
 \usetikzlibrary{backgrounds,fit,positioning,calc,shapes}
 \usetikzlibrary{decorations.pathreplacing}
 \usetikzlibrary{decorations.pathmorphing}
 \usetikzlibrary{decorations.markings}

 \tikzset{
   desc/.style={sloped, fill=white,inner sep=2pt},
   upright desc/.style={fill=white,inner sep=2pt},
   pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pullback 45/.style = {
     append after command={
       \pgfextra{
         \draw[rotate = 45] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   ne pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,-.5cm)$) -- ++(-0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   sw pullback/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (.2cm,.5cm)$) -- ++(0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   dotted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [densely dotted] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   muted pullback/.style = {
     append after command={
       \pgfextra{
         \draw [gray] ($(\tikzlastnode) + (.2cm,-.5cm)$) -- ++(0.3cm,0) -- ++(0,0.3cm);
       }
     }
   },
   pushout/.style = {
     append after command={
       \pgfextra{
         \draw ($(\tikzlastnode) + (-.2cm,.5cm)$) -- ++(-0.3cm,0) -- ++(0,-0.3cm);
       }
     }
   },
   between/.style args={#1 and #2}{
     at = ($(#1)!0.5!(#2)$)
   },
   diagram/.style = {
     on grid,
     node distance=2cm,
     commutative diagrams/every diagram,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
     }
   },
   fibration/.style = {
     -{Triangle[open]}
   },
   etale/.style = {
     -{Triangle[open]}
   },
   etale cover/.style= {
     >={Triangle[open]},->.>
   },
   opfibration/.style = {
     -{Triangle}
   },
   lies over/.style = {
     |-{Triangle[open]}
   },
   op lies over/.style = {
     |-{Triangle}
   },
   embedding/.style = {
     {right hook}->
   },
   open immersion/.style = {
     {right hook}-{Triangle[open]}
   },
   closed immersion/.style = {
     {right hook}-{Triangle}
   },
   closed immersion*/.style = {
     {left hook}-{Triangle}
   },
   embedding*/.style = {
     {left hook}->
   },
   open immersion*/.style = {
     {left hook}-{Triangle[open]}
   },
   exists/.style = {
     densely dashed
   },
 }

 \newlength{\dontworryaboutit}

 \tikzset{
   inline diagram/.style = {
     commutative diagrams/every diagram,
     commutative diagrams/cramped,
     line width = .5pt,
     every node/.append style = {
       commutative diagrams/every cell,
       anchor = base,
       inner sep = 0pt
     },
     every path/.append style = {
       outer xsep = 2pt
     }
   }
 }

 \tikzset{
   square/nw/.style = {},
   square/ne/.style = {},
   square/se/.style = {},
   square/sw/.style = {},
   square/north/.style = {->},
   square/south/.style = {->},
   square/west/.style = {->},
   square/east/.style = {->},
   square/north/node/.style = {above},
   square/south/node/.style = {below},
   square/west/node/.style = {left},
   square/east/node/.style = {right},
 }

 \ExplSyntaxOn

 \bool_new:N \l_jon_glue_west

 \keys_define:nn { jon-tikz/diagram } {
   nw .tl_set:N = \l_jon_tikz_diagram_nw,
   sw .tl_set:N = \l_jon_tikz_diagram_sw,
   ne .tl_set:N = \l_jon_tikz_diagram_ne,
   se .tl_set:N = \l_jon_tikz_diagram_se,

   width .tl_set:N = \l_jon_tikz_diagram_width,
   height .tl_set:N = \l_jon_tikz_diagram_height,

   north .tl_set:N = \l_jon_tikz_diagram_north,
   south .tl_set:N = \l_jon_tikz_diagram_south,
   west .tl_set:N = \l_jon_tikz_diagram_west,
   east .tl_set:N = \l_jon_tikz_diagram_east,

   nw/style .code:n = {\tikzset{square/nw/.style = {#1}}},
   sw/style .code:n = {\tikzset{square/sw/.style = {#1}}},
   ne/style .code:n = {\tikzset{square/ne/.style = {#1}}},
   se/style .code:n = {\tikzset{square/se/.style = {#1}}},

   glue .choice:,
   glue / west .code:n = {\bool_set:Nn \l_jon_glue_west \c_true_bool},

   glue~target .tl_set:N = \l_jon_tikz_glue_target,

   north/style .code:n = {\tikzset{square/north/.style = {#1}}},
   north/node/style .code:n = {\tikzset{square/north/node/.style = {#1}}},
   south/style .code:n = {\tikzset{square/south/.style = {#1}}},
   south/node/style .code:n = {\tikzset{square/south/node/.style = {#1}}},
   west/style .code:n = {\tikzset{square/west/.style = {#1}}},
   west/node/style .code:n = {\tikzset{square/west/node/.style = {#1}}},
   east/style .code:n = {\tikzset{square/east/.style = {#1}}},
   east/node/style .code:n = {\tikzset{square/east/node/.style = {#1}}},

   draft .meta:n = {
     nw = {\__jon_tikz_diagram_fmt_placeholder:n {nw}},
     sw = {\__jon_tikz_diagram_fmt_placeholder:n {sw}},
     se = {\__jon_tikz_diagram_fmt_placeholder:n {se}},
     ne = {\__jon_tikz_diagram_fmt_placeholder:n {ne}},
     north = {\__jon_tikz_diagram_fmt_placeholder:n {north}},
     south = {\__jon_tikz_diagram_fmt_placeholder:n {south}},
     west = {\__jon_tikz_diagram_fmt_placeholder:n {west}},
     east = {\__jon_tikz_diagram_fmt_placeholder:n {east}},
   }
 }

 \tl_set:Nn \l_jon_tikz_diagram_width { 2cm }
 \tl_set:Nn \l_jon_tikz_diagram_height { 2cm }


 \cs_new:Npn \__jon_tikz_diagram_fmt_placeholder:n #1 {
   \texttt{\textcolor{red}{#1}}
 }

 \keys_set:nn { jon-tikz/diagram } {
   glue~target = {},
 }


 \cs_new:Nn \__jon_tikz_render_square:nn {
   \group_begin:
   \keys_set:nn {jon-tikz/diagram} {#2}
   \bool_if:nTF \l_jon_glue_west {
     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~\l_jon_tikz_glue_target ne,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (\l_jon_tikz_glue_target ne) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (\l_jon_tikz_glue_target se) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   } {
     \node (#1nw) [square/nw] {$\l_jon_tikz_diagram_nw$};
     \node (#1sw) [below = \l_jon_tikz_diagram_height~of~#1nw,square/sw] {$\l_jon_tikz_diagram_sw$};
     \draw[square/west] (#1nw) to node [square/west/node] {$\l_jon_tikz_diagram_west$} (#1sw);

     \node (#1ne) [right = \l_jon_tikz_diagram_width~of~#1nw,square/ne] {$\l_jon_tikz_diagram_ne$};
     \node (#1se) [below = \l_jon_tikz_diagram_height~of~#1ne,square/se] {$\l_jon_tikz_diagram_se$};
     \draw[square/north] (#1nw) to node [square/north/node] {$\l_jon_tikz_diagram_north$} (#1ne);
     \draw[square/east] (#1ne) to node [square/east/node] {$\l_jon_tikz_diagram_east$} (#1se);
     \draw[square/south] (#1sw) to node [square/south/node] {$\l_jon_tikz_diagram_south$} (#1se);
   }
   \group_end:
 }

 \NewDocumentCommand\SpliceDiagramSquare{D<>{}m}{
   \__jon_tikz_render_square:nn {#1} {#2}
 }


 \NewDocumentCommand\DiagramSquare{D<>{}O{}m}{
   \begin{tikzpicture}[diagram,#2,baseline=(#1sw.base)]
     \__jon_tikz_render_square:nn {#1} {#3}
   \end{tikzpicture}
 }

 \ExplSyntaxOff

  ]]></fr:resource-source><fr:resource-source type="latex" part="body"><![CDATA[
      \begin {tikzpicture}[diagram]
        \node  (pu) {$Pu$};
        \node  (pv) [right = of pu] {$Pv$};
        \node  (x) [below left = 1.5cm of pu] {$x$};
        \node  (y) [below right = 1.5cm of pv] {$y$};
        \node  (u) [above = 1.5cm of pu] {$u$};
        \node  (v) [above = 1.5cm of pv] {$v$};
        \draw [lies over] (u) to (pu);
        \draw [lies over] (v) to (pv);
        \draw [->] (u) to node [above] {$h$} (v);
        \draw [->] (x) to node [sloped,above] {$\phi _{u}^{-1}$} (pu);
        \draw [->] (pu) to node [upright desc] {$Ph$} (pv);
        \draw [->] (pv) to node [sloped,above] {$\phi _{v}$} (y);
        \draw [->,bend right=30] (x) to node [below] {$f$} (y);
      \end {tikzpicture}
    ]]></fr:resource-source></fr:resource></html:figure></html:li></html:ol>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-001U/</fr:uri>
                <fr:display-uri>frct-001U</fr:display-uri>
                <fr:route>/frct-001U/</fr:route>
                <fr:taxon>Exercise</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Suppose that <fr:tex display="inline"><![CDATA[B]]></fr:tex> is an internal category in <fr:tex display="inline"><![CDATA[\mathbf {Set}]]></fr:tex>, i.e.
it has a set of objects. Exhibit an equivalence of displayed categories between
<fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> as described above, and the naïve definition which <fr:tex display="inline"><![CDATA[E_{x}]]></fr:tex> is the
collection of objects <fr:tex display="inline"><![CDATA[u\in  E]]></fr:tex> such that <fr:tex display="inline"><![CDATA[Pu = x]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <html:p>We have a functor <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex> taking a pair <fr:tex display="inline"><![CDATA[(x,(u,\phi _{u}))]]></fr:tex> to <fr:tex display="inline"><![CDATA[u]]></fr:tex>.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-001V/</fr:uri>
                <fr:display-uri>frct-001V</fr:display-uri>
                <fr:route>/frct-001V/</fr:route>
                <fr:taxon>Exercise</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Explicitly construct the functorial action of <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-001W/</fr:uri>
                <fr:display-uri>frct-001W</fr:display-uri>
                <fr:route>/frct-001W/</fr:route>
                <fr:taxon>Exercise</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Verify that <fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  E]]></fr:tex> is a categorical equivalence.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:uri>https://www.jonmsterling.com/frct-000C/</fr:uri>
                <fr:display-uri>frct-000C</fr:display-uri>
                <fr:route>/frct-000C/</fr:route>
                <fr:title text="Relationship to Street's fibrations">Relationship to Street's fibrations</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>In classical category theory, cartesian fibrations are defined by
  <fr:link href="/sga-1/" title="Revêtements étales et groupe fondamental (SGA 1)" uri="https://www.jonmsterling.com/sga-1/" display-uri="sga-1" type="local">Grothendieck</fr:link> to be certain functors <fr:tex display="inline"><![CDATA[E\to  B]]></fr:tex> such that any morphism <fr:tex display="inline"><![CDATA[f:x\to  Pv]]></fr:tex>
in <fr:tex display="inline"><![CDATA[B]]></fr:tex> lies strictly underneath a cartesian morphism in <fr:tex display="inline"><![CDATA[E]]></fr:tex>. As we have
discussed, this condition cannot be formulated unless equality is meaningful
for the collection of objects of <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:p>
                <html:p>There is an alternative definition of cartesian fibration due to <fr:link href="/street-1980/" title="Fibrations in bicategories" uri="https://www.jonmsterling.com/street-1980/" display-uri="street-1980" type="local">Street</fr:link> that avoids
equality of objects; here we require for each <fr:tex display="inline"><![CDATA[f:x\to  Pv]]></fr:tex> a cartesian morphism
<fr:tex display="inline"><![CDATA[h:f^{*}v \to  v]]></fr:tex> together with an isomorphism <fr:tex display="inline"><![CDATA[\phi  : P(f^{*}v)\cong  x]]></fr:tex>
such that <fr:tex display="inline"><![CDATA[\phi ^{-1};Ph = f]]></fr:tex>.</html:p>
                <html:p>By unrolling definitions, it is not difficult to see that the displayed
category <fr:tex display="inline"><![CDATA[P_{\bullet }]]></fr:tex> is a cartesian fibration in our sense if and only if the functor
<fr:tex display="inline"><![CDATA[P:E\to  B]]></fr:tex> was a fibration in Street’s sense. Moreover, it can be seen that the
Grothendieck construction yields a <html:em>Grothendieck</html:em> fibration
<fr:tex display="inline"><![CDATA[\widetilde {P_{\bullet }}\to  B]]></fr:tex>; hence we have introduced by accident a convenient
destription of the <html:em>strictification</html:em> of Street fibrations into equivalent
Grothendieck fibrations.</html:p>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
